This file is a merged representation of the entire codebase, combined into a single document by Repomix.
The content has been processed where empty lines have been removed.

# File Summary

## Purpose
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  a. A header with the file path (## File: path/to/file)
  b. The full contents of the file in a code block

## Usage Guidelines
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

## Notes
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Empty lines have been removed from all files
- Files are sorted by Git change count (files with more changes are at the bottom)

# Directory Structure
```
.github/
  workflows/
    codecov.yml
    repomix.yml
backend/
  docs/
    ARCHITECTURE.md
    CONVENTIONS.md
    README.md
  src/
    auth/
      decorators/
        get-user.decorator.spec.ts
        get-user.decorator.ts
        index.ts
        roles.decorator.ts
      dto/
        index.ts
        login.dto.ts
        register.dto.ts
      enums/
        role.enum.spec.ts
        role.enum.ts
      guards/
        index.spec.ts
        index.ts
        jwt-auth.guard.spec.ts
        jwt-auth.guard.ts
        roles.guard.spec.ts
        roles.guard.ts
      interfaces/
        auth.interface.ts
      strategies/
        jwt.strategy.spec.ts
        jwt.strategy.ts
      auth.controller.spec.ts
      auth.controller.ts
      auth.module.spec.ts
      auth.module.ts
      auth.service.spec.ts
      auth.service.ts
    bookings/
      dto/
        booking-response.dto.ts
        create-booking.dto.ts
        create-walk-in-booking.dto.ts
        index.spec.ts
        index.ts
        upcoming-count-response.dto.spec.ts
        upcoming-count-response.dto.ts
        update-booking.dto.ts
      entities/
        booking.entity.ts
      bookings.controller.spec.ts
      bookings.controller.ts
      bookings.module.spec.ts
      bookings.module.ts
      bookings.service.spec.ts
      bookings.service.ts
    config/
      cache.config.spec.ts
      cache.config.ts
      database.config.spec.ts
      database.config.ts
      index.ts
      jwt.config.spec.ts
      jwt.config.ts
    database/
      migrations/
        1731981975581-InitialMigration.spec.ts
        1731981975581-InitialMigration.ts
        1731981975582-CreateBookingSystem.spec.ts
        1731981975582-CreateBookingSystem.ts
        1731981975583-CreateOrders.spec.ts
        1731981975583-CreateOrders.ts
        1731981975584-AddShopCodes.spec.ts
        1731981975584-AddShopCodes.ts
        1732141970009-ClearServices.spec.ts
        1732141970009-ClearServices.ts
        1732142680425-UpdateServices.spec.ts
        1732142680425-UpdateServices.ts
      seeds/
        create-admin-user.seed.spec.ts
        create-admin-user.seed.ts
        create-initial-data.seed.spec.ts
        create-initial-data.seed.ts
        create-sample-bookings.seed.spec.ts
        create-sample-bookings.seed.ts
        create-sample-orders.seed.spec.ts
        create-sample-orders.seed.ts
        create-services.seed.spec.ts
        create-services.seed.ts
        run-seeds.spec.ts
        run-seeds.ts
        seeder.interface.ts
        update-admin-password.seed.spec.ts
        update-admin-password.seed.ts
    employees/
      dto/
        create-employee.dto.spec.ts
        create-employee.dto.ts
        index.spec.ts
        index.ts
        update-employee.dto.spec.ts
        update-employee.dto.ts
      entities/
        employee.entity.spec.ts
        employee.entity.ts
      employees.controller.spec.ts
      employees.controller.ts
      employees.module.ts
      employees.service.spec.ts
      employees.service.ts
    orders/
      entities/
        order.entity.spec.ts
        order.entity.ts
      orders.controller.spec.ts
      orders.controller.ts
      orders.module.spec.ts
      orders.module.ts
      orders.service.spec.ts
      orders.service.ts
    services/
      entities/
        service.entity.spec.ts
        service.entity.ts
      services.controller.spec.ts
      services.controller.ts
      services.module.spec.ts
      services.module.ts
      services.service.spec.ts
      services.service.ts
    shops/
      entities/
        shop-code.entity.ts
      guards/
        shop-code.guard.spec.ts
        shop-code.guard.ts
      shops.module.spec.ts
      shops.module.ts
      shops.service.spec.ts
      shops.service.ts
    users/
      entities/
        user.entity.spec.ts
        user.entity.ts
      enums/
        role.enum.spec.ts
        role.enum.ts
      users.module.spec.ts
      users.module.ts
      users.service.spec.ts
      users.service.ts
    app.controller.spec.ts
    app.controller.ts
    app.module.spec.ts
    app.module.ts
    app.service.ts
    main.spec.ts
    main.ts
  test/
    app.e2e-spec.ts
    jest-e2e.json
  .gitignore
  eslint.config.js
  jest.config.js
  nest-cli.json
  package.json
  README.md
  renovate.json
  tsconfig.build.json
  tsconfig.json
  typeorm.config.ts
DOCS/
  ARCHITECTURE.md
  CONVENTIONS.md
  README.md
frontend/
  admin/
    .vscode/
      extensions.json
    docs/
      ARCHITECTURE.md
      CONVENTIONS.md
      README.md
    public/
      vite.svg
    src/
      assets/
        vue.svg
      components/
        base/
          __tests__/
            Button.spec.ts
            Card.spec.ts
          Button.vue
          Card.vue
        BookingDetailsModal.vue
        BookingEditModal.vue
        HelloWorld.vue
        OrdersChart.vue
      router/
        index.ts
      stores/
        __tests__/
          auth.spec.ts
        auth.ts
        bookings.ts
        employees.ts
        orders.ts
      types/
        components/
          button.ts
          index.ts
        index.ts
      views/
        __tests__/
          DashboardView.spec.ts
        BookingsView.vue
        DashboardView.vue
        EmployeesView.vue
        LoginView.vue
        OrdersView.vue
      App.vue
      env.d.ts
      main.ts
      style.css
      vite-env.d.ts
    .env.example
    .gitignore
    index.html
    package.json
    postcss.config.js
    README.md
    renovate.json
    tailwind.config.js
    tsconfig.app.json
    tsconfig.json
    tsconfig.node.json
    vite.config.ts
  customer/
    .vscode/
      extensions.json
    cypress/
      e2e/
        example.cy.ts
      fixtures/
        example.json
      support/
        commands.ts
        e2e.ts
      tsconfig.json
    docs/
      ARCHITECTURE.md
      CONVENTIONS.md
      README.md
    src/
      assets/
        base.css
        logo.svg
        main.css
      components/
        __tests__/
          BookingForm.spec.ts
          PaymentForm.spec.ts
          ServiceList.spec.ts
          WaitingTimeDisplay.spec.ts
        BookingForm.vue
        PaymentForm.vue
        ServiceList.vue
        WaitingTimeDisplay.vue
      router/
        index.ts
      stores/
        __tests__/
          booking.spec.ts
          counter.spec.ts
          display.spec.ts
          services.spec.ts
          waiting.spec.ts
        booking.ts
        counter.ts
        display.ts
        services.ts
        types.ts
        waiting.ts
      views/
        __tests__/
          TVDisplayView.spec.ts
        TVDisplayView.vue
      App.vue
      main.ts
    .editorconfig
    .gitignore
    .prettierrc.json
    cypress.config.ts
    env.d.ts
    eslint.config.js
    index.html
    package.json
    postcss.config.js
    README.md
    tailwind.config.js
    tsconfig.app.json
    tsconfig.json
    tsconfig.node.json
    tsconfig.vitest.json
    vite.config.ts
    vitest.config.ts
.gitattributes
.gitignore
codacy-fixes.txt
codecov.yml
CRITICAL.md
docker-compose.yml
Dockerfile
ISSUES.md
LICENSE
README.md
renovate.json
TODO.md
```

# Files

## File: .github/workflows/codecov.yml
````yaml
name: Run Codecov tests and upload coverage
on:
  push:
    paths:
      - "backend/**"
      - "frontend/customer/**"
jobs:
  backend-test:
    name: Run backend tests and collect coverage
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ./backend
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Set up Node
        uses: actions/setup-node@v4
        with:
          node-version: "22"
      - name: Install pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 8
          run_install: false
      - name: Get pnpm store directory
        shell: bash
        run: |
          echo "STORE_PATH=$(pnpm store path --silent)" >> $GITHUB_ENV
      - name: Setup pnpm cache
        uses: actions/cache@v4
        with:
          path: ${{ env.STORE_PATH }}
          key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-store-
      - name: Install dependencies
        run: pnpm install
      - name: Run tests
        run: pnpm test -- --coverage
      - name: Upload results to Codecov
        uses: codecov/codecov-action@v5
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
          directory: ./backend/coverage
          flags: backend
          fail_ci_if_error: true
  frontend-customer-test:
    name: Run frontend customer tests and collect coverage
    runs-on: ubuntu-latest
    defaults:
      run:
        working-directory: ./frontend/customer
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      - name: Set up Node
        uses: actions/setup-node@v4
        with:
          node-version: "22"
      - name: Install pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 8
          run_install: false
      - name: Get pnpm store directory
        shell: bash
        run: |
          echo "STORE_PATH=$(pnpm store path --silent)" >> $GITHUB_ENV
      - name: Setup pnpm cache
        uses: actions/cache@v4
        with:
          path: ${{ env.STORE_PATH }}
          key: ${{ runner.os }}-pnpm-store-${{ hashFiles('**/pnpm-lock.yaml') }}
          restore-keys: |
            ${{ runner.os }}-pnpm-store-
      - name: Install dependencies
        run: pnpm install
      - name: Run tests
        run: pnpm test:unit --coverage
      - name: Upload results to Codecov
        uses: codecov/codecov-action@v5
        with:
          token: ${{ secrets.CODECOV_TOKEN }}
          directory: ./frontend/customer/coverage
          flags: frontend-customer
          fail_ci_if_error: true
````

## File: backend/docs/ARCHITECTURE.md
````markdown
# Hair Salon Booking System Planning Document

## Table of Contents

- [Introduction](#introduction)
- [Project Objectives](#project-objectives)
- [Functional Requirements](#functional-requirements)
- [Non-Functional Requirements](#non-functional-requirements)
- [Technology Stack](#technology-stack)
- [System Architecture](#system-architecture)
- [Database Design](#database-design)
- [API Design](#api-design)
- [Frontend Design](#frontend-design)
- [Security Considerations](#security-considerations)
- [Scalability Considerations](#scalability-considerations)
- [Deployment Plan](#deployment-plan)
- [Timeline and Milestones](#timeline-and-milestones)
- [Conclusion](#conclusion)

---

## Introduction

This document outlines the planning phase for developing a full-stack booking system for a hair salon. The system aims to streamline the booking process for customers, manage appointments efficiently, and provide administrative capabilities for salon management and staff.

---

## Project Objectives

- Develop a scalable, production-ready booking platform tailored for hair salons.
- Implement a user-friendly frontend interface for customers to book appointments.
- Create an administrative dashboard for the salon's CEO and staff to manage bookings, schedules, and generate reports.
- Ensure the system is secure, fast, and maintainable for future enhancements.
- Expose a robust API for potential integration with other solutions.

---

## Functional Requirements

### Customer-Facing Features

- **User Registration and Authentication**: Customers can create accounts and securely log in.
- **Appointment Booking**: Browse available time slots and book appointments without double-booking conflicts.
- **Service Selection**: View and select from a list of services offered.
- **Booking Management**: View, modify, or cancel existing bookings.
- **Notifications**: Receive email/SMS confirmations and reminders.

### Employee Features

- **Employee Login**: Staff members have individual accounts to access their schedules.
- **Schedule Management**: View and manage personal appointment schedules.
- **Availability Settings**: Set availability and block out times when not available.

### Admin Features

- **Admin Dashboard**: Comprehensive overview of daily bookings, staff schedules, and salon performance.
- **User Management**: Add, modify, or remove employee accounts.
- **Reporting**: Generate reports on bookings, revenue, and employee performance; export data to Excel.
- **Service Management**: Add or update services offered, including pricing and duration.

---

## Non-Functional Requirements

- **Scalability**: Able to handle increased load, e.g., for large salons like Cutters.
- **Performance**: Fast load times and responsive interactions.
- **Security**: Protect user data with robust authentication and authorization mechanisms.
- **Maintainability**: Clean, well-documented codebase for future development.
- **Reliability**: Ensure high availability and fault tolerance.
- **Usability**: Intuitive user interface and user experience.
- **Compliance**: Adhere to relevant data protection regulations (e.g., GDPR).

---

## Technology Stack

### Backend

- **Language**: Node.js (JavaScript/TypeScript)
- **Framework**: [NestJS](https://nestjs.com/) for a scalable and maintainable structure.
  - Future-proof and supports enterprise-grade applications.
  - Built with TypeScript, encouraging type safety.
- **Database**:
  - **Primary**: PostgreSQL for relational data storage.
  - **Cache**: Redis for caching frequently accessed data and managing session data.
- **Authentication**: JSON Web Tokens (JWT) with refresh tokens for secure API access.
- **API Documentation**: Swagger/OpenAPI for documenting APIs.

### Frontend

- **Framework**: Vue 3
  - Known for its gentle learning curve and flexibility.
  - Composition API allows for better organization in larger applications.
- **State Management**: Pinia (the successor to Vuex) for managing application state.
- **Routing**: Vue Router for navigating between views.

### DevOps and Deployment

- **Containerization**: Docker for consistent environments across development, testing, and production.
- **Orchestration**: Kubernetes or Docker Compose for managing containers.
- **Continuous Integration/Continuous Deployment (CI/CD)**: Jenkins, GitHub Actions, or GitLab CI for automatic building, testing, and deployment.
- **Hosting**: Cloud provider like AWS, Azure, or Google Cloud Platform.

---

## System Architecture

### Overview

The system will follow a modular architecture separating the frontend, backend, and database layers.

1. **Frontend Client**:

   - Runs in the browser.
   - Communicates with the backend via RESTful API calls.
   - Provides interfaces for customers, employees, and admins based on roles.

2. **Backend API**:

   - Exposes RESTful endpoints for all functionalities.
   - Handles business logic, authentication, and authorization.
   - Interacts with the database and cache layers.

3. **Database Layer**:
   - PostgreSQL stores persistent relational data.
   - Redis used for session management, caching, and handling real-time features (e.g., notifications).

### Interaction Flow

1. A customer accesses the booking interface via the frontend.
2. The frontend communicates with the backend API to fetch available time slots.
3. Upon booking, the backend validates the request, ensures no double-booking via Redis locks, and stores the appointment in PostgreSQL.
4. Notifications are sent, and the employee's schedule is updated accordingly.

---

## Database Design

### Entities and Relationships

1. **Users**

   - **Attributes**: `id`, `name`, `email`, `password`, `role` (customer, employee, admin), `contact_info`, `created_at`, `updated_at`
   - Stores all user information with role-based access.

2. **Employees**

   - **Attributes**: `id`, `user_id`, `specializations`, `availability`, `created_at`, `updated_at`
   - Linked to the `Users` table via `user_id`.

3. **Services**

   - **Attributes**: `id`, `name`, `description`, `duration`, `price`, `created_at`, `updated_at`
   - List of services offered by the salon.

4. **Bookings**

   - **Attributes**: `id`, `customer_id`, `employee_id`, `service_id`, `start_time`, `end_time`, `status`, `created_at`, `updated_at`
   - Represents appointments; references `Users`, `Employees`, and `Services`.

5. **Payments** (Optional for future implementation)

   - **Attributes**: `id`, `booking_id`, `amount`, `payment_method`, `status`, `transaction_date`

6. **Reports**
   - Generated on-demand; data pulled from existing tables.

### Database Constraints

- **Uniqueness**: Ensure email addresses are unique in the `Users` table.
- **Foreign Keys**: Maintain referential integrity between tables.
- **Indexes**: Optimize queries on frequently accessed fields (e.g., `start_time` in `Bookings`).

---

## API Design

### Authentication

- **Endpoints**:
  - `POST /auth/register`: Register a new user.
  - `POST /auth/login`: Authenticate user and provide JWT.
  - `POST /auth/refresh`: Refresh access tokens.
- **Middleware**: Protect routes using JWT verification.

### Customer APIs

- `GET /services`: List all available services.
- `GET /employees`: View employees and their specializations.
- `GET /availability`: Check available time slots for a service and employee.
- `POST /bookings`: Create a new booking.
- `GET /bookings/{id}`: Retrieve booking details.
- `PUT /bookings/{id}`: Modify an existing booking.
- `DELETE /bookings/{id}`: Cancel a booking.

### Employee APIs

- `GET /employees/{id}/schedule`: View own schedule.
- `PUT /employees/{id}/availability`: Update availability.

### Admin APIs

- `GET /admin/dashboard`: Get overview statistics.
- `POST /admin/employees`: Add a new employee.
- `PUT /admin/employees/{id}`: Update employee details.
- `DELETE /admin/employees/{id}`: Remove an employee.
- `POST /admin/services`: Add a new service.
- `PUT /admin/services/{id}`: Update service details.
- `DELETE /admin/services/{id}`: Remove a service.
- `GET /admin/reports`: Generate and retrieve reports.

### Error Handling

- Use standardized HTTP status codes.
- Return error messages with details to assist in debugging (avoid exposing sensitive information).

---

## Frontend Design

### User Interface Components

#### Customers

- **Home Page**: Introduction and quick access to booking.
- **Service Catalog**: Display services with details.
- **Booking Flow**:
  1. Select Service.
  2. Choose Employee (optional or auto-assigned).
  3. Pick Date and Time.
  4. Confirm Booking.
- **User Account**:
  - View upcoming and past appointments.
  - Edit personal information.

#### Employees

- **Dashboard**: Overview of today's appointments.
- **Schedule View**: Calendar with upcoming bookings.
- **Availability Settings**: Interface to block out unavailable times.

#### Admins

- **Admin Dashboard**: Key metrics and alerts.
- **Employee Management**: CRUD operations for employee accounts.
- **Service Management**: Add or modify services.
- **Reporting Tools**: Generate and export reports.

### UX/UI Considerations

- **Responsive Design**: Ensure usability on desktops, tablets, and mobile devices.
- **Accessibility**: Adhere to WCAG guidelines for inclusive design.
- **Consistency**: Use a design system or component library (e.g., Vuetify) for uniformity.

---

## Security Considerations

- **Authentication**: Implement robust authentication with password hashing (e.g., bcrypt) and secure JWT handling.
- **Authorization**: Role-based access control to restrict resources.
- **Input Validation**: Sanitize and validate all user inputs to prevent SQL injection and XSS attacks.
- **Data Protection**: Encrypt sensitive data at rest and in transit (use HTTPS with TLS).
- **Rate Limiting**: Protect against brute-force attacks by limiting login attempts.
- **Audit Logging**: Maintain logs of critical actions for auditing purposes.

---

## Scalability Considerations

- **Stateless Backend**: Design the backend to be stateless to facilitate horizontal scaling.
- **Load Balancing**: Use a load balancer to distribute traffic across multiple server instances.
- **Caching Strategy**: Implement caching for frequent read operations using Redis.
- **Database Optimization**: Use indexing and query optimization; consider read replicas for PostgreSQL.
- **Asynchronous Processing**: Use message queues (e.g., RabbitMQ) for background tasks like sending notifications.

---

## Deployment Plan

### Environments

1. **Development**
   - Local machines with hot-reloading for rapid development.
2. **Testing/Staging**
   - Mirror production environment for testing features before release.
3. **Production**
   - Live environment with robust monitoring and backup strategies.

### CI/CD Pipeline

- **Code Repository**: Use Git for version control (GitHub, GitLab).
- **Automated Testing**: Run unit and integration tests on every push.
- **Build and Deployment**: Automate using CI/CD tools to reduce manual errors.

### Monitoring and Logging

- **Application Monitoring**: Use tools like Prometheus and Grafana.
- **Error Tracking**: Implement Sentry or similar for error logging.
- **Health Checks**: Set up endpoint and infrastructure health checks.

---

## Timeline and Milestones

| Phase                     | Duration | Key Deliverables                                   |
| ------------------------- | -------- | -------------------------------------------------- |
| **Requirements Analysis** | 1 week   | Finalize specifications and user stories           |
| **Design**                | 2 weeks  | System architecture, database schema, UI mockups   |
| **Backend Development**   | 4 weeks  | API endpoints, authentication, business logic      |
| **Frontend Development**  | 4 weeks  | UI components, state management, API integration   |
| **Testing**               | 2 weeks  | Unit tests, integration tests, user acceptance     |
| **Deployment Setup**      | 1 week   | CI/CD pipeline, server setup, domain configuration |
| **Beta Release**          | 1 week   | Deploy to staging, gather feedback                 |
| **Final Adjustments**     | 1 week   | Bug fixes, performance tuning                      |
| **Launch**                | -        | Deploy to production                               |

_Total Estimated Time: Approximately 3 months_

---

## Conclusion

This planning document outlines a comprehensive approach to developing a full-stack hair salon booking system that is scalable, secure, and user-friendly. By leveraging modern technologies and adhering to best practices in software development, the final product aims to meet the immediate needs of hair salons while being adaptable for future growth and integration.

---

**Next Steps**:

- Review and approve the planning document.
- Set up initial development environments.
- Begin the requirements analysis phase with stakeholder meetings.
````

## File: backend/docs/CONVENTIONS.md
````markdown
# Code Conventions and Best Practices

## General Principles

- Follow TDD (Test-Driven Development)
- Apply DRY (Don't Repeat Yourself)
- Follow KISS (Keep It Simple, Stupid)
- Apply YAGNI (You Aren't Gonna Need It)
- Follow SOLID Principles:
  - Single Responsibility
  - Open/Closed
  - Liskov Substitution
  - Interface Segregation
  - Dependency Inversion

## TypeScript/JavaScript Conventions

### Naming Conventions

- Use `PascalCase` for:
  - Classes
  - Interfaces
  - Type aliases
  - Enums
- Use `camelCase` for:
  - Variables
  - Functions
  - Methods
  - Properties
  - Parameters
- Use `UPPER_SNAKE_CASE` for constants
- Use descriptive names that reflect the purpose

### File Naming

- Use `kebab-case` for file names
- Suffix files based on their type:
  - `.controller.ts` for controllers
  - `.service.ts` for services
  - `.entity.ts` for database entities
  - `.dto.ts` for Data Transfer Objects
  - `.spec.ts` for test files

### Code Organization

- One class per file
- Group related functionality in modules
- Keep files focused and small
- Use barrel exports (index.ts) for clean imports

## Testing Conventions

### Test Structure

- Follow the AAA pattern:
  - Arrange: Set up test data
  - Act: Execute the code being tested
  - Assert: Verify the results
- Use descriptive test names that explain the scenario
- Group related tests using describe blocks
- Mock external dependencies

### Test Coverage

- Aim for 80%+ code coverage
- Write unit tests for:
  - Services
  - Controllers
  - Guards
  - Pipes
  - Custom decorators
- Include integration tests for:
  - API endpoints
  - Database operations

## API Conventions

### RESTful Endpoints

- Use plural nouns for resources
- Follow HTTP method semantics:
  - GET: Read
  - POST: Create
  - PUT: Full update
  - PATCH: Partial update
  - DELETE: Remove
- Use proper HTTP status codes

### Request/Response

- Use DTOs for request validation
- Follow consistent response format:
  ```typescript
  {
    success: boolean;
    data?: any;
    error?: {
      code: string;
      message: string;
    }
  }
  ```

## Database Conventions

### Entity Design

- Use singular names for entity classes
- Include created_at and updated_at timestamps
- Use proper column types and constraints
- Define explicit relationships

### Migrations

- One migration per change
- Descriptive migration names
- Include both up and down migrations
- Test migrations before deployment

## Documentation

- Use JSDoc for code documentation
- Keep README files up to date
- Document API endpoints using Swagger
- Include setup instructions

## Version Control

- Write clear commit messages
- Use feature branches
- Follow conventional commits format:
  - feat: New feature
  - fix: Bug fix
  - docs: Documentation
  - style: Formatting
  - refactor: Code restructuring
  - test: Adding tests
  - chore: Maintenance

## Error Handling

- Use custom exception filters
- Implement proper logging
- Return appropriate error responses
- Handle async/await properly with try/catch

## Security

- Validate all inputs
- Sanitize data before storage
- Use proper authentication/authorization
- Follow security best practices
- Keep dependencies updated

## Performance

- Use appropriate caching strategies
- Optimize database queries
- Implement pagination for lists
- Monitor and optimize resource usage
````

## File: backend/docs/README.md
````markdown
# Hair Salon Booking System Documentation

## Overview

This is a full-stack booking system for hair salons built using NestJS (backend) and Vue 3 (frontend). The system allows customers to book appointments, employees to manage their schedules, and administrators to oversee all operations.

## Project Structure

```
├── backend/               # NestJS backend application
├── frontend/             # Vue 3 frontend application
├── docs/                 # Project documentation
└── architecture/         # System architecture and planning
```

## Technology Stack

### Backend

- NestJS (TypeScript)
- PostgreSQL (Database)
- Redis (Caching)
- Jest (Testing)
- Swagger (API Documentation)

### Frontend

- Vue 3
- Pinia (State Management)
- Vue Router
- TypeScript

## Getting Started

### Prerequisites

- Node.js (v16 or higher)
- npm or yarn
- PostgreSQL
- Redis
- Docker (optional)

### Backend Setup

1. Navigate to the backend directory:
   ```bash
   cd backend
   ```

2. Install dependencies:
   ```bash
   npm install
   ```

3. Set up environment variables:
   - Copy `.env.example` to `.env`
   - Update the variables with your configuration

4. Run database migrations:
   ```bash
   npm run migration:run
   ```

5. Start the development server:
   ```bash
   npm run start:dev
   ```

The API will be available at `http://localhost:3000`
Swagger documentation will be at `http://localhost:3000/api`

### Running Tests

```bash
# Unit tests
npm run test

# e2e tests
npm run test:e2e

# Test coverage
npm run test:cov
```

## Development Guidelines

### Code Style

- Follow the conventions defined in [CONVENTIONS.md](./CONVENTIONS.md)
- Use ESLint and Prettier for code formatting
- Write tests for all new features
- Follow TDD principles

### Git Workflow

1. Create a feature branch from `develop`:
   ```bash
   git checkout -b feature/your-feature-name
   ```

2. Make your changes following the conventions

3. Write tests for your changes

4. Commit your changes using conventional commits

5. Create a pull request to `develop`

### Database Changes

1. Create a new migration:
   ```bash
   npm run migration:create -- -n YourMigrationName
   ```

2. Update the migration file with your changes

3. Test the migration:
   ```bash
   npm run migration:run
   ```

4. Test the rollback:
   ```bash
   npm run migration:revert
   ```

## API Documentation

- API documentation is available through Swagger at `/api` when running the backend
- Keep the Swagger documentation up to date when making API changes
- Follow the API conventions defined in [CONVENTIONS.md](./CONVENTIONS.md)

## Testing Strategy

### Unit Tests

- Write unit tests for:
  - Services
  - Controllers
  - Guards
  - Pipes
  - Custom decorators

### Integration Tests

- Write integration tests for:
  - API endpoints
  - Database operations
  - Cache operations

### E2E Tests

- Write end-to-end tests for critical user flows
- Test the integration between frontend and backend

## Deployment

### Development

- Use `npm run start:dev` for local development
- Development server runs at `http://localhost:3000`

### Production

1. Build the application:
   ```bash
   npm run build
   ```

2. Start the production server:
   ```bash
   npm run start:prod
   ```

### Docker

1. Build the Docker image:
   ```bash
   docker build -t hair-salon-booking .
   ```

2. Run the container:
   ```bash
   docker run -p 3000:3000 hair-salon-booking
   ```

## Monitoring and Logging

- Use built-in NestJS logging
- Monitor application performance
- Track error rates and API usage
- Set up alerts for critical issues

## Security

- Follow security best practices
- Keep dependencies updated
- Use proper authentication and authorization
- Validate all inputs
- Implement rate limiting
- Use HTTPS in production

## Support

1. Check the existing documentation
2. Review the codebase and tests
3. Contact the development team

## License

This project is licensed under the terms specified in the LICENSE file at the root of the repository.
````

## File: backend/src/auth/decorators/get-user.decorator.spec.ts
````typescript
import { ExecutionContext, Type } from "@nestjs/common";
import { GetUser } from "./get-user.decorator";
import { User, UserRole } from "../../users/entities/user.entity";
import { Request } from "express";
import {
  HttpArgumentsHost,
  RpcArgumentsHost,
  WsArgumentsHost,
} from "@nestjs/common/interfaces";
interface RequestWithUser extends Request {
  user?: User;
}
describe("GetUser", () => {
  const mockUser: User = {
    id: "user-1",
    email: "test@example.com",
    firstName: "Test",
    lastName: "User",
    password: "hashed_password",
    role: UserRole.CUSTOMER,
    phoneNumber: null,
    createdAt: new Date(),
    updatedAt: new Date(),
    async validatePassword(): Promise<boolean> {
      await Promise.resolve();
      return true;
    },
    async hashPassword(): Promise<void> {
      await Promise.resolve();
    },
  };
  // Extract the factory function from the decorator
  const decoratorFunction = (
    data: unknown,
    ctx: ExecutionContext
  ): User | undefined => {
    const request = ctx.switchToHttp().getRequest<RequestWithUser>();
    return request.user;
  };
  function createMockExecutionContext(
    request: Partial<RequestWithUser>
  ): ExecutionContext {
    // Cast the mock implementations to their respective interfaces
    const mockHttpContext = {
      getRequest: <T>() => request as T,
      getResponse: <T>() => ({}) as T,
      getNext: <T>() => (() => {}) as T,
    } as HttpArgumentsHost;
    const mockRpcContext = {
      getData: <T>() => ({}) as T,
      getContext: <T>() => ({}) as T,
    } as RpcArgumentsHost;
    const mockWsContext = {
      getData: <T>() => ({}) as T,
      getClient: <T>() => ({}) as T,
      getPattern: () => "",
    } as WsArgumentsHost;
    const mockExecutionContext = {
      switchToHttp: () => mockHttpContext,
      switchToRpc: () => mockRpcContext,
      switchToWs: () => mockWsContext,
      getType: () => "http",
      getClass: () => Object as Type<unknown>,
      getHandler: () => () => {},
      getArgs: () => [],
      getArgByIndex: () => null,
    } as ExecutionContext;
    return mockExecutionContext;
  }
  it("should extract user from request", () => {
    const mockContext = createMockExecutionContext({ user: mockUser });
    const result = decoratorFunction(undefined, mockContext);
    expect(result).toEqual(mockUser);
  });
  it("should handle missing user in request", () => {
    const mockContext = createMockExecutionContext({});
    const result = decoratorFunction(undefined, mockContext);
    expect(result).toBeUndefined();
  });
  it("should ignore data parameter", () => {
    const mockContext = createMockExecutionContext({ user: mockUser });
    const result = decoratorFunction("some-data", mockContext);
    expect(result).toEqual(mockUser);
  });
  it("should be defined", () => {
    expect(GetUser).toBeDefined();
  });
});
````

## File: backend/src/auth/decorators/get-user.decorator.ts
````typescript
import { createParamDecorator, ExecutionContext } from '@nestjs/common';
import { User } from '../../users/entities/user.entity';
import { Request } from 'express';
interface RequestWithUser extends Request {
  user: User;
}
export const GetUser = createParamDecorator(
  (data: unknown, ctx: ExecutionContext): User => {
    const request = ctx.switchToHttp().getRequest<RequestWithUser>();
    if (!request.user) {
      throw new Error('User not found in request');
    }
    const user: User = request.user;
    return user;
  },
);
````

## File: backend/src/auth/decorators/index.ts
````typescript
export * from "./roles.decorator";
````

## File: backend/src/auth/decorators/roles.decorator.ts
````typescript
import { SetMetadata } from "@nestjs/common";
import { UserRole } from "../../users/entities/user.entity";
export const Roles = (...roles: UserRole[]): MethodDecorator => {
  const decorator: MethodDecorator = SetMetadata("roles", roles);
  return decorator;
};
````

## File: backend/src/auth/dto/index.ts
````typescript
export * from "./login.dto";
export * from "./register.dto";
````

## File: backend/src/auth/enums/role.enum.spec.ts
````typescript
import { Role } from './role.enum';
describe('Role Enum', () => {
  it('should define USER role', () => {
    expect(Role.USER).toBeDefined();
    expect(Role.USER).toBe('user');
  });
  it('should define ADMIN role', () => {
    expect(Role.ADMIN).toBeDefined();
    expect(Role.ADMIN).toBe('admin');
  });
  it('should define EMPLOYEE role', () => {
    expect(Role.EMPLOYEE).toBeDefined();
    expect(Role.EMPLOYEE).toBe('employee');
  });
  it('should have exactly three roles', () => {
    const roleValues = Object.values(Role);
    expect(roleValues).toHaveLength(3);
    expect(roleValues).toEqual(['user', 'admin', 'employee']);
  });
  it('should be usable in type checks', () => {
    const checkRole = (role: Role): boolean => {
      return Object.values(Role).includes(role);
    };
    expect(checkRole(Role.USER)).toBe(true);
    expect(checkRole(Role.ADMIN)).toBe(true);
    expect(checkRole(Role.EMPLOYEE)).toBe(true);
    expect(checkRole('invalid' as Role)).toBe(false);
  });
  it('should be usable in switch statements', () => {
    const getRoleLevel = (role: Role): number => {
      switch (role) {
        case Role.ADMIN:
          return 3;
        case Role.EMPLOYEE:
          return 2;
        case Role.USER:
          return 1;
        default:
          return 0;
      }
    };
    expect(getRoleLevel(Role.ADMIN)).toBe(3);
    expect(getRoleLevel(Role.EMPLOYEE)).toBe(2);
    expect(getRoleLevel(Role.USER)).toBe(1);
  });
});
````

## File: backend/src/auth/enums/role.enum.ts
````typescript
export enum Role {
  USER = 'user',
  ADMIN = 'admin',
  EMPLOYEE = 'employee',
}
````

## File: backend/src/auth/guards/index.spec.ts
````typescript
import { JwtAuthGuard } from './jwt-auth.guard';
import { RolesGuard } from './roles.guard';
import * as guards from './index';
describe('Guards barrel exports', () => {
  it('should export JwtAuthGuard', () => {
    expect(guards.JwtAuthGuard).toBeDefined();
    expect(guards.JwtAuthGuard).toBe(JwtAuthGuard);
  });
  it('should export RolesGuard', () => {
    expect(guards.RolesGuard).toBeDefined();
    expect(guards.RolesGuard).toBe(RolesGuard);
  });
});
````

## File: backend/src/auth/guards/index.ts
````typescript
export * from "./jwt-auth.guard";
export * from "./roles.guard";
````

## File: backend/src/auth/guards/jwt-auth.guard.spec.ts
````typescript
import { ExecutionContext, UnauthorizedException } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';
import { JwtAuthGuard } from './jwt-auth.guard';
import { Test, TestingModule } from '@nestjs/testing';
describe('JwtAuthGuard', () => {
  let guard: JwtAuthGuard;
  interface RequestMock {
    headers: {
      authorization?: string | string[];
    };
  }
  const createMockContext = (request: RequestMock): ExecutionContext => ({
    switchToHttp: jest.fn().mockReturnValue({
      getRequest: jest.fn().mockReturnValue(request),
    }),
    getHandler: jest.fn(),
    getClass: jest.fn(),
    getArgs: jest.fn(),
    getArgByIndex: jest.fn(),
    switchToRpc: jest.fn(),
    switchToWs: jest.fn(),
    getType: jest.fn(),
  } as unknown as ExecutionContext);
  const testUnauthorizedScenario = (
    scenario: {
      headers: { authorization?: string | string[] },
      expectedError: string
    }
  ) => {
    const context = createMockContext({ headers: scenario.headers });
    expect(() => guard.canActivate(context)).toThrow(
      new UnauthorizedException(scenario.expectedError)
    );
  };
  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [JwtAuthGuard],
    }).compile();
    guard = module.get<JwtAuthGuard>(JwtAuthGuard);
  });
  describe('canActivate', () => {
    const authorizationScenarios = [
      {
        description: 'missing Authorization header',
        headers: {},
        expectedError: 'Missing Authorization header'
      },
      {
        description: 'non-string Authorization header',
        headers: { authorization: ['Bearer token'] },
        expectedError: 'Invalid Authorization header format'
      },
      {
        description: 'wrong auth type',
        headers: { authorization: 'Basic token' },
        expectedError: 'Authorization header must start with "Bearer "'
      },
      {
        description: 'wrong format',
        headers: { authorization: 'Bearer token extra' },
        expectedError: 'Invalid Authorization header format'
      },
      {
        description: 'missing token',
        headers: { authorization: 'Bearer ' },
        expectedError: 'Token not provided'
      }
    ];
    authorizationScenarios.forEach(scenario => {
      it(`should throw UnauthorizedException when ${scenario.description}`, () => {
        testUnauthorizedScenario(scenario);
      });
    });
    it('should call super.canActivate when token is valid', () => {
      const context = createMockContext({
        headers: { authorization: 'Bearer valid-token' }
      });
      const superCanActivateSpy = jest
        .spyOn(AuthGuard('jwt').prototype, 'canActivate')
        .mockImplementation(() => true);
      const result = guard.canActivate(context);
      expect(result).toBe(true);
      expect(superCanActivateSpy).toHaveBeenCalledWith(context);
    });
  });
  describe('handleRequest', () => {
    type JwtErrorName = 'JsonWebTokenError' | 'TokenExpiredError';
    interface JwtError extends Error {
      name: JwtErrorName;
    }
    function createJwtError(message: string, name: JwtErrorName): JwtError {
      const error = new Error(message) as JwtError;
      error.name = name;
      return error;
    }
    const testErrorScenario = (
      error: Error | string | null,
      info: JwtError | null,
      expectedError: UnauthorizedException | Error
    ) => {
      const finalError = typeof error === 'string' ? new Error(error) : error;
      expect(() => guard.handleRequest(finalError, false, info)).toThrow(expectedError);
    };
    it('should return user when authentication is successful', () => {
      const user = { id: '1', email: 'test@example.com' };
      const result = guard.handleRequest(null, user, null);
      expect(result).toBe(user);
    });
    const errorScenarios: Array<{
      description: string;
      error: Error | string | null;
      info: JwtError | null;
      expectedError: UnauthorizedException | Error;
    }> = [
      {
        description: 'user not authenticated',
        error: null,
        info: null,
        expectedError: new UnauthorizedException('User not authenticated')
      },
      {
        description: 'invalid token format',
        error: null,
        info: createJwtError('invalid token', 'JsonWebTokenError'),
        expectedError: new UnauthorizedException('Invalid token format')
      },
      {
        description: 'expired token',
        error: null,
        info: createJwtError('jwt expired', 'TokenExpiredError'),
        expectedError: new UnauthorizedException('Token has expired')
      }
    ];
    errorScenarios.forEach(scenario => {
      it(`should throw UnauthorizedException for ${scenario.description}`, () => {
        testErrorScenario(scenario.error, scenario.info, scenario.expectedError);
      });
    });
    it('should throw original error when error is provided', () => {
      const error = new Error('Custom error');
      testErrorScenario(error, null, error);
    });
    it('should convert non-Error error to UnauthorizedException', () => {
      const errorMessage = 'string error';
      testErrorScenario(
        errorMessage,
        null,
        new UnauthorizedException(errorMessage)
      );
    });
  });
});
````

## File: backend/src/auth/guards/jwt-auth.guard.ts
````typescript
import { Injectable, ExecutionContext, UnauthorizedException, Logger } from "@nestjs/common";
import { AuthGuard } from "@nestjs/passport";
import { User } from "../../users/entities/user.entity";
import { Request } from "express";
import { Observable } from 'rxjs';
interface JwtError extends Error {
  name: 'JsonWebTokenError' | 'TokenExpiredError';
}
@Injectable()
export class JwtAuthGuard extends AuthGuard("jwt") {
  private readonly logger = new Logger(JwtAuthGuard.name);
  canActivate(context: ExecutionContext): boolean | Promise<boolean> | Observable<boolean> {
    const request = context.switchToHttp().getRequest<Request>();
    const authHeader = request.headers.authorization;
    // Check if Authorization header exists and is properly formatted
    if (!authHeader) {
      throw new UnauthorizedException('Missing Authorization header');
    }
    if (typeof authHeader !== 'string') {
      throw new UnauthorizedException('Invalid Authorization header format');
    }
    if (!authHeader.startsWith('Bearer ')) {
      throw new UnauthorizedException('Authorization header must start with "Bearer "');
    }
    const parts = authHeader.split(' ');
    if (parts.length !== 2) {
      throw new UnauthorizedException('Invalid Authorization header format');
    }
    const [, token] = parts;
    if (!token || typeof token !== 'string') {
      throw new UnauthorizedException('Token not provided');
    }
    // Add debug logging
    console.log('JWT Auth Guard - Token:', token);
    try {
      const result = super.canActivate(context);
      if (result instanceof Observable) {
        return result;
      }
      if (result instanceof Promise) {
        return result;
      }
      return result;
    } catch (error) {
      this.logger.error('Error in canActivate:', error);
      throw new UnauthorizedException('Authentication failed');
    }
  }
  handleRequest<TUser = User>(
    err: Error | null,
    user: TUser | false,
    info: JwtError | null
  ): TUser {
    // Add debug logging
    const errorMessage = err instanceof Error ? err.message : String(err);
    const infoMessage = info instanceof Error ? info.message : String(info);
    console.log('JWT Auth Guard - Error:', errorMessage);
    console.log('JWT Auth Guard - User:', user);
    console.log('JWT Auth Guard - Info:', infoMessage);
    // Handle specific JWT errors
    if (info instanceof Error) {
      switch (info.name) {
        case 'JsonWebTokenError':
          throw new UnauthorizedException('Invalid token format');
        case 'TokenExpiredError':
          throw new UnauthorizedException('Token has expired');
      }
    }
    if (err) {
      throw err instanceof Error ? err : new UnauthorizedException(String(err));
    }
    if (!user) {
      throw new UnauthorizedException('User not authenticated');
    }
    return user;
  }
}
````

## File: backend/src/auth/guards/roles.guard.spec.ts
````typescript
import { Test, TestingModule } from '@nestjs/testing';
import { Reflector } from '@nestjs/core';
import { ExecutionContext } from '@nestjs/common';
import { RolesGuard } from './roles.guard';
import { UserRole } from '../../users/entities/user.entity';
describe('RolesGuard', () => {
  let guard: RolesGuard;
  let reflector: Reflector;
  const mockReflector = {
    getAllAndOverride: jest.fn(),
  };
  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        RolesGuard,
        {
          provide: Reflector,
          useValue: mockReflector,
        },
      ],
    }).compile();
    guard = module.get<RolesGuard>(RolesGuard);
    reflector = module.get<Reflector>(Reflector);
  });
  it('should be defined', () => {
    expect(guard).toBeDefined();
  });
  describe('canActivate', () => {
    let mockExecutionContext: ExecutionContext;
    let mockGetRequest: jest.Mock;
    beforeEach(() => {
      mockGetRequest = jest.fn().mockReturnValue({
        user: {
          role: UserRole.CUSTOMER,
        },
      });
      mockExecutionContext = {
        getHandler: jest.fn(),
        getClass: jest.fn(),
        switchToHttp: jest.fn().mockReturnValue({
          getRequest: mockGetRequest,
        }),
      } as unknown as ExecutionContext;
    });
    it('should allow access when no roles are required', () => {
      mockReflector.getAllAndOverride.mockReturnValue(null);
      const result = guard.canActivate(mockExecutionContext);
      expect(result).toBe(true);
      expect(reflector.getAllAndOverride).toHaveBeenCalledWith('roles', [
        mockExecutionContext.getHandler(),
        mockExecutionContext.getClass(),
      ]);
    });
    it('should allow access when user has required role', () => {
      mockReflector.getAllAndOverride.mockReturnValue([UserRole.CUSTOMER]);
      const result = guard.canActivate(mockExecutionContext);
      expect(result).toBe(true);
    });
    it('should deny access when user does not have required role', () => {
      mockReflector.getAllAndOverride.mockReturnValue([UserRole.ADMIN]);
      const result = guard.canActivate(mockExecutionContext);
      expect(result).toBe(false);
    });
    it('should allow access when user has one of multiple required roles', () => {
      mockReflector.getAllAndOverride.mockReturnValue([
        UserRole.ADMIN,
        UserRole.CUSTOMER,
      ]);
      const result = guard.canActivate(mockExecutionContext);
      expect(result).toBe(true);
    });
    it('should handle roles defined at both handler and class level', () => {
      mockReflector.getAllAndOverride.mockReturnValue([UserRole.CUSTOMER]);
      const mockContext = {
        ...mockExecutionContext,
        getHandler: jest.fn(),
        getClass: jest.fn(),
      };
      const result = guard.canActivate(mockContext as ExecutionContext);
      expect(result).toBe(true);
      expect(reflector.getAllAndOverride).toHaveBeenCalledWith('roles', [
        mockContext.getHandler(),
        mockContext.getClass(),
      ]);
    });
    it('should deny access when user is null', () => {
      mockReflector.getAllAndOverride.mockReturnValue([UserRole.CUSTOMER]);
      mockGetRequest.mockReturnValue({
        user: null,
      });
      const result = guard.canActivate(mockExecutionContext);
      expect(result).toBe(false);
    });
    it('should deny access when user.role is null', () => {
      mockReflector.getAllAndOverride.mockReturnValue([UserRole.CUSTOMER]);
      mockGetRequest.mockReturnValue({
        user: {
          role: null,
        },
      });
      const result = guard.canActivate(mockExecutionContext);
      expect(result).toBe(false);
    });
    it('should deny access when user.role is not a valid UserRole', () => {
      mockReflector.getAllAndOverride.mockReturnValue([UserRole.CUSTOMER]);
      mockGetRequest.mockReturnValue({
        user: {
          role: 'INVALID_ROLE',
        },
      });
      const result = guard.canActivate(mockExecutionContext);
      expect(result).toBe(false);
    });
    it('should deny access when user object is missing', () => {
      mockReflector.getAllAndOverride.mockReturnValue([UserRole.CUSTOMER]);
      mockGetRequest.mockReturnValue({});
      const result = guard.canActivate(mockExecutionContext);
      expect(result).toBe(false);
    });
  });
});
````

## File: backend/src/auth/guards/roles.guard.ts
````typescript
import { Injectable, CanActivate, ExecutionContext } from "@nestjs/common";
import { Reflector } from "@nestjs/core";
import { User, UserRole } from "../../users/entities/user.entity";
import { Request } from "express";
interface RequestWithUser extends Request {
  user: User;
}
@Injectable()
export class RolesGuard implements CanActivate {
  constructor(private readonly reflector: Reflector) {}
  canActivate(context: ExecutionContext): boolean {
    const requiredRoles = this.reflector.getAllAndOverride<UserRole[]>(
      "roles",
      [context.getHandler(), context.getClass()],
    );
    // Add debug logging
    console.log('Roles Guard - Required Roles:', requiredRoles);
    if (!requiredRoles) {
      console.log('Roles Guard - No roles required');
      return true;
    }
    const request = context.switchToHttp().getRequest<RequestWithUser>();
    const user = request.user;
    console.log('Roles Guard - User:', user);
    console.log('Roles Guard - User Role:', user?.role);
    if (!user || !user.role) {
      console.log('Roles Guard - No user or role found in request');
      return false;
    }
    // Ensure user.role is a valid UserRole
    if (!Object.values(UserRole).includes(user.role)) {
      console.log('Roles Guard - Invalid user role');
      return false;
    }
    const hasRole: boolean = requiredRoles.includes(user.role);
    console.log('Roles Guard - Has Required Role:', hasRole);
    const canActivate: boolean = hasRole;
    return canActivate;
  }
}
````

## File: backend/src/auth/interfaces/auth.interface.ts
````typescript
import { User } from "../../users/entities/user.entity";
export type UserResponse = Omit<
  User,
  "password" | "hashPassword" | "validatePassword"
>;
export interface AuthResponse {
  user: UserResponse;
  token: string;
}
export interface JwtPayload {
  sub: string;
  email: string;
  role: string;
}
````

## File: backend/src/auth/strategies/jwt.strategy.spec.ts
````typescript
import { Test, TestingModule } from '@nestjs/testing';
import { ConfigService } from '@nestjs/config';
import { getRepositoryToken } from '@nestjs/typeorm';
import { UnauthorizedException } from '@nestjs/common';
import { JwtStrategy } from './jwt.strategy';
import { User, UserRole } from '../../users/entities/user.entity';
import { Request } from 'express';
interface JwtPayload {
  sub: string;
  email: string;
  iat?: number;
  exp?: number;
}
type MockConfigService = {
  get: jest.Mock<string | undefined, [string]>;
};
describe('JwtStrategy', () => {
  let strategy: JwtStrategy;
  let configService: MockConfigService;
  const mockConfigService: MockConfigService = {
    get: jest.fn((key: string) => key === 'JWT_SECRET' ? 'test-secret' : undefined),
  };
  const mockUsersRepository = {
    findOne: jest.fn(),
  };
  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        JwtStrategy,
        {
          provide: ConfigService,
          useValue: mockConfigService,
        },
        {
          provide: getRepositoryToken(User),
          useValue: mockUsersRepository,
        },
      ],
    }).compile();
    strategy = module.get<JwtStrategy>(JwtStrategy);
    configService = module.get(ConfigService);
  });
  afterEach(() => {
    jest.clearAllMocks();
  });
  it('should be defined', () => {
    expect(strategy).toBeDefined();
  });
  it('should use the secret from config service', () => {
    expect(configService.get).toHaveBeenCalledWith('JWT_SECRET');
    expect(configService.get('JWT_SECRET')).toBe('test-secret');
  });
  describe('validate', () => {
    const mockRequest = {
      headers: {
        authorization: 'Bearer test-token'
      }
    } as Request;
    const mockPayload: JwtPayload = {
      sub: 'user-123',
      email: 'test@example.com'
    };
    const mockUser: Partial<User> = {
      id: 'user-123',
      email: 'test@example.com',
      firstName: 'John',
      lastName: 'Doe',
      role: UserRole.CUSTOMER,
    };
    it('should return user when payload is valid', async () => {
      mockUsersRepository.findOne.mockResolvedValue(mockUser);
      const result = await strategy.validate(mockRequest, mockPayload);
      expect(result).toEqual({
        id: mockUser.id,
        email: mockUser.email,
        firstName: mockUser.firstName,
        lastName: mockUser.lastName,
        role: mockUser.role,
      });
      expect(mockUsersRepository.findOne).toHaveBeenCalledWith({
        where: { id: mockPayload.sub },
        select: ['id', 'email', 'firstName', 'lastName', 'role'],
      });
    });
    it('should throw UnauthorizedException when user is not found', async () => {
      mockUsersRepository.findOne.mockResolvedValue(null);
      await expect(strategy.validate(mockRequest, mockPayload))
        .rejects
        .toThrow(new UnauthorizedException('User not found'));
      expect(mockUsersRepository.findOne).toHaveBeenCalledWith({
        where: { id: mockPayload.sub },
        select: ['id', 'email', 'firstName', 'lastName', 'role'],
      });
    });
    it('should throw UnauthorizedException when payload is invalid', async () => {
      const invalidPayload = {} as JwtPayload;
      await expect(strategy.validate(mockRequest, invalidPayload))
        .rejects
        .toThrow(new UnauthorizedException('Invalid token payload'));
      expect(mockUsersRepository.findOne).not.toHaveBeenCalled();
    });
    it('should throw UnauthorizedException when payload is missing required fields', async () => {
      const incompletePayload: Partial<JwtPayload> = { iat: 123456789 };
      await expect(strategy.validate(mockRequest, incompletePayload as JwtPayload))
        .rejects
        .toThrow(new UnauthorizedException('Invalid token payload'));
      expect(mockUsersRepository.findOne).not.toHaveBeenCalled();
    });
    it('should handle repository errors gracefully', async () => {
      const dbError = new Error('Database connection failed');
      mockUsersRepository.findOne.mockRejectedValue(dbError);
      await expect(strategy.validate(mockRequest, mockPayload))
        .rejects
        .toThrow(UnauthorizedException);
      expect(mockUsersRepository.findOne).toHaveBeenCalledWith({
        where: { id: mockPayload.sub },
        select: ['id', 'email', 'firstName', 'lastName', 'role'],
      });
    });
  });
});
````

## File: backend/src/auth/strategies/jwt.strategy.ts
````typescript
import { Injectable, UnauthorizedException } from "@nestjs/common";
import { PassportStrategy } from "@nestjs/passport";
import { ExtractJwt, Strategy } from "passport-jwt";
import { ConfigService } from "@nestjs/config";
import { InjectRepository } from "@nestjs/typeorm";
import { Repository } from "typeorm";
import { User } from "../../users/entities/user.entity";
import { Request } from "express";
interface JwtPayload {
  sub: string;
  email: string;
  iat?: number;
  exp?: number;
}
interface SafeUser {
  id: string;
  email: string;
  firstName: string;
  lastName: string;
  role: string;
}
@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
  constructor(
    private readonly configService: ConfigService,
    @InjectRepository(User)
    private readonly usersRepository: Repository<User>
  ) {
    const jwtSecret = configService.get<string>("JWT_SECRET");
    if (!jwtSecret) {
      throw new Error("JWT_SECRET is not configured");
    }
    // Type assertion to ensure type safety
    const jwtExtractor = ExtractJwt.fromAuthHeaderAsBearerToken();
    if (!jwtExtractor || typeof jwtExtractor !== 'function') {
      throw new Error("Failed to initialize JWT extractor");
    }
    super({
      jwtFromRequest: jwtExtractor,
      ignoreExpiration: false,
      secretOrKey: jwtSecret,
      passReqToCallback: true,
    });
  }
  async validate(request: Request, payload: JwtPayload): Promise<SafeUser> {
    try {
      // Log the incoming request headers
      console.log("JWT Strategy - Headers:", request.headers);
      console.log(
        "JWT Strategy - Authorization:",
        request.headers.authorization
      );
      console.log("JWT Strategy - Payload:", payload);
      if (!this.isValidPayload(payload)) {
        console.log("JWT Strategy - Invalid payload");
        throw new UnauthorizedException("Invalid token payload");
      }
      const user = await this.usersRepository.findOne({
        where: { id: payload.sub },
        select: ["id", "email", "firstName", "lastName", "role"],
      });
      if (!user) {
        console.log("JWT Strategy - User not found:", payload.sub);
        throw new UnauthorizedException("User not found");
      }
      if (!this.isValidUser(user)) {
        console.log("JWT Strategy - Invalid user data:", user);
        throw new UnauthorizedException("Invalid user data");
      }
      console.log("JWT Strategy - Found User:", user);
      // Return a plain object instead of the entity
      return {
        id: user.id,
        email: user.email,
        firstName: user.firstName,
        lastName: user.lastName,
        role: user.role,
      };
    } catch (error: unknown) {
      console.error("JWT Strategy - Validation error:", error);
      if (error instanceof UnauthorizedException) {
        throw error;
      }
      throw new UnauthorizedException(
        error instanceof Error ? error.message : "Token validation failed"
      );
    }
  }
  private isValidPayload(payload: unknown): payload is JwtPayload {
    return (
      typeof payload === 'object' &&
      payload !== null &&
      typeof (payload as JwtPayload).sub === 'string' &&
      typeof (payload as JwtPayload).email === 'string'
    );
  }
  private isValidUser(user: unknown): user is SafeUser {
    return (
      typeof user === 'object' &&
      user !== null &&
      typeof (user as SafeUser).id === 'string' &&
      typeof (user as SafeUser).email === 'string' &&
      typeof (user as SafeUser).firstName === 'string' &&
      typeof (user as SafeUser).lastName === 'string' &&
      typeof (user as SafeUser).role === 'string'
    );
  }
}
````

## File: backend/src/auth/auth.controller.spec.ts
````typescript
import { Test, TestingModule } from "@nestjs/testing";
import { AuthController } from "./auth.controller";
import { AuthService } from "./auth.service";
import { UserRole } from "../users/entities/user.entity";
import { RegisterDto } from "./dto/register.dto";
import { LoginDto } from "./dto/login.dto";
describe("AuthController", () => {
  let controller: AuthController;
  const mockUser = {
    id: "1",
    email: "test@example.com",
    firstName: "Test",
    lastName: "User",
    role: UserRole.CUSTOMER,
  };
  const mockAuthResponse = {
    user: mockUser,
    token: "jwt_token",
  };
  const mockAuthService = {
    register: jest.fn().mockImplementation(() => Promise.resolve(mockAuthResponse)),
    login: jest.fn().mockImplementation(() => Promise.resolve(mockAuthResponse)),
  };
  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [AuthController],
      providers: [
        {
          provide: AuthService,
          useValue: mockAuthService,
        },
      ],
    }).compile();
    controller = module.get<AuthController>(AuthController);
    // Clear mock calls between tests
    jest.clearAllMocks();
  });
  it("should be defined", () => {
    expect(controller).toBeDefined();
  });
  describe("register", () => {
    const registerDto: RegisterDto = {
      email: "test@example.com",
      password: "password123",
      firstName: "Test",
      lastName: "User",
      role: UserRole.CUSTOMER,
    };
    it("should successfully register a new user", async () => {
      const result = await controller.register(registerDto);
      expect(result).toEqual(mockAuthResponse);
      expect(mockAuthService.register).toHaveBeenCalledWith(registerDto);
    });
    it("should pass through service errors", async () => {
      const error = new Error("Registration failed");
      mockAuthService.register.mockRejectedValueOnce(error);
      await expect(controller.register(registerDto)).rejects.toThrow(error);
    });
  });
  describe("login", () => {
    const loginDto: LoginDto = {
      email: "test@example.com",
      password: "password123",
    };
    it("should successfully login a user", async () => {
      const result = await controller.login(loginDto);
      expect(result).toEqual(mockAuthResponse);
      expect(mockAuthService.login).toHaveBeenCalledWith(loginDto);
    });
    it("should pass through service errors", async () => {
      const error = new Error("Login failed");
      mockAuthService.login.mockRejectedValueOnce(error);
      await expect(controller.login(loginDto)).rejects.toThrow(error);
    });
  });
});
````

## File: backend/src/auth/auth.controller.ts
````typescript
import { Controller, Post, Body } from "@nestjs/common";
import {
  ApiTags,
  ApiOperation,
  ApiResponse,
  ApiBody,
  getSchemaPath,
} from "@nestjs/swagger";
import { AuthService } from "./auth.service";
import { LoginDto, RegisterDto } from "./dto";
import { AuthResponse } from "./interfaces/auth.interface";
@ApiTags("Authentication")
@Controller("auth")
export class AuthController {
  constructor(private readonly authService: AuthService) {}
  @Post("register")
  @ApiOperation({ summary: "Register a new user" })
  @ApiBody({ type: RegisterDto })
  @ApiResponse({
    status: 201,
    description: "User successfully registered",
    schema: {
      properties: {
        user: {
          $ref: getSchemaPath(RegisterDto),
          properties: {
            id: { type: "string" },
            createdAt: { type: "string", format: "date-time" },
            updatedAt: { type: "string", format: "date-time" },
          },
        },
        token: { type: "string" },
      },
    },
  })
  @ApiResponse({
    status: 409,
    description: "Email already exists",
  })
  @ApiResponse({
    status: 500,
    description: "Internal server error",
  })
  async register(@Body() registerDto: RegisterDto): Promise<AuthResponse> {
    return this.authService.register(registerDto);
  }
  @Post("login")
  @ApiOperation({ summary: "Login user" })
  @ApiBody({ type: LoginDto })
  @ApiResponse({
    status: 200,
    description: "User successfully logged in",
    schema: {
      properties: {
        user: {
          $ref: getSchemaPath(RegisterDto),
          properties: {
            id: { type: "string" },
            createdAt: { type: "string", format: "date-time" },
            updatedAt: { type: "string", format: "date-time" },
          },
        },
        token: { type: "string" },
      },
    },
  })
  @ApiResponse({
    status: 401,
    description: "Invalid credentials",
  })
  @ApiResponse({
    status: 500,
    description: "Internal server error",
  })
  async login(@Body() loginDto: LoginDto): Promise<AuthResponse> {
    return this.authService.login(loginDto);
  }
}
````

## File: backend/src/auth/auth.module.spec.ts
````typescript
import { PassportModule } from '@nestjs/passport';
import { JwtModule } from '@nestjs/jwt';
import { ConfigService } from '@nestjs/config';
import { TypeOrmModule } from '@nestjs/typeorm';
import { AuthModule } from './auth.module';
import { UsersModule } from '../users/users.module';
import { AuthService } from './auth.service';
import { JwtStrategy } from './strategies/jwt.strategy';
import { RolesGuard } from './guards/roles.guard';
import { User } from '../users/entities/user.entity';
import { DynamicModule, Provider, Type, ValueProvider, FactoryProvider } from '@nestjs/common';
type Constructor<T> = new (...args: unknown[]) => T;
interface ModuleMetadata {
  imports: Array<Type<unknown> | DynamicModule>;
  providers: Provider[];
  exports: Array<Type<unknown> | DynamicModule>;
  controllers: Constructor<unknown>[];
}
interface PassportConfig extends ValueProvider<{ defaultStrategy: string }> {
  provide: string;
  useValue: { defaultStrategy: string };
}
interface JwtConfig extends FactoryProvider {
  provide: string;
  useFactory: (...args: unknown[]) => unknown;
  inject: Type<unknown>[];
}
interface TypeOrmEntityConfig {
  provide: string;
  useValue: {
    targetEntitySchema: {
      target: Constructor<User>;
    };
  };
}
jest.mock('../users/users.module');
describe('AuthModule', () => {
  beforeEach(() => {
    jest.clearAllMocks();
  });
  describe('module metadata', () => {
    it('should have the correct imports', () => {
      const imports = Reflect.getMetadata('imports', AuthModule) as ModuleMetadata['imports'];
      // Check UsersModule
      expect(imports).toContain(UsersModule);
      // Check PassportModule (as dynamic module)
      const passportModuleConfig = imports.find(
        (imp): imp is DynamicModule => 
          typeof imp === 'object' && 
          'module' in imp && 
          imp.module === PassportModule
      );
      expect(passportModuleConfig).toBeDefined();
      const passportProvider = passportModuleConfig?.providers?.[0] as PassportConfig;
      if (passportProvider) {
        expect(passportProvider.useValue).toEqual({
          defaultStrategy: 'jwt'
        });
      }
      // Check JwtModule
      const jwtModuleConfig = imports.find(
        (imp): imp is DynamicModule => 
          typeof imp === 'object' && 
          'module' in imp && 
          imp.module === JwtModule
      );
      expect(jwtModuleConfig).toBeDefined();
      const jwtProvider = jwtModuleConfig?.providers?.[0] as JwtConfig;
      if (jwtProvider) {
        expect(jwtProvider.inject).toContain(ConfigService);
      }
      // Check TypeOrmModule
      const typeOrmModuleConfig = imports.find(
        (imp): imp is DynamicModule => 
          typeof imp === 'object' && 
          'module' in imp && 
          imp.module === TypeOrmModule
      );
      expect(typeOrmModuleConfig).toBeDefined();
      const typeOrmProvider = typeOrmModuleConfig?.exports?.[0] as TypeOrmEntityConfig;
      if (typeOrmProvider?.useValue) {
        expect(typeOrmProvider.useValue.targetEntitySchema.target).toBe(User);
      }
    });
    it('should have the correct providers', () => {
      const providers = Reflect.getMetadata('providers', AuthModule) as Provider[];
      expect(providers).toContain(AuthService);
      expect(providers).toContain(JwtStrategy);
      expect(providers).toContain(RolesGuard);
    });
    it('should have the correct exports', () => {
      const exports = Reflect.getMetadata('exports', AuthModule) as ModuleMetadata['exports'];
      expect(exports).toContain(AuthService);
      expect(exports).toContain(JwtStrategy);
      expect(exports).toContain(RolesGuard);
      expect(exports).toContain(JwtModule);
      expect(exports).toContain(PassportModule);
    });
    it('should have the correct controllers', () => {
      const controllers = Reflect.getMetadata('controllers', AuthModule) as Constructor<unknown>[];
      expect(controllers).toBeDefined();
      expect(controllers.length).toBe(1);
    });
  });
});
````

## File: backend/src/auth/auth.module.ts
````typescript
import { Module } from "@nestjs/common";
import { JwtModule } from "@nestjs/jwt";
import { PassportModule } from "@nestjs/passport";
import { ConfigService } from "@nestjs/config";
import { TypeOrmModule } from "@nestjs/typeorm";
import { UsersModule } from "../users/users.module";
import { AuthService } from "./auth.service";
import { AuthController } from "./auth.controller";
import { JwtStrategy } from "./strategies/jwt.strategy";
import { RolesGuard } from "./guards/roles.guard";
import { User } from "../users/entities/user.entity";
@Module({
  imports: [
    UsersModule,
    PassportModule.register({ defaultStrategy: "jwt" }),
    JwtModule.registerAsync({
      inject: [ConfigService],
      useFactory: (configService: ConfigService) => ({
        secret: configService.get("JWT_SECRET"),
        signOptions: {
          expiresIn: configService.get("JWT_EXPIRATION") || "1h",
        },
      }),
    }),
    TypeOrmModule.forFeature([User]),
  ],
  providers: [AuthService, JwtStrategy, RolesGuard],
  controllers: [AuthController],
  exports: [AuthService, JwtStrategy, RolesGuard, JwtModule, PassportModule],
})
export class AuthModule {}
````

## File: backend/src/auth/auth.service.spec.ts
````typescript
import { Test, TestingModule } from "@nestjs/testing";
import { JwtService } from "@nestjs/jwt";
import { AuthService } from "./auth.service";
import { UsersService } from "../users/users.service";
import { UserRole } from "../users/entities/user.entity";
import { ConflictException, UnauthorizedException } from "@nestjs/common";
import * as bcrypt from "bcrypt";
jest.mock('bcrypt', () => ({
  compare: jest.fn(),
  hash: jest.fn(),
}));
describe("AuthService", () => {
  let service: AuthService;
  const mockUser = {
    id: "1",
    email: "test@example.com",
    firstName: "Test",
    lastName: "User",
    password: "hashedPassword",
    role: UserRole.CUSTOMER,
  };
  const mockUsersService = {
    findByEmail: jest.fn().mockImplementation(() => Promise.resolve(null)),
    create: jest.fn().mockImplementation(() => Promise.resolve(mockUser)),
  };
  const mockJwtService = {
    sign: jest.fn().mockReturnValue("jwt_token"),
  };
  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        AuthService,
        {
          provide: UsersService,
          useValue: mockUsersService,
        },
        {
          provide: JwtService,
          useValue: mockJwtService,
        },
      ],
    }).compile();
    service = module.get<AuthService>(AuthService);
    // Clear mock calls between tests
    jest.clearAllMocks();
  });
  it("should be defined", () => {
    expect(service).toBeDefined();
  });
  describe("register", () => {
    const registerDto = {
      email: "test@example.com",
      password: "password123",
      firstName: "Test",
      lastName: "User",
      role: UserRole.CUSTOMER,
    };
    it("should successfully register a new user", async () => {
      const result = await service.register(registerDto);
      expect(result).toHaveProperty("token");
      expect(result).toHaveProperty("user");
      expect(result.user).not.toHaveProperty("password");
      expect(mockUsersService.create).toHaveBeenCalled();
    });
    it("should throw ConflictException if email already exists", async () => {
      mockUsersService.findByEmail.mockResolvedValueOnce(mockUser);
      await expect(service.register(registerDto)).rejects.toThrow(
        ConflictException
      );
    });
  });
  describe("login", () => {
    const loginDto = {
      email: "test@example.com",
      password: "password123",
    };
    beforeEach(() => {
      // Setup bcrypt mock before each test
      (bcrypt.compare as jest.Mock).mockResolvedValue(true);
    });
    it("should successfully login a user", async () => {
      mockUsersService.findByEmail.mockResolvedValueOnce(mockUser);
      const result = await service.login(loginDto);
      expect(result).toHaveProperty("token");
      expect(result).toHaveProperty("user");
      expect(result.user).not.toHaveProperty("password");
    });
    it("should throw UnauthorizedException if user not found", async () => {
      mockUsersService.findByEmail.mockResolvedValueOnce(null);
      await expect(service.login(loginDto)).rejects.toThrow(
        UnauthorizedException
      );
    });
    it("should throw UnauthorizedException if password is invalid", async () => {
      mockUsersService.findByEmail.mockResolvedValueOnce(mockUser);
      (bcrypt.compare as jest.Mock).mockResolvedValue(false);
      await expect(service.login(loginDto)).rejects.toThrow(
        UnauthorizedException
      );
    });
  });
});
````

## File: backend/src/bookings/dto/booking-response.dto.ts
````typescript
import { Booking, BookingStatus } from "../entities/booking.entity";
import { User } from "../../users/entities/user.entity";
import { Employee } from "../../employees/entities/employee.entity";
import { Service } from "../../services/entities/service.entity";
interface BookingWithRelations extends Booking {
  customer: User;
  employee: Employee & { user: User };
  service: Service;
}
export class BookingResponseDto {
  id: string;
  customerName: string;
  employeeName: string;
  serviceName: string;
  startTime: string;
  status: BookingStatus;
  static fromEntity(booking: BookingWithRelations): BookingResponseDto {
    const dto = new BookingResponseDto();
    dto.id = booking.id;
    dto.customerName = `${booking.customer.firstName} ${booking.customer.lastName}`;
    dto.employeeName = `${booking.employee.user.firstName} ${booking.employee.user.lastName}`;
    dto.serviceName = booking.service.name;
    dto.startTime = booking.startTime.toISOString();
    dto.status = booking.status;
    return dto;
  }
  static fromEntities(bookings: BookingWithRelations[]): BookingResponseDto[] {
    return bookings.map(booking => BookingResponseDto.fromEntity(booking));
  }
}
````

## File: backend/src/bookings/dto/create-booking.dto.ts
````typescript
import {
  IsNotEmpty,
  IsUUID,
  IsDateString,
  IsString,
  IsOptional,
} from "class-validator";
export class CreateBookingDto {
  @IsNotEmpty()
  @IsUUID()
  customerId: string;
  @IsNotEmpty()
  @IsUUID()
  employeeId: string;
  @IsNotEmpty()
  @IsUUID()
  serviceId: string;
  @IsNotEmpty()
  @IsDateString()
  startTime: string;
  @IsOptional()
  @IsString()
  notes?: string;
}
````

## File: backend/src/bookings/dto/create-walk-in-booking.dto.ts
````typescript
import {
  IsNotEmpty,
  IsUUID,
  IsString,
  IsOptional,
  IsBoolean,
} from "class-validator";
export class CreateWalkInBookingDto {
  @IsNotEmpty()
  @IsUUID()
  serviceId: string;
  @IsNotEmpty()
  @IsString()
  firstName: string;
  @IsOptional()
  @IsString()
  phoneNumber?: string;
  @IsNotEmpty()
  @IsBoolean()
  isPaid: boolean;
}
````

## File: backend/src/bookings/dto/index.spec.ts
````typescript
import {
  CreateBookingDto,
  UpdateBookingDto,
  BookingResponseDto,
  UpcomingCountResponseDto,
} from './index';
describe('DTO exports', () => {
  it('should export CreateBookingDto', () => {
    expect(CreateBookingDto).toBeDefined();
    const dto = new CreateBookingDto();
    expect(dto).toBeInstanceOf(CreateBookingDto);
  });
  it('should export UpdateBookingDto', () => {
    expect(UpdateBookingDto).toBeDefined();
    const dto = new UpdateBookingDto();
    expect(dto).toBeInstanceOf(UpdateBookingDto);
  });
  it('should export BookingResponseDto', () => {
    expect(BookingResponseDto).toBeDefined();
    const dto = new BookingResponseDto();
    expect(dto).toBeInstanceOf(BookingResponseDto);
  });
  it('should export UpcomingCountResponseDto', () => {
    expect(UpcomingCountResponseDto).toBeDefined();
    const dto = new UpcomingCountResponseDto();
    expect(dto).toBeInstanceOf(UpcomingCountResponseDto);
  });
});
````

## File: backend/src/bookings/dto/index.ts
````typescript
export * from './create-booking.dto';
export * from './update-booking.dto';
export * from './booking-response.dto';
export * from './upcoming-count-response.dto';
````

## File: backend/src/bookings/dto/upcoming-count-response.dto.spec.ts
````typescript
import { UpcomingCustomerDto, UpcomingCountResponseDto } from './upcoming-count-response.dto';
describe('UpcomingCustomerDto', () => {
  it('should create a valid UpcomingCustomerDto instance', () => {
    const dto = new UpcomingCustomerDto();
    dto.firstName = 'John';
    dto.estimatedWaitingTime = 30;
    expect(dto).toBeDefined();
    expect(dto.firstName).toBe('John');
    expect(dto.estimatedWaitingTime).toBe(30);
  });
});
describe('UpcomingCountResponseDto', () => {
  it('should create a valid UpcomingCountResponseDto instance', () => {
    const customerDto = new UpcomingCustomerDto();
    customerDto.firstName = 'John';
    customerDto.estimatedWaitingTime = 30;
    const dto = new UpcomingCountResponseDto();
    dto.count = 1;
    dto.customers = [customerDto];
    expect(dto).toBeDefined();
    expect(dto.count).toBe(1);
    expect(dto.customers).toHaveLength(1);
    expect(dto.customers[0]).toEqual({
      firstName: 'John',
      estimatedWaitingTime: 30,
    });
  });
  it('should handle multiple customers', () => {
    const customer1 = new UpcomingCustomerDto();
    customer1.firstName = 'John';
    customer1.estimatedWaitingTime = 30;
    const customer2 = new UpcomingCustomerDto();
    customer2.firstName = 'Jane';
    customer2.estimatedWaitingTime = 60;
    const dto = new UpcomingCountResponseDto();
    dto.count = 2;
    dto.customers = [customer1, customer2];
    expect(dto.count).toBe(2);
    expect(dto.customers).toHaveLength(2);
    expect(dto.customers).toEqual([
      { firstName: 'John', estimatedWaitingTime: 30 },
      { firstName: 'Jane', estimatedWaitingTime: 60 },
    ]);
  });
  it('should handle empty customers array', () => {
    const dto = new UpcomingCountResponseDto();
    dto.count = 0;
    dto.customers = [];
    expect(dto.count).toBe(0);
    expect(dto.customers).toHaveLength(0);
  });
});
````

## File: backend/src/bookings/dto/upcoming-count-response.dto.ts
````typescript
export class UpcomingCustomerDto {
  firstName: string;
  estimatedWaitingTime: number; // in minutes
}
export class UpcomingCountResponseDto {
  count: number;
  customers: UpcomingCustomerDto[];
}
````

## File: backend/src/bookings/dto/update-booking.dto.ts
````typescript
import { IsOptional, IsEnum, IsString, IsDateString } from "class-validator";
import { Exclude, Transform } from "class-transformer";
import { BookingStatus } from "../entities/booking.entity";
export class UpdateBookingDto {
  @Exclude()
  id?: string;
  @Exclude()
  customerName?: string;
  @Exclude()
  employeeName?: string;
  @Exclude()
  serviceName?: string;
  @IsOptional()
  @IsDateString()
  startTime?: string;
  @IsOptional()
  @IsEnum(BookingStatus)
  @Transform(({ value }: { value: string | undefined }) => {
    if (typeof value === 'string') {
      return value.toLowerCase();
    }
    return value;
  })
  status?: BookingStatus;
  @IsOptional()
  @IsString()
  notes?: string;
  @IsOptional()
  @IsString()
  cancellationReason?: string;
}
````

## File: backend/src/bookings/entities/booking.entity.ts
````typescript
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  ManyToOne,
  JoinColumn,
} from "typeorm";
import { User } from "../../users/entities/user.entity";
import { Employee } from "../../employees/entities/employee.entity";
import { Service } from "../../services/entities/service.entity";
export enum BookingStatus {
  PENDING = "pending",
  CONFIRMED = "confirmed",
  CANCELLED = "cancelled",
  COMPLETED = "completed",
  NO_SHOW = "no_show",
}
@Entity("bookings")
export class Booking {
  @PrimaryGeneratedColumn("uuid")
  id: string;
  @ManyToOne(() => User, { nullable: false })
  @JoinColumn({ name: "customer_id" })
  customer: User;
  @ManyToOne(() => Employee, { nullable: false })
  @JoinColumn({ name: "employee_id" })
  employee: Employee;
  @ManyToOne(() => Service, { nullable: false })
  @JoinColumn({ name: "service_id" })
  service: Service;
  @Column({ type: "timestamp" })
  startTime: Date;
  @Column({ type: "timestamp" })
  endTime: Date;
  @Column({
    type: "enum",
    enum: BookingStatus,
    default: BookingStatus.PENDING,
  })
  status: BookingStatus;
  @Column("text", { nullable: true })
  notes: string;
  @Column("decimal", { precision: 10, scale: 2 })
  totalPrice: number;
  @Column({ default: false })
  reminderSent: boolean;
  @Column({ type: "timestamp", nullable: true })
  cancelledAt: Date;
  @Column({ type: "text", nullable: true })
  cancellationReason: string;
  @CreateDateColumn()
  createdAt: Date;
  @UpdateDateColumn()
  updatedAt: Date;
}
````

## File: backend/src/bookings/bookings.controller.spec.ts
````typescript
import { Test, TestingModule } from "@nestjs/testing";
import { BookingsController } from "./bookings.controller";
import { BookingsService } from "./bookings.service";
import { OrdersService } from "../orders/orders.service";
import { ShopsService } from "../shops/shops.service";
import { CreateBookingDto } from "./dto/create-booking.dto";
import { UpdateBookingDto } from "./dto/update-booking.dto";
import { Booking, BookingStatus } from "./entities/booking.entity";
import { UpcomingCountResponseDto } from "./dto/upcoming-count-response.dto";
describe("BookingsController", () => {
  let controller: BookingsController;
  let ordersService: OrdersService;
  const mockBooking = {
    id: "booking-1",
    customer: { id: "customer-1", firstName: "John" },
    employee: { id: "employee-1", user: { firstName: "Jane" } },
    service: { id: "service-1", name: "Haircut" },
    startTime: new Date(),
    endTime: new Date(),
    status: BookingStatus.PENDING,
    notes: "Test booking",
    totalPrice: 100.00,
    reminderSent: false,
    cancelledAt: null,
    cancellationReason: null,
    createdAt: new Date(),
    updatedAt: new Date()
  } as unknown as Booking;
  const mockCount = 5;
  const mockUpcomingCount: UpcomingCountResponseDto = {
    count: mockCount,
    customers: [
      {
        firstName: "John",
        estimatedWaitingTime: 30
      }
    ]
  };
  const mockBookingsService = {
    create: jest.fn().mockResolvedValue(mockBooking),
    findOne: jest.fn().mockResolvedValue(mockBooking),
    findByCustomer: jest.fn().mockResolvedValue([mockBooking]),
    findByEmployee: jest.fn().mockResolvedValue([mockBooking]),
    findUpcoming: jest.fn().mockResolvedValue([mockBooking]),
    update: jest.fn().mockResolvedValue(mockBooking),
    cancel: jest.fn().mockResolvedValue(mockBooking),
    getUpcomingCount: jest.fn().mockResolvedValue(mockUpcomingCount),
  };
  const mockShopsService = {
    validateShopCode: jest.fn().mockResolvedValue(true),
  };
  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [BookingsController],
      providers: [
        {
          provide: BookingsService,
          useValue: mockBookingsService,
        },
        {
          provide: OrdersService,
          useValue: {
            createFromBooking: jest.fn().mockResolvedValue({ id: "order-1" }),
          },
        },
        {
          provide: ShopsService,
          useValue: mockShopsService,
        },
      ],
    }).compile();
    controller = module.get<BookingsController>(BookingsController);
    ordersService = module.get<OrdersService>(OrdersService);
  });
  it("should be defined", () => {
    expect(controller).toBeDefined();
  });
  describe("create", () => {
    it("should create a booking", async () => {
      const createBookingDto: CreateBookingDto = {
        customerId: "customer-1",
        employeeId: "employee-1",
        serviceId: "service-1",
        startTime: new Date().toISOString(),
        notes: "Test booking",
      };
      const result = await controller.create(createBookingDto);
      expect(result).toBeDefined();
      expect(mockBookingsService.create).toHaveBeenCalledWith(createBookingDto);
    });
  });
  describe("findOne", () => {
    it("should return a booking by id", async () => {
      const result = await controller.findOne("booking-1");
      expect(result).toBeDefined();
      expect(mockBookingsService.findOne).toHaveBeenCalledWith("booking-1");
    });
  });
  describe("findByCustomer", () => {
    it("should return bookings for a customer", async () => {
      const result = await controller.findByCustomer("customer-1");
      expect(result).toBeDefined();
      expect(mockBookingsService.findByCustomer).toHaveBeenCalledWith("customer-1");
    });
  });
  describe("findByEmployee", () => {
    it("should return bookings for an employee", async () => {
      const result = await controller.findByEmployee("employee-1");
      expect(result).toBeDefined();
      expect(mockBookingsService.findByEmployee).toHaveBeenCalledWith("employee-1");
    });
  });
  describe("findUpcoming", () => {
    it("should return upcoming bookings", async () => {
      const result = await controller.findUpcoming();
      expect(result).toBeDefined();
      expect(mockBookingsService.findUpcoming).toHaveBeenCalled();
    });
  });
  describe("update", () => {
    it("should update a booking", async () => {
      const updateBookingDto: UpdateBookingDto = {
        startTime: new Date().toISOString(),
        notes: "Updated booking",
      };
      const result = await controller.update("booking-1", updateBookingDto);
      expect(result).toBeDefined();
      expect(mockBookingsService.update).toHaveBeenCalledWith("booking-1", updateBookingDto);
    });
  });
  describe("cancel", () => {
    it("should cancel a booking", async () => {
      const result = await controller.cancel("booking-1");
      expect(result).toBeDefined();
      expect(mockBookingsService.cancel).toHaveBeenCalledWith(
        "booking-1",
        "Cancelled by administrator",
      );
    });
  });
  describe("complete", () => {
    it("should complete a booking and create an order", async () => {
      const mockCreateFromBooking = jest.spyOn(ordersService, 'createFromBooking');
      const result = await controller.complete("booking-1");
      expect(result).toBeDefined();
      expect(mockCreateFromBooking).toHaveBeenCalledWith("booking-1");
    });
  });
  describe("getUpcomingCount", () => {
    it("should return the count of upcoming bookings", async () => {
      const result = await controller.getUpcomingCount();
      expect(result).toBeDefined();
      expect(result.count).toBe(mockCount);
      expect(mockBookingsService.getUpcomingCount).toHaveBeenCalled();
    });
  });
});
````

## File: backend/src/bookings/bookings.controller.ts
````typescript
import {
  Controller,
  Get,
  Post,
  Body,
  Param,
  Put,
  UseGuards,
  BadRequestException,
  Req,
  ParseUUIDPipe,
  ValidationPipe,
  Type,
} from "@nestjs/common";
import { BookingsService } from "./bookings.service";
import { OrdersService } from "../orders/orders.service";
import { CreateBookingDto } from "./dto/create-booking.dto";
import { CreateWalkInBookingDto } from "./dto/create-walk-in-booking.dto";
import { UpdateBookingDto } from "./dto/update-booking.dto";
import { BookingResponseDto } from "./dto/booking-response.dto";
import { UpcomingCountResponseDto } from "./dto/upcoming-count-response.dto";
import { JwtAuthGuard } from "../auth/guards/jwt-auth.guard";
import { RolesGuard } from "../auth/guards/roles.guard";
import { ShopCodeGuard } from "../shops/guards/shop-code.guard";
import { Roles } from "../auth/decorators/roles.decorator";
import { UserRole } from "../users/entities/user.entity";
import { Request } from "express";
import { ShopCode } from "../shops/entities/shop-code.entity";
import { Order } from "../orders/entities/order.entity";
// Extend Express Request to include shop property
interface RequestWithShop extends Request {
  shop?: ShopCode;
}
@Controller("bookings")
export class BookingsController {
  constructor(
    private readonly bookingsService: BookingsService,
    private readonly ordersService: OrdersService
  ) {
    if (!bookingsService) {
      throw new Error('BookingsService is required');
    }
    if (!ordersService) {
      throw new Error('OrdersService is required');
    }
  }
  @Get("upcoming/count")
  async getUpcomingCount(): Promise<UpcomingCountResponseDto> {
    return this.bookingsService.getUpcomingCount();
  }
  @Post("walk-in")
  @UseGuards(ShopCodeGuard as Type<ShopCodeGuard>)
  async createWalkIn(
    @Body(new ValidationPipe({ transform: true })) createWalkInBookingDto: CreateWalkInBookingDto,
    @Req() request: RequestWithShop
  ): Promise<BookingResponseDto> {
    if (!request?.shop) {
      throw new BadRequestException('Shop information is required for walk-in bookings');
    }
    const booking = await this.bookingsService.createWalkIn(
      createWalkInBookingDto,
      request.shop
    );
    return BookingResponseDto.fromEntity(booking);
  }
  @Post()
  @UseGuards(JwtAuthGuard as Type<JwtAuthGuard>, RolesGuard as Type<RolesGuard>)
  @Roles(UserRole.CUSTOMER, UserRole.ADMIN)
  async create(
    @Body(new ValidationPipe({ transform: true })) createBookingDto: CreateBookingDto
  ): Promise<BookingResponseDto> {
    const booking = await this.bookingsService.create(createBookingDto);
    return BookingResponseDto.fromEntity(booking);
  }
  @Get("upcoming")
  @UseGuards(JwtAuthGuard as Type<JwtAuthGuard>, RolesGuard as Type<RolesGuard>)
  @Roles(UserRole.EMPLOYEE, UserRole.ADMIN)
  async findUpcoming(): Promise<BookingResponseDto[]> {
    const bookings = await this.bookingsService.findUpcoming();
    return BookingResponseDto.fromEntities(bookings);
  }
  @Get("customer/:customerId")
  @UseGuards(JwtAuthGuard as Type<JwtAuthGuard>, RolesGuard as Type<RolesGuard>)
  @Roles(UserRole.CUSTOMER, UserRole.ADMIN)
  async findByCustomer(
    @Param("customerId", new ParseUUIDPipe()) customerId: string
  ): Promise<BookingResponseDto[]> {
    const bookings = await this.bookingsService.findByCustomer(customerId);
    return BookingResponseDto.fromEntities(bookings);
  }
  @Get("employee/:employeeId")
  @UseGuards(JwtAuthGuard as Type<JwtAuthGuard>, RolesGuard as Type<RolesGuard>)
  @Roles(UserRole.EMPLOYEE, UserRole.ADMIN)
  async findByEmployee(
    @Param("employeeId", new ParseUUIDPipe()) employeeId: string
  ): Promise<BookingResponseDto[]> {
    const bookings = await this.bookingsService.findByEmployee(employeeId);
    return BookingResponseDto.fromEntities(bookings);
  }
  @Get(":id")
  @UseGuards(JwtAuthGuard as Type<JwtAuthGuard>, RolesGuard as Type<RolesGuard>)
  @Roles(UserRole.CUSTOMER, UserRole.EMPLOYEE, UserRole.ADMIN)
  async findOne(
    @Param("id", new ParseUUIDPipe()) id: string
  ): Promise<BookingResponseDto> {
    const booking = await this.bookingsService.findOne(id);
    return BookingResponseDto.fromEntity(booking);
  }
  @Put(":id")
  @UseGuards(JwtAuthGuard as Type<JwtAuthGuard>, RolesGuard as Type<RolesGuard>)
  @Roles(UserRole.CUSTOMER, UserRole.EMPLOYEE, UserRole.ADMIN)
  async update(
    @Param("id", new ParseUUIDPipe()) id: string,
    @Body(new ValidationPipe({ transform: true })) updateBookingDto: UpdateBookingDto
  ): Promise<BookingResponseDto> {
    const booking = await this.bookingsService.update(id, updateBookingDto);
    return BookingResponseDto.fromEntity(booking);
  }
  @Put(":id/cancel")
  @UseGuards(JwtAuthGuard as Type<JwtAuthGuard>, RolesGuard as Type<RolesGuard>)
  @Roles(UserRole.CUSTOMER, UserRole.EMPLOYEE, UserRole.ADMIN)
  async cancel(
    @Param("id", new ParseUUIDPipe()) id: string
  ): Promise<BookingResponseDto> {
    const reason = "Cancelled by administrator";
    const booking = await this.bookingsService.cancel(id, reason);
    return BookingResponseDto.fromEntity(booking);
  }
  @Put(":id/complete")
  @UseGuards(JwtAuthGuard as Type<JwtAuthGuard>, RolesGuard as Type<RolesGuard>)
  @Roles(UserRole.ADMIN)
  async complete(
    @Param("id", new ParseUUIDPipe()) id: string
  ): Promise<Order> {
    return this.ordersService.createFromBooking(id);
  }
}
````

## File: backend/src/bookings/bookings.module.spec.ts
````typescript
import { BookingsModule } from "./bookings.module";
import { TypeOrmModule } from "@nestjs/typeorm";
import { BookingsService } from "./bookings.service";
import { DynamicModule, ForwardReference, Type } from "@nestjs/common";
type ModuleImport =
  | Type<unknown>
  | DynamicModule
  | Promise<DynamicModule>
  | ForwardReference;
describe("BookingsModule", () => {
  it("should have correct module metadata", () => {
    // Get module metadata directly from the decorator
    const moduleDecorator = Reflect.getMetadata(
      "imports",
      BookingsModule
    ) as ModuleImport[];
    // Check TypeOrmModule.forFeature
    const typeOrmFeature = moduleDecorator.find(
      (item): item is DynamicModule =>
        item !== null &&
        typeof item === "object" &&
        "module" in item &&
        item.module === TypeOrmModule
    );
    expect(typeOrmFeature).toBeDefined();
    // Get all module names
    const moduleNames = moduleDecorator
      .map((item): string | null => {
        if (typeof item === "function") {
          return item.name;
        }
        if (item && typeof item === "object" && "name" in item) {
          const name = item.name;
          return typeof name === 'string' ? name : null;
        }
        return null;
      })
      .filter((name): name is string => Boolean(name));
    // Check for expected modules
    const expectedModules = [
      "UsersModule",
      "ServicesModule",
      "ShopsModule",
      "AuthModule",
    ];
    expectedModules.forEach((moduleName) => {
      expect(moduleNames).toContain(moduleName);
    });
  });
  it("should export BookingsService and TypeOrmModule", () => {
    const exports = Reflect.getMetadata("exports", BookingsModule) as Array<
      Type<unknown> | DynamicModule
    >;
    expect(exports).toContain(BookingsService);
    const hasTypeOrmExport = exports.some(
      (exp): boolean =>
        exp === TypeOrmModule ||
        (exp !== null &&
          typeof exp === "object" &&
          "module" in exp &&
          exp.module === TypeOrmModule)
    );
    expect(hasTypeOrmExport).toBe(true);
  });
});
````

## File: backend/src/bookings/bookings.module.ts
````typescript
import { Module, forwardRef } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { BookingsService } from './bookings.service';
import { BookingsController } from './bookings.controller';
import { Booking } from './entities/booking.entity';
import { UsersModule } from '../users/users.module';
import { EmployeesModule } from '../employees/employees.module';
import { ServicesModule } from '../services/services.module';
import { OrdersModule } from '../orders/orders.module';
import { ShopsModule } from '../shops/shops.module';
import { AuthModule } from '../auth/auth.module';
import { RolesGuard } from '../auth/guards/roles.guard';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
@Module({
  imports: [
    TypeOrmModule.forFeature([Booking]),
    UsersModule,
    forwardRef(() => EmployeesModule),
    ServicesModule,
    forwardRef(() => OrdersModule),
    ShopsModule,
    AuthModule,
  ],
  controllers: [BookingsController],
  providers: [
    BookingsService,
    RolesGuard,
    JwtAuthGuard,
  ],
  exports: [BookingsService, TypeOrmModule],
})
export class BookingsModule {}
````

## File: backend/src/bookings/bookings.service.spec.ts
````typescript
import { Test, TestingModule } from "@nestjs/testing";
import { getRepositoryToken } from "@nestjs/typeorm";
import { BookingsService } from "./bookings.service";
import { Booking, BookingStatus } from "./entities/booking.entity";
import { UsersService } from "../users/users.service";
import { EmployeesService } from "../employees/employees.service";
import { ServicesService } from "../services/services.service";
import { OrdersService } from "../orders/orders.service";
import { CreateBookingDto } from "./dto/create-booking.dto";
import { CreateWalkInBookingDto } from "./dto/create-walk-in-booking.dto";
import { UpdateBookingDto } from "./dto/update-booking.dto";
import { NotFoundException, BadRequestException } from "@nestjs/common";
import { User, UserRole } from "../users/entities/user.entity";
describe("BookingsService", () => {
  let service: BookingsService;
  interface MockUser {
    id: string;
    firstName: string;
    lastName: string;
    email: string;
    password: string;
    role: UserRole;
    phoneNumber: string | null;
    createdAt: Date;
    updatedAt: Date;
  }
  interface FindOneOptions {
    where: { id: string };
    relations: string[];
  }
  interface FindOptions {
    where: unknown;
    relations: string[];
    order: { startTime: "ASC" | "DESC" };
  }
  interface MockBooking {
    id: string;
    customer?: Partial<MockUser>;
    service?: { id: string; duration: number };
    employee?: { id: string };
    status?: BookingStatus;
    startTime?: Date;
    endTime?: Date;
    notes?: string;
    totalPrice?: number;
    cancelledAt?: Date;
    cancellationReason?: string;
  }
  const mockBookingRepository = {
    create: jest.fn().mockImplementation(
      (dto: Partial<Booking>): MockBooking => ({
        id: "booking1",
        ...dto,
      })
    ),
    save: jest
      .fn()
      .mockImplementation(
        (booking: MockBooking): Promise<MockBooking> =>
          Promise.resolve({ id: "booking1", ...booking })
      ),
    findOne: jest
      .fn()
      .mockImplementation(
        (): Promise<MockBooking | null> => Promise.resolve({ id: "booking1" })
      ),
    find: jest
      .fn()
      .mockImplementation(
        (): Promise<MockBooking[]> => Promise.resolve([{ id: "booking1" }])
      ),
  };
  const mockUsersService = {
    create: jest.fn(),
    findOne: jest.fn(),
  };
  const mockEmployeesService = {
    findOne: jest.fn(),
    findAll: jest.fn(),
    isAvailable: jest.fn(),
  };
  const mockServicesService = {
    findOne: jest.fn(),
  };
  const mockOrdersService = {
    create: jest.fn(),
  };
  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        BookingsService,
        {
          provide: getRepositoryToken(Booking),
          useValue: mockBookingRepository,
        },
        {
          provide: UsersService,
          useValue: mockUsersService,
        },
        {
          provide: EmployeesService,
          useValue: mockEmployeesService,
        },
        {
          provide: ServicesService,
          useValue: mockServicesService,
        },
        {
          provide: OrdersService,
          useValue: mockOrdersService,
        },
      ],
    }).compile();
    service = module.get<BookingsService>(BookingsService);
  });
  afterEach(() => {
    jest.clearAllMocks();
  });
  describe("createWalkIn", () => {
    const mockShop = {
      id: "shop1",
      code: "SHOP1",
      shopName: "Test Shop",
      isActive: true,
      dailyBookingLimit: 100,
      lastBookingTime: new Date(),
      todayBookingCount: 0,
      createdAt: new Date(),
      updatedAt: new Date(),
    };
    const mockService = { id: "service1", duration: 30, price: 50 };
    const mockEmployee = { id: "emp1", isActive: true };
    const mockCustomer = { id: "cust1" };
    const createWalkInDto: CreateWalkInBookingDto = {
      serviceId: "service1",
      firstName: "John",
      phoneNumber: "1234567890",
      isPaid: true,
    };
    it("should create a walk-in booking successfully", async () => {
      mockUsersService.create.mockResolvedValue(mockCustomer);
      mockServicesService.findOne.mockResolvedValue(mockService);
      mockEmployeesService.findAll.mockResolvedValue([mockEmployee]);
      mockBookingRepository.find.mockResolvedValue([]);
      const newBooking: MockBooking = { id: "booking1" };
      mockBookingRepository.create.mockReturnValue(newBooking);
      mockBookingRepository.save.mockResolvedValue(newBooking);
      const result = await service.createWalkIn(createWalkInDto, mockShop);
      expect(result).toBeDefined();
      expect(mockUsersService.create).toHaveBeenCalled();
      expect(mockServicesService.findOne).toHaveBeenCalledWith(
        createWalkInDto.serviceId
      );
      expect(mockBookingRepository.save).toHaveBeenCalled();
    });
    it("should throw NotFoundException when service not found", async () => {
      mockServicesService.findOne.mockResolvedValue(null);
      await expect(
        service.createWalkIn(createWalkInDto, mockShop)
      ).rejects.toThrow(NotFoundException);
    });
    it("should throw BadRequestException when no active employees", async () => {
      mockServicesService.findOne.mockResolvedValue(mockService);
      mockEmployeesService.findAll.mockResolvedValue([]);
      await expect(
        service.createWalkIn(createWalkInDto, mockShop)
      ).rejects.toThrow(BadRequestException);
    });
  });
  describe("create", () => {
    const mockCustomer = { id: "cust1" };
    const mockEmployee = { id: "emp1" };
    const mockService = { id: "service1", duration: 30, price: 50 };
    const createBookingDto: CreateBookingDto = {
      customerId: "cust1",
      employeeId: "emp1",
      serviceId: "service1",
      startTime: new Date().toISOString(),
      notes: "Test booking",
    };
    it("should create a booking successfully", async () => {
      mockUsersService.findOne.mockResolvedValue(mockCustomer);
      mockEmployeesService.findOne.mockResolvedValue(mockEmployee);
      mockServicesService.findOne.mockResolvedValue(mockService);
      mockEmployeesService.isAvailable.mockResolvedValue(true);
      const newBooking: MockBooking = { id: "booking1" };
      mockBookingRepository.create.mockReturnValue(newBooking);
      mockBookingRepository.save.mockResolvedValue(newBooking);
      const result = await service.create(createBookingDto);
      expect(result).toBeDefined();
      expect(mockUsersService.findOne).toHaveBeenCalledWith(
        createBookingDto.customerId
      );
      expect(mockEmployeesService.findOne).toHaveBeenCalledWith(
        createBookingDto.employeeId
      );
      expect(mockServicesService.findOne).toHaveBeenCalledWith(
        createBookingDto.serviceId
      );
      expect(mockBookingRepository.save).toHaveBeenCalled();
    });
    it("should throw NotFoundException when customer not found", async () => {
      mockUsersService.findOne.mockResolvedValue(null);
      await expect(service.create(createBookingDto)).rejects.toThrow(
        NotFoundException
      );
    });
    it("should throw BadRequestException when employee not available", async () => {
      mockUsersService.findOne.mockResolvedValue(mockCustomer);
      mockEmployeesService.findOne.mockResolvedValue(mockEmployee);
      mockServicesService.findOne.mockResolvedValue(mockService);
      mockEmployeesService.isAvailable.mockResolvedValue(false);
      await expect(service.create(createBookingDto)).rejects.toThrow(
        BadRequestException
      );
    });
  });
  describe("findOne", () => {
    it("should return a booking when found", async () => {
      const mockBooking: MockBooking = { id: "booking1" };
      mockBookingRepository.findOne.mockResolvedValue(mockBooking);
      const result = await service.findOne("booking1");
      expect(result).toBe(mockBooking);
      const expectedOptions: FindOneOptions = {
        where: { id: "booking1" },
        relations: ["customer", "employee", "employee.user", "service"],
      };
      expect(mockBookingRepository.findOne).toHaveBeenCalledWith(
        expectedOptions
      );
    });
    it("should throw NotFoundException when booking not found", async () => {
      mockBookingRepository.findOne.mockResolvedValue(null);
      await expect(service.findOne("booking1")).rejects.toThrow(
        NotFoundException
      );
    });
  });
  describe("update", () => {
    const mockBooking = {
      id: "booking1",
      service: { id: "service1" },
      employee: { id: "emp1" },
    };
    const updateDto: UpdateBookingDto = {
      startTime: new Date().toISOString(),
    };
    it("should update booking successfully", async () => {
      mockBookingRepository.findOne.mockResolvedValue(mockBooking);
      mockServicesService.findOne.mockResolvedValue({ duration: 30 });
      mockEmployeesService.isAvailable.mockResolvedValue(true);
      const updatedBooking: MockBooking = {
        id: mockBooking.id,
        startTime: new Date(updateDto.startTime),
        service: { id: mockBooking.service.id, duration: 30 },
        employee: { id: mockBooking.employee.id },
      };
      mockBookingRepository.save.mockResolvedValue(updatedBooking);
      const result = await service.update("booking1", updateDto);
      expect(result).toBeDefined();
      expect(mockBookingRepository.save).toHaveBeenCalled();
    });
    it("should throw BadRequestException when employee not available for new time", async () => {
      mockBookingRepository.findOne.mockResolvedValue(mockBooking);
      mockServicesService.findOne.mockResolvedValue({ duration: 30 });
      mockEmployeesService.isAvailable.mockResolvedValue(false);
      await expect(service.update("booking1", updateDto)).rejects.toThrow(
        BadRequestException
      );
    });
  });
  describe("cancel", () => {
    it("should cancel booking successfully", async () => {
      const mockBooking: MockBooking = { id: "booking1" };
      const reason = "Test reason";
      const expectedSavedBooking = {
        id: mockBooking.id,
        status: BookingStatus.CANCELLED,
        cancelledAt: expect.any(Date) as Date,
        cancellationReason: reason,
      };
      mockBookingRepository.findOne.mockResolvedValue(mockBooking);
      mockBookingRepository.save.mockImplementation(
        (booking: MockBooking): Promise<MockBooking> => Promise.resolve(booking)
      );
      const result = await service.cancel("booking1", reason);
      expect(result.status).toBe(BookingStatus.CANCELLED);
      expect(result.cancellationReason).toBe(reason);
      expect(mockBookingRepository.save).toHaveBeenCalledWith(
        expectedSavedBooking
      );
    });
  });
  describe("findUpcoming", () => {
    it("should return upcoming bookings", async () => {
      const mockBookings: MockBooking[] = [
        { id: "booking1" },
        { id: "booking2" },
      ];
      mockBookingRepository.find.mockResolvedValue(mockBookings);
      const result = await service.findUpcoming();
      expect(result).toEqual(mockBookings);
      const expectedFindOptions: FindOptions = {
        where: expect.any(Object),
        relations: ["customer", "employee", "employee.user", "service"],
        order: { startTime: "ASC" },
      };
      expect(mockBookingRepository.find).toHaveBeenCalledWith(
        expectedFindOptions
      );
    });
  });
  describe("getUpcomingCount", () => {
    it("should return upcoming count and customers", async () => {
      const mockBookings: Partial<Booking>[] = [
        {
          id: "booking1",
          customer: {
            id: "user1",
            firstName: "John",
            lastName: "Doe",
            email: "john@example.com",
            password: "password",
            role: UserRole.CUSTOMER,
            phoneNumber: "1234567890",
            createdAt: new Date(),
            updatedAt: new Date(),
            hashPassword: async () => Promise.resolve(),
            validatePassword: async () => Promise.resolve(true),
          } as User,
          service: {
            id: "service1",
            name: "Haircut",
            description: "Basic haircut",
            duration: 30,
            price: 50,
            isActive: true,
            employees: [],
            createdAt: new Date(),
            updatedAt: new Date(),
          },
        },
        {
          id: "booking2",
          customer: {
            id: "user2",
            firstName: "Jane",
            lastName: "Doe",
            email: "jane@example.com",
            password: "password",
            role: UserRole.CUSTOMER,
            phoneNumber: "0987654321",
            createdAt: new Date(),
            updatedAt: new Date(),
            hashPassword: async () => Promise.resolve(),
            validatePassword: async () => Promise.resolve(true),
          } as User,
          service: {
            id: "service2",
            name: "Styling",
            description: "Hair styling",
            duration: 45,
            price: 75,
            isActive: true,
            employees: [],
            createdAt: new Date(),
            updatedAt: new Date(),
          },
        },
      ];
      mockBookingRepository.find.mockResolvedValue(mockBookings);
      const result = await service.getUpcomingCount();
      expect(result.count).toBe(2);
      expect(result.customers).toHaveLength(2);
      expect(result.customers[1].estimatedWaitingTime).toBe(30); // First booking's duration
    });
  });
});
````

## File: backend/src/bookings/bookings.service.ts
````typescript
import {
  Injectable,
  NotFoundException,
  BadRequestException,
  Logger,
} from "@nestjs/common";
import { InjectRepository } from "@nestjs/typeorm";
import { Repository, MoreThan, In, Between } from "typeorm";
import { Booking, BookingStatus } from "./entities/booking.entity";
import { CreateBookingDto } from "./dto/create-booking.dto";
import { CreateWalkInBookingDto } from "./dto/create-walk-in-booking.dto";
import { UpdateBookingDto } from "./dto/update-booking.dto";
import {
  UpcomingCountResponseDto,
  UpcomingCustomerDto,
} from "./dto/upcoming-count-response.dto";
import { UsersService } from "../users/users.service";
import { EmployeesService } from "../employees/employees.service";
import { ServicesService } from "../services/services.service";
import { OrdersService } from "../orders/orders.service";
import { ShopCode } from "../shops/entities/shop-code.entity";
import { UserRole } from "../users/entities/user.entity";
@Injectable()
export class BookingsService {
  private readonly logger = new Logger(BookingsService.name);
  constructor(
    @InjectRepository(Booking)
    private readonly bookingRepository: Repository<Booking>,
    private readonly usersService: UsersService,
    private readonly employeesService: EmployeesService,
    private readonly servicesService: ServicesService,
    private readonly ordersService: OrdersService
  ) {}
  async createWalkIn(
    createWalkInBookingDto: CreateWalkInBookingDto,
    shop: ShopCode
  ): Promise<Booking> {
    const { serviceId, firstName, phoneNumber, isPaid } =
      createWalkInBookingDto;
    // Create temporary customer for walk-in
    const customer = await this.usersService.create({
      firstName,
      lastName: "Walk-in",
      email: `walkin_${Date.now()}@temp.com`,
      password: Math.random().toString(36),
      phoneNumber,
      role: UserRole.CUSTOMER,
    });
    // Verify service exists
    const service = await this.servicesService.findOne(serviceId);
    if (!service) {
      throw new NotFoundException("Service not found");
    }
    // Get all employees and filter active ones
    const allEmployees = await this.employeesService.findAll();
    const activeEmployees = allEmployees.filter((emp) => emp.isActive);
    if (activeEmployees.length === 0) {
      throw new BadRequestException("No employees available");
    }
    // Find the employee with the least pending bookings
    const employeeBookings = await Promise.all(
      activeEmployees.map(async (emp) => ({
        employee: emp,
        bookingCount: (await this.findByEmployee(emp.id)).length,
      }))
    );
    const sortedEmployeeBookings = [...employeeBookings].sort(
      (a, b) => a.bookingCount - b.bookingCount
    );
    const selectedEmployee = sortedEmployeeBookings[0].employee;
    // Calculate start and end times
    const startDate = new Date();
    const endDate = new Date(startDate.getTime() + service.duration * 60000);
    // Create and save the booking
    const booking = this.bookingRepository.create({
      customer,
      employee: selectedEmployee,
      service,
      startTime: startDate,
      endTime: endDate,
      notes: `Walk-in booking from ${shop.shopName}`,
      totalPrice: service.price,
      status: isPaid ? BookingStatus.CONFIRMED : BookingStatus.PENDING,
    });
    return this.bookingRepository.save(booking);
  }
  async create(createBookingDto: CreateBookingDto): Promise<Booking> {
    const { customerId, employeeId, serviceId, startTime, notes } =
      createBookingDto;
    // Verify customer exists
    const customer = await this.usersService.findOne(customerId);
    if (!customer) {
      throw new NotFoundException("Customer not found");
    }
    // Verify employee exists
    const employee = await this.employeesService.findOne(employeeId);
    if (!employee) {
      throw new NotFoundException("Employee not found");
    }
    // Verify service exists
    const service = await this.servicesService.findOne(serviceId);
    if (!service) {
      throw new NotFoundException("Service not found");
    }
    // Calculate end time based on service duration
    const startDate = new Date(startTime);
    const endDate = new Date(startDate.getTime() + service.duration * 60000);
    // Check if employee is available
    const isAvailable = await this.employeesService.isAvailable(
      employeeId,
      startDate,
      endDate
    );
    if (!isAvailable) {
      throw new BadRequestException("Employee is not available at this time");
    }
    // Create and save the booking
    const booking = this.bookingRepository.create({
      customer,
      employee,
      service,
      startTime: startDate,
      endTime: endDate,
      notes,
      totalPrice: service.price,
      status: BookingStatus.PENDING,
    });
    return this.bookingRepository.save(booking);
  }
  async findOne(id: string): Promise<Booking> {
    const booking = await this.bookingRepository.findOne({
      where: { id },
      relations: ["customer", "employee", "employee.user", "service"],
    });
    if (!booking) {
      throw new NotFoundException(`Booking with ID ${id} not found`);
    }
    return booking;
  }
  async update(
    id: string,
    updateBookingDto: UpdateBookingDto
  ): Promise<Booking> {
    const booking = await this.findOne(id);
    // If updating start time, recalculate end time
    if (updateBookingDto.startTime) {
      const startDate = new Date(updateBookingDto.startTime);
      const service = await this.servicesService.findOne(booking.service.id);
      const endDate = new Date(startDate.getTime() + service.duration * 60000);
      // Check employee availability for new time
      const isAvailable = await this.employeesService.isAvailable(
        booking.employee.id,
        startDate,
        endDate,
        id // Exclude current booking from availability check
      );
      if (!isAvailable) {
        throw new BadRequestException("Employee is not available at this time");
      }
      booking.startTime = startDate;
      booking.endTime = endDate;
    }
    // Update other fields
    Object.assign(booking, updateBookingDto);
    return this.bookingRepository.save(booking);
  }
  async cancel(id: string, reason: string): Promise<Booking> {
    const booking = await this.findOne(id);
    booking.status = BookingStatus.CANCELLED;
    booking.cancelledAt = new Date();
    booking.cancellationReason = reason;
    return this.bookingRepository.save(booking);
  }
  async findByCustomer(customerId: string): Promise<Booking[]> {
    const bookings: Booking[] = await this.bookingRepository.find({
      where: { customer: { id: customerId } },
      relations: ["customer", "employee", "employee.user", "service"],
      order: { startTime: "DESC" },
    });
    return bookings;
  }
  async findByEmployee(employeeId: string): Promise<Booking[]> {
    const bookings: Booking[] = await this.bookingRepository.find({
      where: { employee: { id: employeeId } },
      relations: ["customer", "employee", "employee.user", "service"],
      order: { startTime: "DESC" },
    });
    return bookings;
  }
  async findUpcoming(): Promise<Booking[]> {
    const now = new Date();
    const startOfDay = new Date(
      now.getFullYear(),
      now.getMonth(),
      now.getDate()
    );
    this.logger.debug(`Finding bookings from ${startOfDay.toISOString()}`);
    const bookings: Booking[] = await this.bookingRepository.find({
      where: {
        startTime: MoreThan(startOfDay),
        status: In([BookingStatus.PENDING, BookingStatus.CONFIRMED]),
      },
      relations: ["customer", "employee", "employee.user", "service"],
      order: { startTime: "ASC" },
    });
    this.logger.debug(`Found ${bookings.length} bookings`);
    if (bookings.length === 0) {
      this.logger.debug(
        "No bookings found. Checking all bookings for debugging..."
      );
      const allBookings: Booking[] = await this.bookingRepository.find({
        relations: ["customer", "employee", "employee.user", "service"],
      });
      this.logger.debug(`Total bookings in database: ${allBookings.length}`);
      this.logger.debug("Sample booking dates:");
      allBookings.slice(0, 3).forEach((booking: Booking) => {
        this.logger.debug(
          `Booking ${booking.id}: startTime=${booking.startTime.toISOString()}, status=${booking.status}`
        );
      });
    }
    return bookings;
  }
  async getUpcomingCount(): Promise<UpcomingCountResponseDto> {
    const now = new Date();
    const startOfDay = new Date(
      now.getFullYear(),
      now.getMonth(),
      now.getDate()
    );
    const endOfDay = new Date(startOfDay);
    endOfDay.setDate(endOfDay.getDate() + 1);
    const bookings: Booking[] = await this.bookingRepository.find({
      where: {
        startTime: Between(startOfDay, endOfDay),
        status: In([BookingStatus.PENDING, BookingStatus.CONFIRMED]),
      },
      relations: ["customer", "service"],
      order: { startTime: "ASC" },
    });
    const customers: UpcomingCustomerDto[] = bookings.map((booking: Booking, index: number) => {
      // Calculate waiting time based on previous bookings' service durations
      const waitingTime: number = bookings
        .slice(0, index)
        .reduce((total: number, prev: Booking) => total + prev.service.duration, 0);
      return {
        firstName: booking.customer.firstName,
        estimatedWaitingTime: waitingTime,
      };
    });
    return {
      count: bookings.length,
      customers,
    };
  }
}
````

## File: backend/src/config/cache.config.spec.ts
````typescript
import cacheConfig from './cache.config';
describe('Cache Config', () => {
  const OLD_ENV = process.env;
  beforeEach(() => {
    jest.resetModules();
    process.env = { ...OLD_ENV };
  });
  afterAll(() => {
    process.env = OLD_ENV;
  });
  it('should be registered with cache namespace', () => {
    expect(cacheConfig.KEY).toBe('CONFIGURATION(cache)');
  });
  describe('default values', () => {
    it('should use default values when environment variables are not set', () => {
      delete process.env.REDIS_HOST;
      delete process.env.REDIS_PORT;
      delete process.env.CACHE_TTL;
      const config = cacheConfig();
      expect(config.host).toBe('localhost');
      expect(config.port).toBe(6379);
      expect(config.ttl).toBe(300); // 5 minutes = 300 seconds
    });
  });
  describe('environment variables', () => {
    it('should use REDIS_HOST from environment', () => {
      process.env.REDIS_HOST = 'redis.example.com';
      const config = cacheConfig();
      expect(config.host).toBe('redis.example.com');
    });
    it('should use REDIS_PORT from environment', () => {
      process.env.REDIS_PORT = '6380';
      const config = cacheConfig();
      expect(config.port).toBe(6380);
    });
    it('should use CACHE_TTL from environment', () => {
      process.env.CACHE_TTL = '600';
      const config = cacheConfig();
      expect(config.ttl).toBe(600);
    });
    it('should handle invalid REDIS_PORT value', () => {
      process.env.REDIS_PORT = 'invalid';
      const config = cacheConfig();
      expect(config.port).toBe(6379); // Should fall back to default
    });
    it('should handle invalid CACHE_TTL value', () => {
      process.env.CACHE_TTL = 'invalid';
      const config = cacheConfig();
      expect(config.ttl).toBe(300); // Should fall back to default
    });
  });
});
````

## File: backend/src/config/cache.config.ts
````typescript
import { registerAs } from "@nestjs/config";
export default registerAs("cache", () => ({
  host: process.env.REDIS_HOST || "localhost",
  port: parseInt(process.env.REDIS_PORT, 10) || 6379,
  ttl: parseInt(process.env.CACHE_TTL, 10) || 5 * 60, // 5 minutes
}));
````

## File: backend/src/config/database.config.spec.ts
````typescript
import databaseConfig from './database.config';
describe('Database Config', () => {
  const OLD_ENV = process.env;
  beforeEach(() => {
    jest.resetModules();
    process.env = { ...OLD_ENV };
  });
  afterAll(() => {
    process.env = OLD_ENV;
  });
  it('should be registered with database namespace', () => {
    expect(databaseConfig.KEY).toBe('CONFIGURATION(database)');
  });
  it('should use DATABASE_URL from environment', () => {
    process.env.DATABASE_URL = 'postgresql://user:pass@localhost:5432/db';
    const config = databaseConfig();
    expect(config.url).toBe('postgresql://user:pass@localhost:5432/db');
  });
  describe('development environment', () => {
    beforeEach(() => {
      process.env.NODE_ENV = 'development';
    });
    it('should enable synchronize and logging in development', () => {
      const config = databaseConfig();
      expect(config.synchronize).toBe(true);
      expect(config.logging).toBe(true);
    });
  });
  describe('production environment', () => {
    beforeEach(() => {
      process.env.NODE_ENV = 'production';
    });
    it('should disable synchronize and logging in production', () => {
      const config = databaseConfig();
      expect(config.synchronize).toBe(false);
      expect(config.logging).toBe(false);
    });
  });
  describe('static configuration', () => {
    it('should have correct static values', () => {
      const config = databaseConfig();
      expect(config.type).toBe('postgres');
      expect(config.entities).toEqual(['dist/**/*.entity{.ts,.js}']);
      expect(config.migrations).toEqual(['dist/migrations/*{.ts,.js}']);
      expect(config.migrationsTableName).toBe('migrations');
      expect(config.migrationsRun).toBe(true);
    });
    it('should have correct SSL configuration', () => {
      const config = databaseConfig();
      expect(config.ssl).toEqual({
        rejectUnauthorized: false,
      });
    });
  });
});
````

## File: backend/src/config/database.config.ts
````typescript
import { registerAs } from "@nestjs/config";
export default registerAs("database", () => ({
  type: "postgres",
  url: process.env.DATABASE_URL,
  entities: ["dist/**/*.entity{.ts,.js}"],
  synchronize: process.env.NODE_ENV === "development",
  logging: process.env.NODE_ENV === "development",
  migrations: ["dist/migrations/*{.ts,.js}"],
  migrationsTableName: "migrations",
  migrationsRun: true,
  ssl: {
    rejectUnauthorized: false,
  },
}));
````

## File: backend/src/config/index.ts
````typescript
export { default as databaseConfig } from "./database.config";
export { default as cacheConfig } from "./cache.config";
export { default as jwtConfig } from "./jwt.config";
````

## File: backend/src/config/jwt.config.spec.ts
````typescript
import jwtConfig from './jwt.config';
describe('JWT Config', () => {
  const OLD_ENV = process.env;
  beforeEach(() => {
    jest.resetModules();
    process.env = { ...OLD_ENV };
  });
  afterAll(() => {
    process.env = OLD_ENV;
  });
  it('should be registered with jwt namespace', () => {
    // registerAs adds a KEY property in the format "CONFIGURATION(namespace)"
    expect(jwtConfig.KEY).toBe('CONFIGURATION(jwt)');
  });
  it('should use JWT_SECRET from environment', () => {
    process.env.JWT_SECRET = 'test-secret';
    const config = jwtConfig();
    expect(config.secret).toBe('test-secret');
  });
  it('should use JWT_EXPIRATION from environment', () => {
    process.env.JWT_EXPIRATION = '2h';
    const config = jwtConfig();
    expect(config.signOptions.expiresIn).toBe('2h');
  });
  it('should use default expiration when JWT_EXPIRATION is not set', () => {
    delete process.env.JWT_EXPIRATION;
    const config = jwtConfig();
    expect(config.signOptions.expiresIn).toBe('1h');
  });
  it('should return undefined secret when JWT_SECRET is not set', () => {
    delete process.env.JWT_SECRET;
    const config = jwtConfig();
    expect(config.secret).toBeUndefined();
  });
});
````

## File: backend/src/config/jwt.config.ts
````typescript
import { registerAs } from '@nestjs/config';
export default registerAs('jwt', () => ({
  secret: process.env.JWT_SECRET,
  signOptions: {
    expiresIn: process.env.JWT_EXPIRATION || '1h',
  },
}));
````

## File: backend/src/database/migrations/1731981975581-InitialMigration.spec.ts
````typescript
import { QueryRunner } from 'typeorm';
import { InitialMigration1731981975581 } from './1731981975581-InitialMigration';
class TestInitialMigration extends InitialMigration1731981975581 {
  public testGetErrorMessage(error: unknown): string {
    return this.getErrorMessage(error);
  }
  public testExecuteQuery(queryRunner: QueryRunner, sql: string): Promise<void> {
    return this.executeQuery(queryRunner, sql);
  }
  public testExecuteQueries(queryRunner: QueryRunner, queries: string[]): Promise<void> {
    return this.executeQueries(queryRunner, queries);
  }
}
describe('InitialMigration1731981975581', () => {
  let migration: TestInitialMigration;
  let mockQueryRunner: QueryRunner;
  let mockQuery: jest.Mock;
  beforeEach(() => {
    migration = new TestInitialMigration();
    mockQuery = jest.fn();
    mockQueryRunner = {
      query: mockQuery,
    } as unknown as QueryRunner;
  });
  describe('getErrorMessage', () => {
    it('should handle Error instance', () => {
      const error = new Error('Test error');
      const result = migration.testGetErrorMessage(error);
      expect(result).toBe('Test error');
    });
    it('should handle string error', () => {
      const error = 'String error';
      const result = migration.testGetErrorMessage(error);
      expect(result).toBe('String error');
    });
    it('should handle unknown error type', () => {
      const error = { custom: 'error' };
      const result = migration.testGetErrorMessage(error);
      expect(result).toBe('Unknown error occurred');
    });
  });
  describe('executeQuery', () => {
    it('should throw error for invalid query runner', async () => {
      const invalidQueryRunner = {} as QueryRunner;
      await expect(migration.testExecuteQuery(invalidQueryRunner, 'SELECT 1'))
        .rejects
        .toThrow('Invalid query runner');
    });
    it('should throw error when query fails', async () => {
      const error = new Error('Query execution failed');
      mockQuery.mockRejectedValue(error);
      await expect(migration.testExecuteQuery(mockQueryRunner, 'SELECT 1'))
        .rejects
        .toThrow('Migration failed executing query: SELECT 1\nError: Query failed: SELECT 1\nError: Query execution failed');
    });
    it('should execute query successfully', async () => {
      mockQuery.mockResolvedValue({});
      await expect(migration.testExecuteQuery(mockQueryRunner, 'SELECT 1'))
        .resolves
        .not
        .toThrow();
    });
  });
  describe('executeQueries', () => {
    it('should execute multiple queries successfully', async () => {
      mockQuery.mockResolvedValue({});
      const queries = ['SELECT 1', 'SELECT 2'];
      await expect(migration.testExecuteQueries(mockQueryRunner, queries))
        .resolves
        .not
        .toThrow();
      expect(mockQuery).toHaveBeenCalledTimes(2);
    });
    it('should throw error when any query fails', async () => {
      const error = new Error('Query execution failed');
      mockQuery.mockRejectedValue(error);
      const queries = ['SELECT 1', 'SELECT 2'];
      await expect(migration.testExecuteQueries(mockQueryRunner, queries))
        .rejects
        .toThrow('Migration failed executing query: SELECT 1\nError: Query failed: SELECT 1\nError: Query execution failed');
    });
  });
  describe('up', () => {
    it('should execute migration up successfully', async () => {
      mockQuery.mockResolvedValue({});
      await expect(migration.up(mockQueryRunner)).resolves.not.toThrow();
      // Verify all required queries were executed
      expect(mockQuery).toHaveBeenCalled();
    });
    it('should handle errors during up migration', async () => {
      const error = new Error('Migration failed');
      mockQuery.mockRejectedValue(error);
      await expect(migration.up(mockQueryRunner))
        .rejects
        .toThrow('Migration up failed: Migration failed');
    });
  });
  describe('down', () => {
    it('should execute migration down successfully', async () => {
      mockQuery.mockResolvedValue({});
      await expect(migration.down(mockQueryRunner)).resolves.not.toThrow();
      // Verify all required queries were executed
      expect(mockQuery).toHaveBeenCalled();
    });
    it('should handle errors during down migration', async () => {
      const error = new Error('Migration failed');
      mockQuery.mockRejectedValue(error);
      await expect(migration.down(mockQueryRunner))
        .rejects
        .toThrow('Migration down failed: Migration failed');
    });
  });
});
````

## File: backend/src/database/migrations/1731981975581-InitialMigration.ts
````typescript
import { MigrationInterface, QueryRunner } from "typeorm";
export class InitialMigration1731981975581 implements MigrationInterface {
  name = "InitialMigration1731981975581";
  protected getErrorMessage(error: unknown): string {
    if (error instanceof Error) {
      return error.message;
    }
    if (typeof error === 'string') {
      return error;
    }
    return 'Unknown error occurred';
  }
  protected async executeQuery(queryRunner: QueryRunner, sql: string): Promise<void> {
    if (!queryRunner || typeof queryRunner.query !== 'function') {
      throw new Error('Invalid query runner');
    }
    try {
      await queryRunner.query(sql).catch((error: unknown) => {
        throw new Error(
          `Query failed: ${sql}\nError: ${this.getErrorMessage(error)}`
        );
      });
    } catch (error: unknown) {
      throw new Error(`Migration failed executing query: ${sql}\nError: ${this.getErrorMessage(error)}`);
    }
  }
  protected async executeQueries(queryRunner: QueryRunner, queries: string[]): Promise<void> {
    for (const query of queries) {
      await this.executeQuery(queryRunner, query);
    }
  }
  public async up(queryRunner: QueryRunner): Promise<void> {
    try {
      // Create enums
      const createEnumQueries = [
        `CREATE TYPE "public"."users_role_enum" AS ENUM('customer', 'employee', 'admin')`,
        `CREATE TYPE "public"."bookings_status_enum" AS ENUM('pending', 'confirmed', 'cancelled', 'completed', 'no_show')`
      ];
      await this.executeQueries(queryRunner, createEnumQueries);
      // Create tables
      const createTableQueries = [
        `CREATE TABLE "users" (
          "id" uuid NOT NULL DEFAULT uuid_generate_v4(),
          "firstName" character varying(100) NOT NULL,
          "lastName" character varying(100) NOT NULL,
          "email" character varying NOT NULL,
          "password" character varying NOT NULL,
          "role" "public"."users_role_enum" NOT NULL DEFAULT 'customer',
          "phoneNumber" character varying,
          "createdAt" TIMESTAMP NOT NULL DEFAULT now(),
          "updatedAt" TIMESTAMP NOT NULL DEFAULT now(),
          CONSTRAINT "UQ_97672ac88f789774dd47f7c8be3" UNIQUE ("email"),
          CONSTRAINT "PK_a3ffb1c0c8416b9fc6f907b7433" PRIMARY KEY ("id")
        )`,
        `CREATE TABLE "employees" (
          "id" uuid NOT NULL DEFAULT uuid_generate_v4(),
          "specializations" text,
          "availability" json,
          "isActive" boolean NOT NULL DEFAULT true,
          "createdAt" TIMESTAMP NOT NULL DEFAULT now(),
          "updatedAt" TIMESTAMP NOT NULL DEFAULT now(),
          "userId" uuid,
          CONSTRAINT "REL_737991e10350d9626f592894ce" UNIQUE ("userId"),
          CONSTRAINT "PK_b9535a98350d5b26e7eb0c26af4" PRIMARY KEY ("id")
        )`,
        `CREATE TABLE "services" (
          "id" uuid NOT NULL DEFAULT uuid_generate_v4(),
          "name" character varying NOT NULL,
          "description" text NOT NULL,
          "price" numeric(10,2) NOT NULL,
          "durationMinutes" integer NOT NULL,
          "isActive" boolean NOT NULL DEFAULT true,
          "categories" text,
          "createdAt" TIMESTAMP NOT NULL DEFAULT now(),
          "updatedAt" TIMESTAMP NOT NULL DEFAULT now(),
          CONSTRAINT "PK_ba2d347a3168a296416c6c5ccb2" PRIMARY KEY ("id")
        )`,
        `CREATE TABLE "bookings" (
          "id" uuid NOT NULL DEFAULT uuid_generate_v4(),
          "startTime" TIMESTAMP NOT NULL,
          "endTime" TIMESTAMP NOT NULL,
          "status" "public"."bookings_status_enum" NOT NULL DEFAULT 'pending',
          "notes" text,
          "totalPrice" numeric(10,2) NOT NULL,
          "reminderSent" boolean NOT NULL DEFAULT false,
          "cancelledAt" TIMESTAMP,
          "cancellationReason" text,
          "createdAt" TIMESTAMP NOT NULL DEFAULT now(),
          "updatedAt" TIMESTAMP NOT NULL DEFAULT now(),
          "customer_id" uuid NOT NULL,
          "employee_id" uuid NOT NULL,
          "service_id" uuid NOT NULL,
          CONSTRAINT "PK_bee6805982cc1e248e94ce94957" PRIMARY KEY ("id")
        )`,
        `CREATE TABLE "employee_services" (
          "service_id" uuid NOT NULL,
          "employee_id" uuid NOT NULL,
          CONSTRAINT "PK_673fd236e781ddb746dd590616a" PRIMARY KEY ("service_id", "employee_id")
        )`
      ];
      await this.executeQueries(queryRunner, createTableQueries);
      // Create indexes
      const createIndexQueries = [
        `CREATE INDEX "IDX_f19f9b60ab07ce81f9affcf797" ON "employee_services" ("service_id")`,
        `CREATE INDEX "IDX_1834a95212d94c86b540273df4" ON "employee_services" ("employee_id")`
      ];
      await this.executeQueries(queryRunner, createIndexQueries);
      // Add foreign key constraints
      const addForeignKeyQueries = [
        `ALTER TABLE "employees" ADD CONSTRAINT "FK_737991e10350d9626f592894cef" FOREIGN KEY ("userId") REFERENCES "users"("id") ON DELETE NO ACTION ON UPDATE NO ACTION`,
        `ALTER TABLE "bookings" ADD CONSTRAINT "FK_8e21b7ae33e7b0673270de4146f" FOREIGN KEY ("customer_id") REFERENCES "users"("id") ON DELETE NO ACTION ON UPDATE NO ACTION`,
        `ALTER TABLE "bookings" ADD CONSTRAINT "FK_eed284d1132173b29a4af74f05f" FOREIGN KEY ("employee_id") REFERENCES "employees"("id") ON DELETE NO ACTION ON UPDATE NO ACTION`,
        `ALTER TABLE "bookings" ADD CONSTRAINT "FK_df22e2beaabc33a432b4f65e3c2" FOREIGN KEY ("service_id") REFERENCES "services"("id") ON DELETE NO ACTION ON UPDATE NO ACTION`,
        `ALTER TABLE "employee_services" ADD CONSTRAINT "FK_f19f9b60ab07ce81f9affcf7974" FOREIGN KEY ("service_id") REFERENCES "services"("id") ON DELETE CASCADE ON UPDATE CASCADE`,
        `ALTER TABLE "employee_services" ADD CONSTRAINT "FK_1834a95212d94c86b540273df4e" FOREIGN KEY ("employee_id") REFERENCES "employees"("id") ON DELETE CASCADE ON UPDATE CASCADE`
      ];
      await this.executeQueries(queryRunner, addForeignKeyQueries);
    } catch (error: unknown) {
      throw new Error(`Migration up failed: ${this.getErrorMessage(error)}`);
    }
  }
  public async down(queryRunner: QueryRunner): Promise<void> {
    try {
      // Drop foreign key constraints
      const dropForeignKeyQueries = [
        `ALTER TABLE "employee_services" DROP CONSTRAINT "FK_1834a95212d94c86b540273df4e"`,
        `ALTER TABLE "employee_services" DROP CONSTRAINT "FK_f19f9b60ab07ce81f9affcf7974"`,
        `ALTER TABLE "bookings" DROP CONSTRAINT "FK_df22e2beaabc33a432b4f65e3c2"`,
        `ALTER TABLE "bookings" DROP CONSTRAINT "FK_eed284d1132173b29a4af74f05f"`,
        `ALTER TABLE "bookings" DROP CONSTRAINT "FK_8e21b7ae33e7b0673270de4146f"`,
        `ALTER TABLE "employees" DROP CONSTRAINT "FK_737991e10350d9626f592894cef"`
      ];
      await this.executeQueries(queryRunner, dropForeignKeyQueries);
      // Drop indexes
      const dropIndexQueries = [
        `DROP INDEX "public"."IDX_1834a95212d94c86b540273df4"`,
        `DROP INDEX "public"."IDX_f19f9b60ab07ce81f9affcf797"`
      ];
      await this.executeQueries(queryRunner, dropIndexQueries);
      // Drop tables in correct order
      const dropTableQueries = [
        `DROP TABLE "employee_services"`,
        `DROP TABLE "bookings"`,
        `DROP TABLE "services"`,
        `DROP TABLE "employees"`,
        `DROP TABLE "users"`
      ];
      await this.executeQueries(queryRunner, dropTableQueries);
      // Drop enums
      const dropEnumQueries = [
        `DROP TYPE "public"."users_role_enum"`,
        `DROP TYPE "public"."bookings_status_enum"`
      ];
      await this.executeQueries(queryRunner, dropEnumQueries);
    } catch (error: unknown) {
      throw new Error(`Migration down failed: ${this.getErrorMessage(error)}`);
    }
  }
}
````

## File: backend/src/database/migrations/1731981975582-CreateBookingSystem.spec.ts
````typescript
import { QueryRunner } from 'typeorm';
import { CreateBookingSystem1731981975582 } from './1731981975582-CreateBookingSystem';
// Helper functions to reduce nesting and improve readability
const findQueryCall = (calls: string[], pattern: string): number =>
  calls.findIndex(call => call.includes(pattern));
const verifyTableSchema = (query: string, tableName: string, ...fields: string[]): void => {
  const tablePattern = new RegExp(`CREATE TABLE[\\s\\S]*${tableName}[\\s\\S]*${fields.join('[\\s\\S]*')}`);
  expect(query).toMatch(tablePattern);
};
const verifyForeignKey = (query: string, tableName: string, columnName: string, referencedTable: string): void => {
  const pattern = new RegExp(
    `CONSTRAINT[\\s\\S]*FOREIGN KEY \\("${columnName}"\\)[\\s\\S]*REFERENCES "${referencedTable}"`,
    'i'
  );
  expect(query).toMatch(pattern);
};
const verifyDropOrder = (calls: string[], tables: string[]): void => {
  const indices = tables.map(table => findQueryCall(calls, `DROP TABLE "${table}"`));
  // Verify each index is greater than the previous one and store the final index
  const finalIndex = indices.reduce((prev, curr) => {
    expect(curr).toBeGreaterThan(prev);
    return curr;
  }, -1); // Start with -1 to ensure first index is valid
  // Verify the final index exists in the array
  expect(indices).toContain(finalIndex);
  // Verify we processed all tables
  expect(finalIndex).toBeLessThan(calls.length);
};
describe('CreateBookingSystem1731981975582', () => {
  let migration: CreateBookingSystem1731981975582;
  let queryRunner: QueryRunner;
  let queryCalls: string[];
  beforeEach(() => {
    migration = new CreateBookingSystem1731981975582();
    queryRunner = {
      query: jest.fn().mockImplementation((query: string) => Promise.resolve([query])),
    } as unknown as QueryRunner;
  });
  afterEach(() => {
    const mockCalls = (queryRunner.query as jest.Mock).mock.calls;
    queryCalls = mockCalls.map((call: [string]) => call[0]);
  });
  test('migration name is correct', () => {
    expect(migration.name).toBe('CreateBookingSystem1731981975582');
  });
  describe('up migration', () => {
    beforeEach(async () => {
      await migration.up(queryRunner);
      const mockCalls = (queryRunner.query as jest.Mock).mock.calls;
      queryCalls = mockCalls.map((call: [string]) => call[0]);
    });
    test('creates services table with required fields', () => {
      const servicesQuery = queryCalls.find(call => call.includes('CREATE TABLE "services"'));
      if (!servicesQuery) throw new Error('Services table creation query not found');
      verifyTableSchema(servicesQuery, 'services', 'id', 'name', 'description', 'duration', 'price');
    });
    test('creates employees table with user foreign key', () => {
      const employeesQuery = queryCalls.find(call => call.includes('CREATE TABLE "employees"'));
      if (!employeesQuery) throw new Error('Employees table creation query not found');
      verifyForeignKey(employeesQuery, 'employees', 'user_id', 'users');
    });
    test('creates employee_services junction table', () => {
      const junctionQuery = queryCalls.find(call => call.includes('CREATE TABLE "employee_services"'));
      if (!junctionQuery) throw new Error('Employee services junction table creation query not found');
      verifyForeignKey(junctionQuery, 'employee_services', 'employee_id', 'employees');
      verifyForeignKey(junctionQuery, 'employee_services', 'service_id', 'services');
    });
    test('creates bookings table with all foreign keys', () => {
      const bookingsQuery = queryCalls.find(call => call.includes('CREATE TABLE "bookings"'));
      if (!bookingsQuery) throw new Error('Bookings table creation query not found');
      [
        ['customer_id', 'users'],
        ['employee_id', 'employees'],
        ['service_id', 'services'],
      ].forEach(([column, reference]) => {
        verifyForeignKey(bookingsQuery, 'bookings', column, reference);
      });
    });
    test('creates all required indexes', () => {
      const indexPatterns = [
        'idx_bookings_customer',
        'idx_bookings_employee',
        'idx_bookings_service',
        'idx_bookings_start_time',
        'idx_bookings_status',
      ];
      indexPatterns.forEach(indexName => {
        expect(queryRunner.query).toHaveBeenCalledWith(
          expect.stringContaining(`CREATE INDEX "${indexName}"`)
        );
      });
    });
  });
  describe('down migration', () => {
    beforeEach(async () => {
      await migration.down(queryRunner);
      const mockCalls = (queryRunner.query as jest.Mock).mock.calls;
      queryCalls = mockCalls.map((call: [string]) => call[0]);
    });
    test('drops indexes in correct order', () => {
      const indexOrder = [
        'idx_bookings_status',
        'idx_bookings_start_time',
        'idx_bookings_service',
        'idx_bookings_employee',
        'idx_bookings_customer',
      ];
      indexOrder.forEach((indexName, i) => {
        const dropIndex = findQueryCall(queryCalls, `DROP INDEX "${indexName}"`);
        expect(dropIndex).toBe(i);
      });
    });
    test('drops tables in correct order', () => {
      const tableOrder = ['bookings', 'employee_services', 'employees', 'services'];
      verifyDropOrder(queryCalls, tableOrder);
    });
    test('drops all required tables', () => {
      const requiredTables = ['bookings', 'employee_services', 'employees', 'services'];
      requiredTables.forEach(tableName => {
        expect(queryRunner.query).toHaveBeenCalledWith(
          expect.stringContaining(`DROP TABLE "${tableName}"`)
        );
      });
    });
  });
});
````

## File: backend/src/database/migrations/1731981975582-CreateBookingSystem.ts
````typescript
import { MigrationInterface, QueryRunner } from "typeorm";
export class CreateBookingSystem1731981975582 implements MigrationInterface {
  name = "CreateBookingSystem1731981975582";
  public async up(queryRunner: QueryRunner): Promise<void> {
    // Create services table
    await queryRunner.query(`
      CREATE TABLE "services" (
        "id" uuid PRIMARY KEY DEFAULT uuid_generate_v4(),
        "name" varchar NOT NULL,
        "description" text NOT NULL,
        "duration" integer NOT NULL,
        "price" decimal(10,2) NOT NULL,
        "is_active" boolean NOT NULL DEFAULT true,
        "created_at" TIMESTAMP NOT NULL DEFAULT now(),
        "updated_at" TIMESTAMP NOT NULL DEFAULT now()
      )
    `);
    // Create employees table
    await queryRunner.query(`
      CREATE TABLE "employees" (
        "id" uuid PRIMARY KEY DEFAULT uuid_generate_v4(),
        "user_id" uuid NOT NULL UNIQUE,
        "specializations" text[] DEFAULT '{}',
        "availability" jsonb,
        "is_active" boolean NOT NULL DEFAULT true,
        "created_at" TIMESTAMP NOT NULL DEFAULT now(),
        "updated_at" TIMESTAMP NOT NULL DEFAULT now(),
        CONSTRAINT "fk_employee_user" FOREIGN KEY ("user_id") 
          REFERENCES "users"("id") ON DELETE CASCADE
      )
    `);
    // Create employee_services junction table
    await queryRunner.query(`
      CREATE TABLE "employee_services" (
        "employee_id" uuid NOT NULL,
        "service_id" uuid NOT NULL,
        CONSTRAINT "pk_employee_services" PRIMARY KEY ("employee_id", "service_id"),
        CONSTRAINT "fk_employee_services_employee" FOREIGN KEY ("employee_id") 
          REFERENCES "employees"("id") ON DELETE CASCADE,
        CONSTRAINT "fk_employee_services_service" FOREIGN KEY ("service_id") 
          REFERENCES "services"("id") ON DELETE CASCADE
      )
    `);
    // Create bookings table
    await queryRunner.query(`
      CREATE TABLE "bookings" (
        "id" uuid PRIMARY KEY DEFAULT uuid_generate_v4(),
        "customer_id" uuid NOT NULL,
        "employee_id" uuid NOT NULL,
        "service_id" uuid NOT NULL,
        "start_time" TIMESTAMP NOT NULL,
        "end_time" TIMESTAMP NOT NULL,
        "status" varchar NOT NULL DEFAULT 'pending',
        "notes" text,
        "total_price" decimal(10,2) NOT NULL,
        "reminder_sent" boolean NOT NULL DEFAULT false,
        "cancelled_at" TIMESTAMP,
        "cancellation_reason" text,
        "created_at" TIMESTAMP NOT NULL DEFAULT now(),
        "updated_at" TIMESTAMP NOT NULL DEFAULT now(),
        CONSTRAINT "fk_booking_customer" FOREIGN KEY ("customer_id") 
          REFERENCES "users"("id") ON DELETE CASCADE,
        CONSTRAINT "fk_booking_employee" FOREIGN KEY ("employee_id") 
          REFERENCES "employees"("id") ON DELETE CASCADE,
        CONSTRAINT "fk_booking_service" FOREIGN KEY ("service_id") 
          REFERENCES "services"("id") ON DELETE CASCADE
      )
    `);
    // Create indexes
    await queryRunner.query(`
      CREATE INDEX "idx_bookings_customer" ON "bookings"("customer_id");
      CREATE INDEX "idx_bookings_employee" ON "bookings"("employee_id");
      CREATE INDEX "idx_bookings_service" ON "bookings"("service_id");
      CREATE INDEX "idx_bookings_start_time" ON "bookings"("start_time");
      CREATE INDEX "idx_bookings_status" ON "bookings"("status");
    `);
  }
  public async down(queryRunner: QueryRunner): Promise<void> {
    // Drop indexes
    await queryRunner.query(`DROP INDEX "idx_bookings_status"`);
    await queryRunner.query(`DROP INDEX "idx_bookings_start_time"`);
    await queryRunner.query(`DROP INDEX "idx_bookings_service"`);
    await queryRunner.query(`DROP INDEX "idx_bookings_employee"`);
    await queryRunner.query(`DROP INDEX "idx_bookings_customer"`);
    // Drop tables
    await queryRunner.query(`DROP TABLE "bookings"`);
    await queryRunner.query(`DROP TABLE "employee_services"`);
    await queryRunner.query(`DROP TABLE "employees"`);
    await queryRunner.query(`DROP TABLE "services"`);
  }
}
````

## File: backend/src/database/migrations/1731981975583-CreateOrders.spec.ts
````typescript
import { QueryRunner, Table, TableForeignKey } from "typeorm";
import { CreateOrders1731981975583 } from "./1731981975583-CreateOrders";
type SafeQueryRunner = {
  createTable: jest.Mock<Promise<Table>, [Table, boolean]>;
  createForeignKey: jest.Mock<Promise<void>, [string, TableForeignKey]>;
  getTable: jest.Mock<Promise<Table>, [string]>;
  dropForeignKey: jest.Mock<Promise<void>, [string, TableForeignKey]>;
  dropTable: jest.Mock<Promise<void>, [string]>;
};
describe("CreateOrders1731981975583", () => {
  let migration: CreateOrders1731981975583;
  let queryRunner: SafeQueryRunner;
  beforeEach(() => {
    migration = new CreateOrders1731981975583();
    queryRunner = {
      createTable: jest.fn<Promise<Table>, [Table, boolean]>().mockResolvedValue(
        new Table({ name: "orders", columns: [] })
      ),
      createForeignKey: jest.fn<Promise<void>, [string, TableForeignKey]>().mockResolvedValue(undefined),
      getTable: jest.fn<Promise<Table>, [string]>().mockResolvedValue(
        new Table({
          name: "orders",
          columns: [],
          foreignKeys: [
            new TableForeignKey({
              columnNames: ["booking_id"],
              referencedColumnNames: ["id"],
              referencedTableName: "bookings",
              onDelete: "CASCADE",
            }),
          ],
        })
      ),
      dropForeignKey: jest.fn<Promise<void>, [string, TableForeignKey]>().mockResolvedValue(undefined),
      dropTable: jest.fn<Promise<void>, [string]>().mockResolvedValue(undefined),
    };
  });
  describe("up", () => {
    it("should create orders table with correct columns", async () => {
      await migration.up(queryRunner as unknown as QueryRunner);
      expect(queryRunner.createTable).toHaveBeenCalledWith(
        expect.any(Table),
        true,
      );
      const table = queryRunner.createTable.mock.calls[0]?.[0];
      if (!(table instanceof Table)) {
        throw new Error('Invalid createTable mock call');
      }
      expect(table.name).toBe("orders");
      expect(table.columns).toHaveLength(7);
      // Check specific columns
      const columns = table.columns;
      expect(columns[0].name).toBe("id");
      expect(columns[0].type).toBe("uuid");
      expect(columns[0].isPrimary).toBe(true);
      expect(columns[1].name).toBe("booking_id");
      expect(columns[1].type).toBe("uuid");
      expect(columns[2].name).toBe("completed_at");
      expect(columns[2].type).toBe("timestamp");
      expect(columns[3].name).toBe("total_amount");
      expect(columns[3].type).toBe("decimal");
      expect(columns[3].precision).toBe(10);
      expect(columns[3].scale).toBe(2);
      expect(columns[4].name).toBe("notes");
      expect(columns[4].type).toBe("text");
      expect(columns[4].isNullable).toBe(true);
      expect(columns[5].name).toBe("created_at");
      expect(columns[5].type).toBe("timestamp");
      expect(columns[6].name).toBe("updated_at");
      expect(columns[6].type).toBe("timestamp");
    });
    it("should create foreign key for booking_id", async () => {
      await migration.up(queryRunner as unknown as QueryRunner);
      expect(queryRunner.createForeignKey).toHaveBeenCalledWith(
        "orders",
        expect.any(TableForeignKey),
      );
      const foreignKey = queryRunner.createForeignKey.mock.calls[0]?.[1];
      if (!(foreignKey instanceof TableForeignKey)) {
        throw new Error('Invalid createForeignKey mock call');
      }
      expect(foreignKey.columnNames).toEqual(["booking_id"]);
      expect(foreignKey.referencedColumnNames).toEqual(["id"]);
      expect(foreignKey.referencedTableName).toBe("bookings");
      expect(foreignKey.onDelete).toBe("CASCADE");
    });
  });
  describe("down", () => {
    it("should drop foreign key and table", async () => {
      await migration.down(queryRunner as unknown as QueryRunner);
      expect(queryRunner.getTable).toHaveBeenCalledWith("orders");
      expect(queryRunner.dropForeignKey).toHaveBeenCalledWith(
        "orders",
        expect.any(TableForeignKey)
      );
      expect(queryRunner.dropTable).toHaveBeenCalledWith("orders");
      // Verify the mock calls have correct types
      const foreignKey = queryRunner.dropForeignKey.mock.calls[0]?.[1];
      if (!(foreignKey instanceof TableForeignKey)) {
        throw new Error('Invalid dropForeignKey mock call');
      }
    });
  });
});
````

## File: backend/src/database/migrations/1731981975583-CreateOrders.ts
````typescript
import { MigrationInterface, QueryRunner, Table, TableForeignKey } from "typeorm";
export class CreateOrders1731981975583 implements MigrationInterface {
  private async executeQuery<T>(
    operation: () => Promise<T>,
    errorMessage: string
  ): Promise<T> {
    try {
      return await operation();
    } catch (error) {
      throw new Error(
        `${errorMessage}: ${error instanceof Error ? error.message : String(error)}`
      );
    }
  }
  public async up(queryRunner: QueryRunner): Promise<void> {
    await this.executeQuery(
      async () => {
        await queryRunner.createTable(
          new Table({
            name: "orders",
            columns: [
              {
                name: "id",
                type: "uuid",
                isPrimary: true,
                generationStrategy: "uuid",
                default: "uuid_generate_v4()",
              },
              {
                name: "booking_id",
                type: "uuid",
              },
              {
                name: "completed_at",
                type: "timestamp",
              },
              {
                name: "total_amount",
                type: "decimal",
                precision: 10,
                scale: 2,
              },
              {
                name: "notes",
                type: "text",
                isNullable: true,
              },
              {
                name: "created_at",
                type: "timestamp",
                default: "now()",
              },
              {
                name: "updated_at",
                type: "timestamp",
                default: "now()",
              },
            ],
          }),
          true,
        );
        await queryRunner.createForeignKey(
          "orders",
          new TableForeignKey({
            columnNames: ["booking_id"],
            referencedColumnNames: ["id"],
            referencedTableName: "bookings",
            onDelete: "CASCADE",
          }),
        );
      },
      "Failed to create orders table"
    );
  }
  public async down(queryRunner: QueryRunner): Promise<void> {
    await this.executeQuery(
      async () => {
        const table = await queryRunner.getTable("orders");
        if (!table) {
          throw new Error("Orders table not found");
        }
        const foreignKeys = table.foreignKeys;
        if (!Array.isArray(foreignKeys)) {
          throw new Error("Invalid foreign keys structure");
        }
        const foreignKey = foreignKeys.find(
          (fk) => Array.isArray(fk.columnNames) && fk.columnNames.includes("booking_id")
        );
        if (!foreignKey) {
          throw new Error("Foreign key for booking_id not found");
        }
        await queryRunner.dropForeignKey("orders", foreignKey);
        await queryRunner.dropTable("orders");
      },
      "Failed to drop orders table"
    );
  }
}
````

## File: backend/src/database/migrations/1731981975584-AddShopCodes.spec.ts
````typescript
import { QueryRunner } from 'typeorm';
import { AddShopCodes1731981975584 } from './1731981975584-AddShopCodes';
type SafeQueryRunner = {
  hasTable: jest.Mock<Promise<boolean>, [string]>;
  query: jest.Mock<Promise<void>, [string]>;
};
describe('AddShopCodes1731981975584', () => {
  let migration: AddShopCodes1731981975584;
  let queryRunner: SafeQueryRunner;
  beforeEach(() => {
    migration = new AddShopCodes1731981975584();
    queryRunner = {
      hasTable: jest.fn<Promise<boolean>, [string]>().mockResolvedValue(false),
      query: jest.fn<Promise<void>, [string]>().mockResolvedValue(undefined),
    };
  });
  it('should have correct name', () => {
    expect(migration.name).toBe('AddShopCodes1731981975584');
  });
  describe('up', () => {
    it('should create shop_codes table if it does not exist', async () => {
      queryRunner.hasTable.mockResolvedValue(false);
      await migration.up(queryRunner as unknown as QueryRunner);
      expect(queryRunner.hasTable).toHaveBeenCalledWith('shop_codes');
      expect(queryRunner.query).toHaveBeenCalledTimes(2);
      const calls = queryRunner.query.mock.calls;
      if (!Array.isArray(calls) || calls.length < 2) {
        throw new Error('Expected at least 2 query calls');
      }
      const createTableQuery = calls[0][0];
      const insertDataQuery = calls[1][0];
      if (typeof createTableQuery !== 'string' || typeof insertDataQuery !== 'string') {
        throw new Error('Expected string queries');
      }
      // Verify create table query
      expect(createTableQuery).toContain('CREATE TABLE "shop_codes"');
      expect(createTableQuery).toContain('"id" uuid NOT NULL DEFAULT uuid_generate_v4()');
      expect(createTableQuery).toContain('"code" character varying NOT NULL');
      expect(createTableQuery).toContain('"shop_name" character varying NOT NULL');
      expect(createTableQuery).toContain('"is_active" boolean NOT NULL DEFAULT true');
      expect(createTableQuery).toContain('"daily_booking_limit" integer NOT NULL DEFAULT 100');
      expect(createTableQuery).toContain('"last_booking_time" TIMESTAMP');
      expect(createTableQuery).toContain('"today_booking_count" integer NOT NULL DEFAULT 0');
      expect(createTableQuery).toContain('"created_at" TIMESTAMP NOT NULL DEFAULT now()');
      expect(createTableQuery).toContain('"updated_at" TIMESTAMP NOT NULL DEFAULT now()');
      // Verify initial data insertion
      expect(insertDataQuery).toContain('INSERT INTO "shop_codes"');
      expect(insertDataQuery).toContain('SHOP123');
      expect(insertDataQuery).toContain('Test Shop');
    });
    it('should not create shop_codes table if it already exists', async () => {
      queryRunner.hasTable.mockResolvedValue(true);
      await migration.up(queryRunner as unknown as QueryRunner);
      expect(queryRunner.hasTable).toHaveBeenCalledWith('shop_codes');
      expect(queryRunner.query).not.toHaveBeenCalled();
    });
  });
  describe('down', () => {
    it('should drop shop_codes table', async () => {
      await migration.down(queryRunner as unknown as QueryRunner);
      expect(queryRunner.query).toHaveBeenCalledWith('DROP TABLE IF EXISTS "shop_codes"');
      const calls = queryRunner.query.mock.calls;
      if (!Array.isArray(calls) || calls.length === 0) {
        throw new Error('Expected at least one query call');
      }
      const dropTableQuery = calls[0][0];
      if (typeof dropTableQuery !== 'string') {
        throw new Error('Expected string query');
      }
      expect(dropTableQuery).toBe('DROP TABLE IF EXISTS "shop_codes"');
    });
  });
});
````

## File: backend/src/database/migrations/1731981975584-AddShopCodes.ts
````typescript
import { MigrationInterface, QueryRunner } from "typeorm";
export class AddShopCodes1731981975584 implements MigrationInterface {
  name = "AddShopCodes1731981975584";
  public async up(queryRunner: QueryRunner): Promise<void> {
    // Check if table exists first
    const tableExists = await queryRunner.hasTable("shop_codes");
    if (!tableExists) {
      await queryRunner.query(`
                CREATE TABLE "shop_codes" (
                    "id" uuid NOT NULL DEFAULT uuid_generate_v4(),
                    "code" character varying NOT NULL,
                    "shop_name" character varying NOT NULL,
                    "is_active" boolean NOT NULL DEFAULT true,
                    "daily_booking_limit" integer NOT NULL DEFAULT 100,
                    "last_booking_time" TIMESTAMP,
                    "today_booking_count" integer NOT NULL DEFAULT 0,
                    "created_at" TIMESTAMP NOT NULL DEFAULT now(),
                    "updated_at" TIMESTAMP NOT NULL DEFAULT now(),
                    CONSTRAINT "UQ_shop_codes_code" UNIQUE ("code"),
                    CONSTRAINT "PK_shop_codes" PRIMARY KEY ("id")
                )
            `);
      // Insert initial shop code for testing
      await queryRunner.query(`
                INSERT INTO "shop_codes" ("code", "shop_name")
                VALUES ('SHOP123', 'Test Shop')
            `);
    }
  }
  public async down(queryRunner: QueryRunner): Promise<void> {
    await queryRunner.query(`DROP TABLE IF EXISTS "shop_codes"`);
  }
}
````

## File: backend/src/database/migrations/1732141970009-ClearServices.spec.ts
````typescript
import { QueryRunner } from 'typeorm';
import { ClearServices1732141970009 } from './1732141970009-ClearServices';
describe('ClearServices1732141970009', () => {
  let migration: ClearServices1732141970009;
  let queryRunner: QueryRunner;
  beforeEach(() => {
    migration = new ClearServices1732141970009();
    queryRunner = {
      query: jest.fn(),
    } as unknown as QueryRunner;
  });
  describe('up', () => {
    it('should clear existing services and insert new Norwegian services', async () => {
      await migration.up(queryRunner);
      const { calls } = (queryRunner.query as jest.Mock).mock;
      const queries = calls.map((call: unknown[]) => call[0] as string);
      // Verify deletion queries
      expect(queries).toContain('DELETE FROM "employee_services"');
      expect(queries).toContain('DELETE FROM "services"');
      // Verify service insertions
      const insertQuery = queries.find(q => q.includes('INSERT INTO "services"'));
      expect(insertQuery).toBeDefined();
      const expectedServices = [
        'Standard Klipp',
        'Styling Klipp',
        'Skjegg Trim',
        'Full Service'
      ];
      expectedServices.forEach(service => {
        expect(insertQuery).toContain(service);
      });
    });
  });
  describe('down', () => {
    it('should delete Norwegian services', async () => {
      await migration.down(queryRunner);
      const { calls } = (queryRunner.query as jest.Mock).mock;
      const queries = calls.map((call: unknown[]) => call[0] as string);
      const expectedQuery = 'DELETE FROM "services" WHERE "name" IN (\'Standard Klipp\', \'Styling Klipp\', \'Skjegg Trim\', \'Full Service\')';
      expect(queries).toContain(expectedQuery);
    });
  });
});
````

## File: backend/src/database/migrations/1732141970009-ClearServices.ts
````typescript
import { MigrationInterface, QueryRunner } from "typeorm";
export class ClearServices1732141970009 implements MigrationInterface {
    public async up(queryRunner: QueryRunner): Promise<void> {
        // First, delete all records from employee_services junction table
        await queryRunner.query(`DELETE FROM "employee_services"`);
        // Then, delete all records from services table
        await queryRunner.query(`DELETE FROM "services"`);
        // Insert new Norwegian services
        await queryRunner.query(`
            INSERT INTO "services" ("name", "description", "duration", "price", "isActive")
            VALUES 
            ('Standard Klipp', 'En standard og effektiv hårklipp for deg som har det travelt. Perfekt for å vedlikeholde din nåværende stil.', 20, 299.00, true),
            ('Styling Klipp', 'Komplett hårklipp og styling-service. Inkluderer konsultasjon for å finne det perfekte utseendet.', 30, 399.00, true),
            ('Skjegg Trim', 'Profesjonell skjeggtrimming og forming for å holde skjegget ditt velstelt.', 15, 199.00, true),
            ('Full Service', 'Komplett pakke som inkluderer hårklipp, skjeggtrim og styling. Vår premium-tjeneste.', 45, 549.00, true)
        `);
    }
    public async down(queryRunner: QueryRunner): Promise<void> {
        // Delete the Norwegian services
        await queryRunner.query(`DELETE FROM "services" WHERE "name" IN ('Standard Klipp', 'Styling Klipp', 'Skjegg Trim', 'Full Service')`);
    }
}
````

## File: backend/src/database/migrations/1732142680425-UpdateServices.spec.ts
````typescript
import { QueryRunner } from 'typeorm';
import { UpdateServices1732142680425 } from './1732142680425-UpdateServices';
describe('UpdateServices1732142680425', () => {
  let migration: UpdateServices1732142680425;
  let queryRunner: QueryRunner;
  let queryMock: jest.Mock;
  beforeEach(() => {
    queryMock = jest.fn();
    queryRunner = {
      query: queryMock,
    } as unknown as QueryRunner;
    migration = new UpdateServices1732142680425();
  });
  describe('up', () => {
    it('should clear existing services and insert updated Norwegian services', async () => {
      await migration.up(queryRunner);
      // Verify deletion queries
      expect(queryRunner.query).toHaveBeenCalledWith(`DELETE FROM "employee_services"`);
      expect(queryRunner.query).toHaveBeenCalledWith(`DELETE FROM "services"`);
      // Verify insertion of updated services
      const calls = queryMock.mock.calls as [string][];
      if (!Array.isArray(calls) || calls.length < 3) {
        throw new Error('Expected at least 3 query calls');
      }
      const insertQuery = calls[2][0];
      if (typeof insertQuery !== 'string') {
        throw new Error('Expected string query');
      }
      expect(insertQuery).toContain('INSERT INTO "services"');
      expect(insertQuery).toContain('Standard Klipp');
      expect(insertQuery).toContain('299.00');
      expect(insertQuery).toContain('Styling Klipp');
      expect(insertQuery).toContain('399.00');
      expect(insertQuery).toContain('Skjegg Trim');
      expect(insertQuery).toContain('199.00');
      expect(insertQuery).toContain('Full Service');
      expect(insertQuery).toContain('549.00');
    });
  });
  describe('down', () => {
    it('should delete updated Norwegian services', async () => {
      await migration.down(queryRunner);
      expect(queryRunner.query).toHaveBeenCalledWith(
        `DELETE FROM "services" WHERE "name" IN ('Standard Klipp', 'Styling Klipp', 'Skjegg Trim', 'Full Service')`
      );
    });
  });
});
````

## File: backend/src/database/migrations/1732142680425-UpdateServices.ts
````typescript
import { MigrationInterface, QueryRunner } from "typeorm";
export class UpdateServices1732142680425 implements MigrationInterface {
    public async up(queryRunner: QueryRunner): Promise<void> {
        // First, delete all records from employee_services junction table
        await queryRunner.query(`DELETE FROM "employee_services"`);
        // Then, delete all records from services table
        await queryRunner.query(`DELETE FROM "services"`);
        // Insert new Norwegian services
        await queryRunner.query(`
            INSERT INTO "services" ("name", "description", "duration", "price", "isActive")
            VALUES 
            ('Standard Klipp', 'En standard og effektiv hårklipp for deg som har det travelt. Perfekt for å vedlikeholde din nåværende stil.', 20, 299.00, true),
            ('Styling Klipp', 'Komplett hårklipp og styling-service. Inkluderer konsultasjon for å finne det perfekte utseendet.', 30, 399.00, true),
            ('Skjegg Trim', 'Profesjonell skjeggtrimming og forming for å holde skjegget ditt velstelt.', 15, 199.00, true),
            ('Full Service', 'Komplett pakke som inkluderer hårklipp, skjeggtrim og styling. Vår premium-tjeneste.', 45, 549.00, true)
        `);
    }
    public async down(queryRunner: QueryRunner): Promise<void> {
        // Delete the Norwegian services
        await queryRunner.query(`DELETE FROM "services" WHERE "name" IN ('Standard Klipp', 'Styling Klipp', 'Skjegg Trim', 'Full Service')`);
    }
}
````

## File: backend/src/database/seeds/create-admin-user.seed.spec.ts
````typescript
import { DataSource, Repository } from 'typeorm';
import { User, UserRole } from '../../users/entities/user.entity';
import { createAdminUser } from './create-admin-user.seed';
import * as bcrypt from 'bcrypt';
jest.mock('bcrypt');
describe('createAdminUser', () => {
  let mockDataSource: Partial<DataSource>;
  let mockUserRepository: Partial<Repository<User>>;
  const originalEnv = process.env;
  beforeEach(() => {
    // Mock repository methods
    mockUserRepository = {
      findOne: jest.fn(),
      create: jest.fn(),
      save: jest.fn(),
    };
    // Mock DataSource
    mockDataSource = {
      getRepository: jest.fn().mockReturnValue(mockUserRepository),
    };
    // Mock bcrypt
    (bcrypt.hash as jest.Mock).mockResolvedValue('hashed-password');
    // Setup test environment variables
    process.env = {
      ...originalEnv,
      ADMIN_EMAIL: 'admin@example.com',
      ADMIN_PASSWORD: 'admin123',
    };
    // Mock console methods
    jest.spyOn(console, 'log').mockImplementation(() => {});
    jest.spyOn(console, 'error').mockImplementation(() => {});
  });
  afterEach(() => {
    process.env = originalEnv;
    jest.clearAllMocks();
  });
  it('should create admin user when it does not exist', async () => {
    // Mock that admin doesn't exist
    (mockUserRepository.findOne as jest.Mock).mockResolvedValue(null);
    // Mock created user
    const mockCreatedUser = {
      email: 'admin@example.com',
      password: 'hashed-password',
      firstName: 'Admin',
      lastName: 'User',
      role: UserRole.ADMIN,
    };
    (mockUserRepository.create as jest.Mock).mockReturnValue(mockCreatedUser);
    (mockUserRepository.save as jest.Mock).mockResolvedValue(mockCreatedUser);
    await createAdminUser(mockDataSource as DataSource);
    // Verify admin user was searched for
    expect(mockUserRepository.findOne).toHaveBeenCalledWith({
      where: { email: 'admin@example.com' },
    });
    // Verify password was hashed
    expect(bcrypt.hash).toHaveBeenCalledWith('admin123', 10);
    // Verify user was created with correct data
    expect(mockUserRepository.create).toHaveBeenCalledWith({
      email: 'admin@example.com',
      password: 'hashed-password',
      firstName: 'Admin',
      lastName: 'User',
      role: UserRole.ADMIN,
    });
    // Verify user was saved
    expect(mockUserRepository.save).toHaveBeenCalledWith(mockCreatedUser);
    // Verify success message was logged
    expect(console.log).toHaveBeenCalledWith('Admin user created successfully');
  });
  it('should not create admin user when it already exists', async () => {
    // Mock that admin already exists
    const existingAdmin = {
      email: 'admin@example.com',
      role: UserRole.ADMIN,
    };
    (mockUserRepository.findOne as jest.Mock).mockResolvedValue(existingAdmin);
    await createAdminUser(mockDataSource as DataSource);
    // Verify admin user was searched for
    expect(mockUserRepository.findOne).toHaveBeenCalledWith({
      where: { email: 'admin@example.com' },
    });
    // Verify no creation attempts were made
    expect(mockUserRepository.create).not.toHaveBeenCalled();
    expect(mockUserRepository.save).not.toHaveBeenCalled();
    // Verify appropriate message was logged
    expect(console.log).toHaveBeenCalledWith('Admin user already exists');
  });
  it('should throw error when admin email is missing', async () => {
    delete process.env.ADMIN_EMAIL;
    await expect(createAdminUser(mockDataSource as DataSource)).rejects.toThrow(
      'Admin email and password must be set in environment variables',
    );
    // Verify no database operations were attempted
    expect(mockUserRepository.findOne).not.toHaveBeenCalled();
    expect(mockUserRepository.create).not.toHaveBeenCalled();
    expect(mockUserRepository.save).not.toHaveBeenCalled();
  });
  it('should throw error when admin password is missing', async () => {
    delete process.env.ADMIN_PASSWORD;
    await expect(createAdminUser(mockDataSource as DataSource)).rejects.toThrow(
      'Admin email and password must be set in environment variables',
    );
    // Verify no database operations were attempted
    expect(mockUserRepository.findOne).not.toHaveBeenCalled();
    expect(mockUserRepository.create).not.toHaveBeenCalled();
    expect(mockUserRepository.save).not.toHaveBeenCalled();
  });
  it('should handle database errors', async () => {
    // Mock database error
    const dbError = new Error('Database connection failed');
    (mockUserRepository.findOne as jest.Mock).mockRejectedValue(dbError);
    await expect(createAdminUser(mockDataSource as DataSource)).rejects.toThrow(dbError);
    // Verify error was logged
    expect(console.error).toHaveBeenCalledWith('Error creating admin user:', dbError);
  });
  it('should handle password hashing errors', async () => {
    // Mock that admin doesn't exist
    (mockUserRepository.findOne as jest.Mock).mockResolvedValue(null);
    // Mock bcrypt error
    const hashError = new Error('Hashing failed');
    (bcrypt.hash as jest.Mock).mockRejectedValue(hashError);
    await expect(createAdminUser(mockDataSource as DataSource)).rejects.toThrow(hashError);
    // Verify error was logged
    expect(console.error).toHaveBeenCalledWith('Error creating admin user:', hashError);
  });
});
````

## File: backend/src/database/seeds/create-admin-user.seed.ts
````typescript
import { DataSource } from "typeorm";
import { User, UserRole } from "../../users/entities/user.entity";
import * as bcrypt from "bcrypt";
export const createAdminUser = async (dataSource: DataSource): Promise<void> => {
  const userRepository = dataSource.getRepository(User);
  try {
    const adminEmail = process.env.ADMIN_EMAIL;
    const adminPassword = process.env.ADMIN_PASSWORD;
    if (!adminEmail || !adminPassword) {
      throw new Error(
        "Admin email and password must be set in environment variables",
      );
    }
    // Check if admin user already exists
    const existingAdmin = await userRepository.findOne({
      where: { email: adminEmail },
    });
    if (!existingAdmin) {
      const hashedPassword = await bcrypt.hash(adminPassword, 10);
      const adminUser = userRepository.create({
        email: adminEmail,
        password: hashedPassword,
        firstName: "Admin",
        lastName: "User",
        role: UserRole.ADMIN,
      });
      await userRepository.save(adminUser);
      console.log("Admin user created successfully");
    } else {
      console.log("Admin user already exists");
    }
  } catch (error) {
    console.error("Error creating admin user:", error);
    throw error;
  }
};
````

## File: backend/src/database/seeds/create-initial-data.seed.spec.ts
````typescript
import { DataSource, Repository, EntityTarget } from "typeorm";
import { User, UserRole } from "../../users/entities/user.entity";
import { Employee } from "../../employees/entities/employee.entity";
import { Service } from "../../services/entities/service.entity";
import { createInitialData } from "./create-initial-data.seed";
import * as bcrypt from "bcrypt";
jest.mock("bcrypt");
interface RepositoryMapping {
  User: Repository<User>;
  Employee: Repository<Employee>;
  Service: Repository<Service>;
}
type SupportedEntity = User | Employee | Service;
function getEntityName(entity: EntityTarget<SupportedEntity>): keyof RepositoryMapping {
  if (typeof entity === "function") {
    return entity.name as keyof RepositoryMapping;
  }
  throw new Error("Unsupported entity type");
}
describe("createInitialData", () => {
  let mockDataSource: Partial<DataSource>;
  let mockUserRepository: Partial<Repository<User>>;
  let mockEmployeeRepository: Partial<Repository<Employee>>;
  let mockServiceRepository: Partial<Repository<Service>>;
  let mockQueryBuilder: {
    insert: jest.Mock;
    into: jest.Mock;
    values: jest.Mock;
    execute: jest.Mock;
  };
  const originalEnv = process.env;
  beforeEach(() => {
    // Mock repositories with proper typing
    mockUserRepository = {
      findOne: jest.fn().mockResolvedValue(null),
      save: jest
        .fn()
        .mockImplementation((data: Partial<User>): Promise<User> =>
          Promise.resolve({ id: "user-1", ...data } as User)
        ),
    };
    mockEmployeeRepository = {
      save: jest
        .fn()
        .mockImplementation((data: Partial<Employee>): Promise<Employee> =>
          Promise.resolve({ id: "employee-1", ...data } as Employee)
        ),
    };
    mockServiceRepository = {
      save: jest
        .fn()
        .mockImplementation((services: Partial<Service> | Partial<Service>[]): Promise<Service | Service[]> =>
          Promise.resolve(
            Array.isArray(services)
              ? services.map((s, i) => ({ ...s, id: `service-${i + 1}` } as Service))
              : { ...services, id: 'service-1' } as Service
          )
        ),
    };
    // Mock query builder for service associations
    mockQueryBuilder = {
      insert: jest.fn().mockReturnThis(),
      into: jest.fn().mockReturnThis(),
      values: jest.fn().mockReturnThis(),
      execute: jest.fn().mockResolvedValue(undefined),
    };
    // Mock DataSource with proper typing
    const mockGetRepository = <T extends SupportedEntity>(entity: EntityTarget<T>) => {
      const repositories: RepositoryMapping = {
        User: mockUserRepository as Repository<User>,
        Employee: mockEmployeeRepository as Repository<Employee>,
        Service: mockServiceRepository as Repository<Service>,
      };
      const entityName = getEntityName(entity);
      const repository = repositories[entityName];
      if (!repository) {
        throw new Error(`Repository not mocked for entity: ${entityName}`);
      }
      return repository as Repository<T>;
    };
    mockDataSource = {
      getRepository: jest.fn().mockImplementation(mockGetRepository),
      createQueryBuilder: jest.fn().mockReturnValue(mockQueryBuilder),
    };
    // Mock bcrypt
    (bcrypt.hash as jest.Mock).mockResolvedValue("hashed-password");
    // Setup test environment variables
    process.env = {
      ...originalEnv,
      EMPLOYEE_EMAIL: "employee@example.com",
      EMPLOYEE_PASSWORD: "employee123",
      EMPLOYEE_PHONE: "+1234567890",
    };
    // Mock console methods
    jest.spyOn(console, "log").mockImplementation(() => {});
    jest.spyOn(console, "error").mockImplementation(() => {});
  });
  afterEach(() => {
    process.env = originalEnv;
    jest.clearAllMocks();
  });
  test("creates services, employee user, and employee when they do not exist", async () => {
    // Mock that employee doesn't exist
    (mockUserRepository.findOne as jest.Mock).mockResolvedValue(null);
    // Mock created services
    const mockServices = [
      { id: "service-1", name: "Standard Klipp" },
      { id: "service-2", name: "Styling Klipp" },
      { id: "service-3", name: "Skjegg Trim" },
      { id: "service-4", name: "Full Service" },
    ];
    (mockServiceRepository.save as jest.Mock).mockResolvedValue(mockServices);
    // Mock created employee user
    const mockEmployeeUser = {
      id: "user-1",
      email: "employee@example.com",
      role: UserRole.EMPLOYEE,
    };
    (mockUserRepository.save as jest.Mock).mockResolvedValue(mockEmployeeUser);
    // Mock created employee
    const mockEmployee = {
      id: "employee-1",
      user: mockEmployeeUser,
    };
    (mockEmployeeRepository.save as jest.Mock).mockResolvedValue(mockEmployee);
    await createInitialData(mockDataSource as DataSource);
    // Verify services were created
    expect(mockServiceRepository.save).toHaveBeenCalledWith([
      expect.objectContaining({ name: "Standard Klipp" }),
      expect.objectContaining({ name: "Styling Klipp" }),
      expect.objectContaining({ name: "Skjegg Trim" }),
      expect.objectContaining({ name: "Full Service" }),
    ]);
    // Verify employee user was created
    expect(mockUserRepository.save).toHaveBeenCalledWith(
      expect.objectContaining({
        email: "employee@example.com",
        role: UserRole.EMPLOYEE,
      })
    );
    // Verify employee was created
    expect(mockEmployeeRepository.save).toHaveBeenCalledWith(
      expect.objectContaining({
        user: mockEmployeeUser,
        specializations: ["klipp", "styling", "skjegg"],
      })
    );
    // Verify services were associated with employee
    expect(mockQueryBuilder.insert).toHaveBeenCalled();
    expect(mockQueryBuilder.into).toHaveBeenCalledWith("employee_services");
    expect(mockQueryBuilder.values).toHaveBeenCalledWith(
      mockServices.map((service) => ({
        employee_id: mockEmployee.id,
        service_id: service.id,
      }))
    );
    // Verify success message was logged
    expect(console.log).toHaveBeenCalledWith(
      "Initial data seeded successfully"
    );
  });
  test("does not create employee when it already exists", async () => {
    // Mock that employee already exists
    const existingEmployee = {
      email: "employee@example.com",
      role: UserRole.EMPLOYEE,
    };
    (mockUserRepository.findOne as jest.Mock).mockResolvedValue(
      existingEmployee
    );
    await createInitialData(mockDataSource as DataSource);
    // Verify services were still created
    expect(mockServiceRepository.save).toHaveBeenCalled();
    // Verify no employee creation attempts were made
    expect(mockUserRepository.save).not.toHaveBeenCalled();
    expect(mockEmployeeRepository.save).not.toHaveBeenCalled();
    expect(mockQueryBuilder.insert).not.toHaveBeenCalled();
    // Verify appropriate message was logged
    expect(console.log).toHaveBeenCalledWith("Employee user already exists");
  });
  test("throws error when employee email is missing", async () => {
    delete process.env.EMPLOYEE_EMAIL;
    await expect(
      createInitialData(mockDataSource as DataSource)
    ).rejects.toThrow(
      "Employee email and password must be set in environment variables"
    );
    // Verify no database operations were attempted
    expect(mockServiceRepository.save).not.toHaveBeenCalled();
    expect(mockUserRepository.findOne).not.toHaveBeenCalled();
    expect(mockUserRepository.save).not.toHaveBeenCalled();
    expect(mockEmployeeRepository.save).not.toHaveBeenCalled();
  });
  test("throws error when employee password is missing", async () => {
    delete process.env.EMPLOYEE_PASSWORD;
    await expect(
      createInitialData(mockDataSource as DataSource)
    ).rejects.toThrow(
      "Employee email and password must be set in environment variables"
    );
    // Verify no database operations were attempted
    expect(mockServiceRepository.save).not.toHaveBeenCalled();
    expect(mockUserRepository.findOne).not.toHaveBeenCalled();
    expect(mockUserRepository.save).not.toHaveBeenCalled();
    expect(mockEmployeeRepository.save).not.toHaveBeenCalled();
  });
  test("handles database errors during service creation", async () => {
    const dbError = new Error("Database error during service creation");
    (mockServiceRepository.save as jest.Mock).mockRejectedValue(dbError);
    await expect(
      createInitialData(mockDataSource as DataSource)
    ).rejects.toThrow(dbError);
    // Verify error was logged
    expect(console.error).toHaveBeenCalledWith(
      "Error creating initial data:",
      dbError.message
    );
  });
  test("handles database errors during employee creation", async () => {
    // Mock that employee doesn't exist
    (mockUserRepository.findOne as jest.Mock).mockResolvedValue(null);
    // Mock services creation success
    (mockServiceRepository.save as jest.Mock).mockResolvedValue([]);
    // Mock employee creation error
    const dbError = new Error("Database error during employee creation");
    (mockUserRepository.save as jest.Mock).mockRejectedValue(dbError);
    await expect(
      createInitialData(mockDataSource as DataSource)
    ).rejects.toThrow(dbError);
    // Verify error was logged
    expect(console.error).toHaveBeenCalledWith(
      "Error creating initial data:",
      dbError.message
    );
  });
  test("handles password hashing errors", async () => {
    // Mock that employee doesn't exist
    (mockUserRepository.findOne as jest.Mock).mockResolvedValue(null);
    // Mock services creation success
    (mockServiceRepository.save as jest.Mock).mockResolvedValue([]);
    // Mock bcrypt error
    const hashError = new Error("Hashing failed");
    (bcrypt.hash as jest.Mock).mockRejectedValue(hashError);
    await expect(
      createInitialData(mockDataSource as DataSource)
    ).rejects.toThrow(hashError);
    // Verify error was logged
    expect(console.error).toHaveBeenCalledWith(
      "Error creating initial data:",
      hashError.message
    );
  });
  test("uses default phone number when EMPLOYEE_PHONE is not set", async () => {
    // Remove EMPLOYEE_PHONE from environment
    delete process.env.EMPLOYEE_PHONE;
    // Mock that employee doesn't exist
    (mockUserRepository.findOne as jest.Mock).mockResolvedValue(null);
    // Mock created services
    const mockServices = [{ id: "service-1", name: "Standard Klipp" }];
    (mockServiceRepository.save as jest.Mock).mockResolvedValue(mockServices);
    // Mock created employee user
    const mockEmployeeUser = {
      id: "user-1",
      email: "employee@example.com",
      role: UserRole.EMPLOYEE,
    };
    (mockUserRepository.save as jest.Mock).mockResolvedValue(mockEmployeeUser);
    // Mock created employee
    const mockEmployee = {
      id: "employee-1",
      user: mockEmployeeUser,
    };
    (mockEmployeeRepository.save as jest.Mock).mockResolvedValue(mockEmployee);
    await createInitialData(mockDataSource as DataSource);
    // Verify employee user was created with default phone number
    expect(mockUserRepository.save).toHaveBeenCalledWith(
      expect.objectContaining({
        phoneNumber: "+1234567890", // This is the default value
      })
    );
  });
});
````

## File: backend/src/database/seeds/create-initial-data.seed.ts
````typescript
import { DataSource } from "typeorm";
import { User, UserRole } from "../../users/entities/user.entity";
import { Employee } from "../../employees/entities/employee.entity";
import { Service } from "../../services/entities/service.entity";
import * as bcrypt from "bcrypt";
interface ServiceWithId extends Service {
  id: string;
}
interface EmployeeWithId extends Employee {
  id: string;
}
interface EmployeeServiceAssociation {
  employee_id: string;
  service_id: string;
}
export const createInitialData = async (dataSource: DataSource): Promise<void> => {
  const userRepository = dataSource.getRepository(User);
  const employeeRepository = dataSource.getRepository(Employee);
  const serviceRepository = dataSource.getRepository(Service);
  try {
    const employeeEmail = process.env.EMPLOYEE_EMAIL;
    const employeePassword = process.env.EMPLOYEE_PASSWORD;
    if (!employeeEmail || !employeePassword) {
      throw new Error(
        "Employee email and password must be set in environment variables",
      );
    }
    // Create services
    const services = await serviceRepository.save([
      {
        name: "Standard Klipp",
        description: "En standard og effektiv hårklipp for deg som har det travelt. Perfekt for å vedlikeholde din nåværende stil.",
        price: 299.0,
        duration: 20,
        isActive: true,
      },
      {
        name: "Styling Klipp",
        description: "Komplett hårklipp og styling-service. Inkluderer konsultasjon for å finne det perfekte utseendet.",
        price: 399.0,
        duration: 30,
        isActive: true,
      },
      {
        name: "Skjegg Trim",
        description: "Profesjonell skjeggtrimming og forming for å holde skjegget ditt velstelt.",
        price: 199.0,
        duration: 15,
        isActive: true,
      },
      {
        name: "Full Service",
        description: "Komplett pakke som inkluderer hårklipp, skjeggtrim og styling. Vår premium-tjeneste.",
        price: 549.0,
        duration: 45,
        isActive: true,
      }
    ]) as ServiceWithId[];
    // Check if employee user already exists
    const existingEmployee = await userRepository.findOne({
      where: { email: employeeEmail },
    });
    if (!existingEmployee) {
      // Create employee user
      const hashedPassword = await bcrypt.hash(employeePassword, 10);
      const employeeUser = await userRepository.save({
        firstName: "John",
        lastName: "Doe",
        email: employeeEmail,
        password: hashedPassword,
        role: UserRole.EMPLOYEE,
        phoneNumber: process.env.EMPLOYEE_PHONE || "+1234567890",
      });
      // Create employee
      const employee = await employeeRepository.save({
        user: employeeUser,
        specializations: ["klipp", "styling", "skjegg"],
        availability: {
          monday: [{ start: "09:00", end: "17:00" }],
          tuesday: [{ start: "09:00", end: "17:00" }],
          wednesday: [{ start: "09:00", end: "17:00" }],
          thursday: [{ start: "09:00", end: "17:00" }],
          friday: [{ start: "09:00", end: "17:00" }],
        },
        isActive: true,
      }) as EmployeeWithId;
      // Type guard for service and employee IDs
      if (!employee.id || !services.every(service => service.id)) {
        throw new Error("Failed to create employee or services with valid IDs");
      }
      // Create associations with type safety
      const associations: EmployeeServiceAssociation[] = services.map((service) => ({
        employee_id: employee.id,
        service_id: service.id,
      }));
      // Associate services with employee
      await dataSource
        .createQueryBuilder()
        .insert()
        .into("employee_services")
        .values(associations)
        .execute();
      console.log("Initial data seeded successfully");
    } else {
      console.log("Employee user already exists");
    }
  } catch (error) {
    console.error("Error creating initial data:", error instanceof Error ? error.message : String(error));
    throw error;
  }
};
````

## File: backend/src/database/seeds/create-sample-bookings.seed.spec.ts
````typescript
import { DataSource, Repository, EntityTarget } from "typeorm";
import { User } from "../../users/entities/user.entity";
import { Employee } from "../../employees/entities/employee.entity";
import { Service } from "../../services/entities/service.entity";
import { Booking, BookingStatus } from "../../bookings/entities/booking.entity";
import { createSampleBookings } from "./create-sample-bookings.seed";
import * as bcrypt from "bcrypt";
import { faker } from "@faker-js/faker";
jest.mock("bcrypt");
jest.mock("@faker-js/faker", () => ({
  faker: {
    person: {
      firstName: jest.fn().mockReturnValue("John"),
      lastName: jest.fn().mockReturnValue("Doe"),
    },
    internet: {
      email: jest.fn().mockReturnValue("john.doe@example.com"),
    },
    string: {
      numeric: jest.fn().mockReturnValue("12345678"),
    },
    helpers: {
      arrayElement: jest.fn(),
      maybe: jest.fn(),
    },
    date: {
      between: jest.fn(),
    },
    lorem: {
      sentence: jest.fn().mockReturnValue("Sample note"),
    },
  },
}));
type SupportedEntity = User | Employee | Service | Booking;
interface RepositoryMapping {
  User: Repository<User>;
  Employee: Repository<Employee>;
  Service: Repository<Service>;
  Booking: Repository<Booking>;
}
interface MockCall<T> {
  calls: Array<[T]>;
}
describe("createSampleBookings", () => {
  let mockDataSource: Partial<DataSource>;
  let mockUserRepository: Partial<Repository<User>>;
  let mockEmployeeRepository: Partial<Repository<Employee>>;
  let mockServiceRepository: Partial<Repository<Service>>;
  let mockBookingRepository: Partial<Repository<Booking>>;
  const originalEnv = process.env;
  const originalRandom = Math.random;
  beforeEach(() => {
    mockUserRepository = {
      save: jest
        .fn()
        .mockImplementation(
          (data: Partial<User>): Promise<User> =>
            Promise.resolve({ id: "user-1", ...data } as User)
        ),
    };
    mockEmployeeRepository = {
      findOne: jest.fn().mockResolvedValue(null),
    };
    mockServiceRepository = {
      find: jest.fn().mockResolvedValue([]),
    };
    mockBookingRepository = {
      save: jest
        .fn()
        .mockImplementation(
          (
            bookings: Partial<Booking> | Partial<Booking>[]
          ): Promise<Booking | Booking[]> =>
            Promise.resolve(
              Array.isArray(bookings)
                ? bookings.map(
                    (b, i) => ({ id: `booking-${i}`, ...b }) as Booking
                  )
                : ({ id: "booking-1", ...bookings } as Booking)
            )
        ),
    };
    const repositories: RepositoryMapping = {
      User: mockUserRepository as Repository<User>,
      Employee: mockEmployeeRepository as Repository<Employee>,
      Service: mockServiceRepository as Repository<Service>,
      Booking: mockBookingRepository as Repository<Booking>,
    };
    const mockGetRepository = <T extends SupportedEntity>(
      entity: EntityTarget<T>
    ): Repository<T> => {
      const entityName = typeof entity === "function" ? entity.name : "Unknown";
      const repository = repositories[entityName as keyof RepositoryMapping];
      if (!repository) {
        throw new Error(`Repository not mocked for entity: ${entityName}`);
      }
      return repository as Repository<T>;
    };
    mockDataSource = {
      getRepository: jest.fn().mockImplementation(mockGetRepository),
    };
    (bcrypt.hash as jest.Mock).mockResolvedValue("hashed-password");
    process.env = {
      ...originalEnv,
      EMPLOYEE_EMAIL: "employee@example.com",
    };
    jest.spyOn(console, "log").mockImplementation(() => {});
    jest.spyOn(console, "error").mockImplementation(() => {});
    jest.clearAllMocks();
  });
  afterEach(() => {
    process.env = originalEnv;
    Math.random = originalRandom;
    jest.clearAllMocks();
  });
  it("should create sample customers and bookings when employee and services exist", async () => {
    const mockEmployee = {
      id: "employee-1",
      user: { email: "employee@example.com" },
    };
    (mockEmployeeRepository.findOne as jest.Mock).mockResolvedValue(
      mockEmployee
    );
    const mockServices = [
      { id: "service-1", name: "Haircut", duration: 30, price: 30 },
      { id: "service-2", name: "Styling", duration: 45, price: 40 },
    ];
    (mockServiceRepository.find as jest.Mock).mockResolvedValue(mockServices);
    const mockArrayElement = faker.helpers.arrayElement as jest.Mock;
    mockArrayElement
      .mockReturnValueOnce(mockServices[0])
      .mockReturnValue({ id: "customer-1" });
    const mockDate = new Date("2024-01-01T10:00:00Z");
    (faker.date.between as jest.Mock).mockReturnValue(mockDate);
    (faker.helpers.maybe as jest.Mock).mockImplementation(
      (callback: () => string) => callback()
    );
    await createSampleBookings(mockDataSource as DataSource);
    const saveBookingMock = mockBookingRepository.save as jest.Mock;
    const mockCalls = saveBookingMock.mock as MockCall<Booking[]>;
    if (!mockCalls.calls.length) {
      throw new Error("Expected at least one booking save call");
    }
    const savedBookings = mockCalls.calls[0][0];
    if (!Array.isArray(savedBookings)) {
      throw new Error("Expected an array of bookings");
    }
    expect(savedBookings).toHaveLength(20);
    expect(savedBookings[0]).toEqual(
      expect.objectContaining({
        employee: mockEmployee,
        service: mockServices[0],
        startTime: mockDate,
        endTime: expect.any(Date) as Date,
        notes: "Sample note",
      })
    );
    expect(console.log).toHaveBeenCalledWith(
      "Sample bookings created successfully"
    );
  });
  it("should throw error when employee is not found", async () => {
    (mockEmployeeRepository.findOne as jest.Mock).mockResolvedValue(null);
    await expect(
      createSampleBookings(mockDataSource as DataSource)
    ).rejects.toThrow(
      "Employee not found. Please run initial data seed first."
    );
    expect(mockBookingRepository.save).not.toHaveBeenCalled();
  });
  it("should throw error when customer creation fails", async () => {
    const mockEmployee = {
      id: "employee-1",
      user: { email: "employee@example.com" },
    };
    const mockServices = [{ id: "service-1", duration: 30, price: 30 }];
    (mockEmployeeRepository.findOne as jest.Mock).mockResolvedValue(
      mockEmployee
    );
    (mockServiceRepository.find as jest.Mock).mockResolvedValue(mockServices);
    (mockUserRepository.save as jest.Mock).mockRejectedValueOnce(
      new Error("Database error")
    );
    await expect(
      createSampleBookings(mockDataSource as DataSource)
    ).rejects.toThrow("Failed to create customer 1");
  });
  it("should throw error when service/customer selection fails", async () => {
    const mockEmployee = {
      id: "employee-1",
      user: { email: "employee@example.com" },
    };
    const mockServices = [{ id: "service-1", duration: 30, price: 30 }];
    (mockEmployeeRepository.findOne as jest.Mock).mockResolvedValue(
      mockEmployee
    );
    (mockServiceRepository.find as jest.Mock).mockResolvedValue(mockServices);
    (faker.helpers.arrayElement as jest.Mock).mockReturnValue(null);
    await expect(
      createSampleBookings(mockDataSource as DataSource)
    ).rejects.toThrow("Failed to select service or customer for booking 1");
  });
  it("should throw error when saving bookings fails", async () => {
    const mockEmployee = {
      id: "employee-1",
      user: { email: "employee@example.com" },
    };
    const mockServices = [{ id: "service-1", duration: 30, price: 30 }];
    const mockCustomer = { id: "customer-1" };
    (mockEmployeeRepository.findOne as jest.Mock).mockResolvedValue(
      mockEmployee
    );
    (mockServiceRepository.find as jest.Mock).mockResolvedValue(mockServices);
    (faker.helpers.arrayElement as jest.Mock)
      .mockReturnValueOnce(mockServices[0]) // First call for service
      .mockReturnValue(mockCustomer); // Subsequent calls for customer
    (mockBookingRepository.save as jest.Mock).mockResolvedValue(null);
    await expect(
      createSampleBookings(mockDataSource as DataSource)
    ).rejects.toThrow(
      "Failed to save bookings - no bookings returned from save operation"
    );
  });
  it("should throw error when status weight determination fails", async () => {
    const mockEmployee = {
      id: "employee-1",
      user: { email: "employee@example.com" },
    };
    const mockServices = [{ id: "service-1", duration: 30, price: 30 }];
    const mockCustomer = { id: "customer-1" };
    (mockEmployeeRepository.findOne as jest.Mock).mockResolvedValue(
      mockEmployee
    );
    (mockServiceRepository.find as jest.Mock).mockResolvedValue(mockServices);
    (faker.helpers.arrayElement as jest.Mock)
      .mockReturnValueOnce(mockServices[0]) // First call for service
      .mockReturnValue(mockCustomer); // Subsequent calls for customer
    // Set Math.random to return a value greater than all weights
    Math.random = jest.fn().mockReturnValue(2.0);
    await expect(
      createSampleBookings(mockDataSource as DataSource)
    ).rejects.toThrow("Failed to determine status for booking 1");
  });
  it("should create bookings with cancelled status and cancellation details", async () => {
    const mockEmployee = {
      id: "employee-1",
      user: { email: "employee@example.com" },
    };
    const mockServices = [{ id: "service-1", duration: 30, price: 30 }];
    (mockEmployeeRepository.findOne as jest.Mock).mockResolvedValue(
      mockEmployee
    );
    (mockServiceRepository.find as jest.Mock).mockResolvedValue(mockServices);
    const mockArrayElement = faker.helpers.arrayElement as jest.Mock;
    mockArrayElement
      .mockReturnValueOnce(mockServices[0])
      .mockReturnValue({ id: "customer-1" });
    Math.random = jest.fn().mockReturnValue(0.95);
    const mockStartDate = new Date("2024-01-01T10:00:00Z");
    const mockCancelDate = new Date("2024-01-01T09:00:00Z");
    const mockDateBetween = faker.date.between as jest.Mock;
    mockDateBetween
      .mockReturnValueOnce(mockStartDate)
      .mockReturnValue(mockCancelDate);
    await createSampleBookings(mockDataSource as DataSource);
    const saveBookingMock = mockBookingRepository.save as jest.Mock;
    const mockCalls = saveBookingMock.mock as MockCall<Booking[]>;
    if (!mockCalls.calls.length) {
      throw new Error("Expected at least one booking save call");
    }
    const savedBookings = mockCalls.calls[0][0];
    if (!Array.isArray(savedBookings)) {
      throw new Error("Expected an array of bookings");
    }
    const cancelledBooking = savedBookings.find(
      (b) => b.status === BookingStatus.CANCELLED
    );
    expect(cancelledBooking).toBeDefined();
    if (cancelledBooking) {
      expect(cancelledBooking).toEqual(
        expect.objectContaining({
          status: BookingStatus.CANCELLED,
          cancelledAt: mockCancelDate,
          cancellationReason: "Sample note",
        })
      );
    }
  });
});
````

## File: backend/src/database/seeds/create-sample-bookings.seed.ts
````typescript
import { DataSource, Repository } from "typeorm";
import { User, UserRole } from "../../users/entities/user.entity";
import { Employee } from "../../employees/entities/employee.entity";
import { Service } from "../../services/entities/service.entity";
import { Booking, BookingStatus } from "../../bookings/entities/booking.entity";
import * as bcrypt from "bcrypt";
import { faker } from '@faker-js/faker';
export const createSampleBookings = async (dataSource: DataSource): Promise<{
  total: number;
  confirmed: number;
  pending: number;
  cancelled: number;
}> => {
  // Initialize repositories with proper typing
  const userRepository: Repository<User> = dataSource.getRepository(User);
  const employeeRepository: Repository<Employee> = dataSource.getRepository(Employee);
  const serviceRepository: Repository<Service> = dataSource.getRepository(Service);
  const bookingRepository: Repository<Booking> = dataSource.getRepository(Booking);
  try {
    console.log('Starting to create sample bookings...');
    // Get the employee with proper type assertion
    const employee = await employeeRepository.findOne({
      relations: ['user'],
      where: { user: { email: process.env.EMPLOYEE_EMAIL } }
    });
    if (!employee) {
      throw new Error("Employee not found. Please run initial data seed first.");
    }
    // Get all services with proper type assertion
    const services = await serviceRepository.find();
    if (!services || services.length === 0) {
      throw new Error("No services found. Please run initial data seed first.");
    }
    // Create 10 sample customers
    console.log('Creating sample customers...');
    const customers: User[] = [];
    for (let i = 0; i < 10; i++) {
      const firstName = faker.person.firstName();
      const lastName = faker.person.lastName();
      try {
        const hashedPassword = await bcrypt.hash('password123', 10);
        const customer = await userRepository.save({
          firstName,
          lastName,
          email: faker.internet.email({ firstName, lastName }),
          password: hashedPassword,
          role: UserRole.CUSTOMER,
          phoneNumber: '+47' + faker.string.numeric(8),
        });
        customers.push(customer);
      } catch (error) {
        const err = new Error(`Failed to create customer ${i + 1}`);
        console.error(`Error creating customer ${i + 1}:`, error);
        throw err;
      }
    }
    console.log(`Created ${customers.length} sample customers`);
    const now = new Date();
    // Weighted status distribution to ensure more confirmed bookings
    const statusWeights = [
      { status: BookingStatus.CONFIRMED, weight: 0.7 },  // 70% confirmed
      { status: BookingStatus.PENDING, weight: 0.2 },    // 20% pending
      { status: BookingStatus.CANCELLED, weight: 0.1 },  // 10% cancelled
    ];
    // Create 20 sample bookings
    console.log('Creating sample bookings...');
    const bookings: Partial<Booking>[] = [];
    for (let i = 0; i < 20; i++) {
      const service = faker.helpers.arrayElement(services);
      const customer = faker.helpers.arrayElement(customers);
      if (!service || !customer) {
        const err = new Error(`Failed to select service or customer for booking ${i + 1}`);
        throw err;
      }
      // Use weighted random status
      const randomWeight = Math.random();
      let cumulativeWeight = 0;
      const statusWeight = statusWeights.find(sw => {
        cumulativeWeight += sw.weight;
        return randomWeight <= cumulativeWeight;
      });
      if (!statusWeight) {
        const err = new Error(`Failed to determine status for booking ${i + 1}`);
        throw err;
      }
      const status = statusWeight.status;
      // Generate dates across a wider range (-30 to +30 days)
      const startTime = faker.date.between({
        from: new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000),
        to: new Date(now.getTime() + 30 * 24 * 60 * 60 * 1000)
      });
      // Ensure service.duration is a number
      const duration = typeof service.duration === 'number' ? service.duration : 60;
      const endTime = new Date(startTime.getTime() + duration * 60 * 1000);
      const booking: Partial<Booking> = {
        customer,
        employee,
        service,
        startTime,
        endTime,
        status,
        notes: faker.helpers.maybe(() => faker.lorem.sentence(), { probability: 0.7 }),
        totalPrice: service.price,
        reminderSent: startTime < now,
      };
      // Add cancellation details if status is cancelled
      if (status === BookingStatus.CANCELLED) {
        const [fromDate, toDate] = startTime < now 
          ? [startTime, now]
          : [now, startTime];
        booking.cancelledAt = faker.date.between({
          from: fromDate,
          to: toDate
        });
        booking.cancellationReason = faker.lorem.sentence();
      }
      bookings.push(booking);
    }
    console.log('Saving bookings to database...');
    const savedBookings = await bookingRepository.save(bookings);
    if (!savedBookings || !Array.isArray(savedBookings)) {
      const err = new Error('Failed to save bookings - no bookings returned from save operation');
      throw err;
    }
    const statusDistribution = {
      total: savedBookings.length,
      confirmed: savedBookings.filter(b => b.status === BookingStatus.CONFIRMED).length,
      pending: savedBookings.filter(b => b.status === BookingStatus.PENDING).length,
      cancelled: savedBookings.filter(b => b.status === BookingStatus.CANCELLED).length,
    };
    console.log("Sample bookings created successfully");
    console.log("Status distribution:", statusDistribution);
    return statusDistribution;
  } catch (error) {
    console.error("Error creating sample bookings:", error);
    throw error;
  }
};
````

## File: backend/src/database/seeds/create-sample-orders.seed.spec.ts
````typescript
import { DataSource, Repository } from 'typeorm';
import { createSampleOrders } from './create-sample-orders.seed';
import { Order } from '../../orders/entities/order.entity';
import { Booking, BookingStatus } from '../../bookings/entities/booking.entity';
describe('createSampleOrders', () => {
  let mockDataSource: DataSource;
  let mockBookingRepository: Partial<Repository<Booking>>;
  let mockOrderRepository: Partial<Repository<Order>>;
  interface MockBooking {
    id: string;
    totalPrice: number;
    status: BookingStatus;
    customer: { id: string };
    employee: { id: string };
    service: { id: string };
  }
  interface MockOrder {
    id: string;
    booking: MockBooking;
    totalAmount: number;
  }
  interface TestFixture {
    bookings: MockBooking[];
    order: MockOrder;
    setupMocks: () => void;
  }
  const createMockBooking = (id: string, totalPrice = 100): MockBooking => ({
    id: `booking${id}`,
    totalPrice,
    status: BookingStatus.CONFIRMED,
    customer: { id: `cust${id}` },
    employee: { id: `emp${id}` },
    service: { id: `service${id}` },
  });
  const createMockOrder = (booking: MockBooking): MockOrder => ({
    id: 'order1',
    booking,
    totalAmount: booking.totalPrice,
  });
  const createTestFixture = (bookings: MockBooking[]): TestFixture => {
    const order = createMockOrder(bookings[0]);
    return {
      bookings,
      order,
      setupMocks: () => {
        mockBookingRepository.find = jest.fn().mockResolvedValue(bookings);
        mockOrderRepository.create = jest.fn().mockReturnValue(order);
        mockOrderRepository.save = jest.fn().mockResolvedValue(order);
        mockBookingRepository.save = jest.fn().mockImplementation((booking) => Promise.resolve({
          ...booking,
          status: BookingStatus.COMPLETED,
        }));
      },
    };
  };
  const expectOrderCreationSuccess = () => {
    expect(mockBookingRepository.find).toHaveBeenCalledWith({
      where: { status: BookingStatus.CONFIRMED },
      relations: ['customer', 'employee', 'service'],
    });
    expect(mockOrderRepository.create).toHaveBeenCalled();
    expect(mockOrderRepository.save).toHaveBeenCalled();
    expect(mockBookingRepository.save).toHaveBeenCalled();
  };
  beforeEach(() => {
    mockBookingRepository = {
      find: jest.fn(),
      save: jest.fn(),
    };
    mockOrderRepository = {
      create: jest.fn(),
      save: jest.fn(),
    };
    mockDataSource = {
      getRepository: jest.fn((entity: new () => Booking | Order) => {
        if (entity === Booking) return mockBookingRepository as Repository<Booking>;
        if (entity === Order) return mockOrderRepository as Repository<Order>;
        throw new Error(`Unexpected entity: ${entity.name}`);
      }),
    } as unknown as DataSource;
  });
  it('should create orders for confirmed bookings successfully', async () => {
    const fixture = createTestFixture([
      createMockBooking('1'),
      createMockBooking('2', 150),
    ]);
    fixture.setupMocks();
    await createSampleOrders(mockDataSource);
    expectOrderCreationSuccess();
  });
  describe('error handling', () => {
    const setupErrorTest = async (setupFn: () => void) => {
      setupFn();
      return createSampleOrders(mockDataSource);
    };
    it('should handle case when no confirmed bookings exist', async () => {
      await expect(setupErrorTest(() => {
        mockBookingRepository.find = jest.fn().mockResolvedValue([]);
      })).rejects.toThrow('No orders were created successfully');
    });
    it('should handle invalid booking data', async () => {
      const invalidBooking = {
        id: 'booking1',
        status: BookingStatus.CONFIRMED,
        customer: { id: 'cust1' },
        employee: { id: 'emp1' },
        service: { id: 'service1' },
      };
      await expect(setupErrorTest(() => {
        mockBookingRepository.find = jest.fn().mockResolvedValue([invalidBooking]);
      })).rejects.toThrow('No orders were created successfully');
    });
    it('should handle database error when fetching bookings', async () => {
      await expect(setupErrorTest(() => {
        mockBookingRepository.find = jest.fn().mockRejectedValue(new Error('Database error'));
      })).rejects.toThrow('Database error');
    });
    it('should handle non-array response from booking repository', async () => {
      await expect(setupErrorTest(() => {
        mockBookingRepository.find = jest.fn().mockResolvedValue(null);
      })).rejects.toThrow('Failed to fetch confirmed bookings');
    });
    it('should handle order creation failure', async () => {
      await expect(setupErrorTest(() => {
        const fixture = createTestFixture([createMockBooking('1')]);
        fixture.setupMocks();
        mockOrderRepository.create = jest.fn().mockReturnValue(null);
      })).rejects.toThrow('No orders were created successfully');
    });
    it('should handle order save failure', async () => {
      await expect(setupErrorTest(() => {
        const fixture = createTestFixture([createMockBooking('1')]);
        fixture.setupMocks();
        mockOrderRepository.save = jest.fn().mockResolvedValue(null);
      })).rejects.toThrow('No orders were created successfully');
    });
  });
  describe('booking status updates', () => {
    it('should handle booking status update failure but continue processing', async () => {
      const fixture = createTestFixture([createMockBooking('1')]);
      fixture.setupMocks();
      mockBookingRepository.save = jest.fn().mockRejectedValue(new Error('Failed to update status'));
      await createSampleOrders(mockDataSource);
      expect(mockBookingRepository.save).toHaveBeenCalledWith(expect.objectContaining({
        id: 'booking1',
        status: BookingStatus.COMPLETED,
      }));
    });
    it('should handle booking save returning undefined and continue processing', async () => {
      const fixture = createTestFixture([createMockBooking('1')]);
      fixture.setupMocks();
      mockBookingRepository.save = jest.fn().mockResolvedValue(undefined);
      await createSampleOrders(mockDataSource);
      expect(mockBookingRepository.save).toHaveBeenCalledWith(expect.objectContaining({
        id: 'booking1',
        status: BookingStatus.COMPLETED,
      }));
      expect(mockOrderRepository.create).toHaveBeenCalled();
      expect(mockOrderRepository.save).toHaveBeenCalled();
    });
  });
  it('should limit number of orders to 20', async () => {
    const mockBookings = Array(25).fill(null).map((_, index) => createMockBooking((index + 1).toString()));
    const fixture = createTestFixture(mockBookings);
    fixture.setupMocks();
    await createSampleOrders(mockDataSource);
    expect(mockOrderRepository.create).toHaveBeenCalledTimes(20);
  });
});
````

## File: backend/src/database/seeds/create-sample-orders.seed.ts
````typescript
import { DataSource, Repository } from "typeorm";
import { Order } from "../../orders/entities/order.entity";
import { Booking, BookingStatus } from "../../bookings/entities/booking.entity";
export const createSampleOrders = async (dataSource: DataSource): Promise<void> => {
  // Initialize repositories with proper typing
  const bookingRepository: Repository<Booking> = dataSource.getRepository(Booking);
  const orderRepository: Repository<Order> = dataSource.getRepository(Order);
  try {
    console.log('Starting to create sample orders...');
    // Get all confirmed bookings that don't have orders yet
    const confirmedBookings = await bookingRepository.find({
      where: { status: BookingStatus.CONFIRMED },
      relations: ["customer", "employee", "service"],
    });
    if (!confirmedBookings || !Array.isArray(confirmedBookings)) {
      throw new Error('Failed to fetch confirmed bookings');
    }
    console.log(`Found ${confirmedBookings.length} confirmed bookings`);
    // Take first 20 confirmed bookings (or less if fewer exist)
    const numberOfOrders = Math.min(20, confirmedBookings.length);
    const selectedBookings = confirmedBookings.slice(0, numberOfOrders);
    console.log(`Creating ${numberOfOrders} orders...`);
    const createdOrders: Order[] = [];
    for (const booking of selectedBookings) {
      // Verify booking has required properties
      if (!booking.id || !booking.totalPrice) {
        console.error(`Invalid booking data: ${JSON.stringify(booking)}`);
        continue;
      }
      try {
        // Create order with proper type
        const order = orderRepository.create({
          booking: booking,
          completedAt: new Date(),
          totalAmount: booking.totalPrice,
          notes: `Order created for booking ${booking.id}`,
        });
        if (!order) {
          throw new Error(`Failed to create order for booking ${booking.id}`);
        }
        // Save order with proper error handling
        const savedOrder = await orderRepository.save(order);
        if (!savedOrder) {
          throw new Error(`Failed to save order for booking ${booking.id}`);
        }
        createdOrders.push(savedOrder);
        // Update booking status to completed
        booking.status = BookingStatus.COMPLETED;
        const updatedBooking = await bookingRepository.save(booking);
        if (!updatedBooking) {
          throw new Error(`Failed to update status for booking ${booking.id}`);
        }
        console.log(`Created order ${savedOrder.id} for booking ${booking.id}`);
      } catch (error) {
        // Log error but continue processing other bookings
        console.error(`Error processing booking ${booking.id}:`, error instanceof Error ? error.message : String(error));
        continue;
      }
    }
    if (createdOrders.length === 0) {
      throw new Error('No orders were created successfully');
    }
    console.log(`Successfully created ${createdOrders.length} sample orders`);
  } catch (error) {
    console.error("Error creating sample orders:", error);
    throw error;
  }
};
````

## File: backend/src/database/seeds/create-services.seed.spec.ts
````typescript
import { DataSource } from 'typeorm';
import { CreateServicesSeed } from './create-services.seed';
import { Service } from '../../services/entities/service.entity';
interface MockServiceRepository {
  clear: jest.Mock<Promise<void>, []>;
  save: jest.Mock<Promise<Service[]>, [Service[]]>;
}
type ServiceData = Pick<Service, 'name' | 'description' | 'duration' | 'price' | 'isActive'>;
const expectedServices: ServiceData[] = [
  {
    name: 'Standard Klipp',
    description: 'En standard og effektiv hårklipp for deg som har det travelt. Perfekt for å vedlikeholde din nåværende stil.',
    duration: 20,
    price: 299,
    isActive: true,
  },
  {
    name: 'Styling Klipp',
    description: 'Komplett hårklipp og styling-service. Inkluderer konsultasjon for å finne det perfekte utseendet.',
    duration: 30,
    price: 399,
    isActive: true,
  },
  {
    name: 'Skjegg Trim',
    description: 'Profesjonell skjeggtrimming og forming for å holde skjegget ditt velstelt.',
    duration: 15,
    price: 199,
    isActive: true,
  },
  {
    name: 'Full Service',
    description: 'Komplett pakke som inkluderer hårklipp, skjeggtrim og styling. Vår premium-tjeneste.',
    duration: 45,
    price: 549,
    isActive: true,
  }
];
describe('CreateServicesSeed', () => {
  let seed: CreateServicesSeed;
  let mockDataSource: Partial<DataSource>;
  let mockServiceRepository: MockServiceRepository;
  beforeEach(() => {
    mockServiceRepository = {
      clear: jest.fn<Promise<void>, []>().mockResolvedValue(undefined),
      save: jest.fn<Promise<Service[]>, [Service[]]>().mockImplementation((services: Service[]): Promise<Service[]> => {
        return Promise.resolve(
          services.map(service => ({
            ...service,
            id: 'test-id',
            createdAt: new Date(),
            updatedAt: new Date(),
          }))
        );
      }),
    };
    mockDataSource = {
      getRepository: jest.fn().mockReturnValue(mockServiceRepository),
    };
    seed = new CreateServicesSeed();
  });
  it('should clear existing services and create new ones', async () => {
    await seed.run(mockDataSource as DataSource);
    expect(mockServiceRepository.clear).toHaveBeenCalled();
    const savedServices = mockServiceRepository.save.mock.calls[0][0];
    expectedServices.forEach((expectedService, index) => {
      expect(savedServices[index]).toEqual(
        expect.objectContaining(expectedService)
      );
    });
  });
  it('should handle database errors gracefully', async () => {
    const dbError = new Error('Database connection error');
    mockServiceRepository.clear.mockRejectedValue(dbError);
    await expect(seed.run(mockDataSource as DataSource)).rejects.toThrow('Database connection error');
  });
});
````

## File: backend/src/database/seeds/create-services.seed.ts
````typescript
import { DataSource } from 'typeorm';
import { Seeder } from './seeder.interface';
import { Service } from '../../services/entities/service.entity';
export class CreateServicesSeed implements Seeder {
  async run(dataSource: DataSource): Promise<void> {
    const serviceRepository = dataSource.getRepository(Service);
    // First, clear any existing services to prevent duplicates
    await serviceRepository.clear();
    const services = [
      {
        name: 'Standard Klipp',
        description: 'En standard og effektiv hårklipp for deg som har det travelt. Perfekt for å vedlikeholde din nåværende stil.',
        duration: 20,
        price: 299,
        isActive: true,
      },
      {
        name: 'Styling Klipp',
        description: 'Komplett hårklipp og styling-service. Inkluderer konsultasjon for å finne det perfekte utseendet.',
        duration: 30,
        price: 399,
        isActive: true,
      },
      {
        name: 'Skjegg Trim',
        description: 'Profesjonell skjeggtrimming og forming for å holde skjegget ditt velstelt.',
        duration: 15,
        price: 199,
        isActive: true,
      },
      {
        name: 'Full Service',
        description: 'Komplett pakke som inkluderer hårklipp, skjeggtrim og styling. Vår premium-tjeneste.',
        duration: 45,
        price: 549,
        isActive: true,
      }
    ];
    // Save all services at once
    await serviceRepository.save(services);
  }
}
````

## File: backend/src/database/seeds/run-seeds.spec.ts
````typescript
import { DataSource } from "typeorm";
import { PostgresConnectionOptions } from "typeorm/driver/postgres/PostgresConnectionOptions";
import { createDataSource, runSeeds } from "./run-seeds";
import { createAdminUser } from "./create-admin-user.seed";
import { createInitialData } from "./create-initial-data.seed";
import { createSampleBookings } from "./create-sample-bookings.seed";
import { createSampleOrders } from "./create-sample-orders.seed";
import { DataSource as TypeORMDataSource } from "typeorm";
jest.mock("typeorm", () => {
  const actualModule = jest.requireActual<typeof import("typeorm")>("typeorm");
  class MockDataSource extends actualModule.DataSource {
    constructor(options: PostgresConnectionOptions) {
      if (options.url === "invalid-url") {
        throw new Error("Invalid URL format");
      }
      super(options);
    }
  }
  const mockedModule = {
    ...actualModule,
    DataSource: jest
      .fn()
      .mockImplementation(
        (options: PostgresConnectionOptions): TypeORMDataSource =>
          new MockDataSource(options)
      ),
  };
  return mockedModule;
});
// Mock the seed functions
jest.mock("./create-admin-user.seed");
jest.mock("./create-initial-data.seed");
jest.mock("./create-sample-bookings.seed");
jest.mock("./create-sample-orders.seed");
describe("run-seeds", () => {
  // Create a minimal mock of DataSource with required properties
  const createMockDataSource = () =>
    ({
      name: "default",
      options: {} as PostgresConnectionOptions,
      isInitialized: false,
      initialize: jest.fn().mockResolvedValue(undefined),
      destroy: jest.fn().mockResolvedValue(undefined),
      isConnected: false,
      close: jest.fn().mockResolvedValue(undefined),
      connect: jest.fn().mockResolvedValue(undefined),
      createEntityManager: jest.fn(),
      createQueryRunner: jest.fn(),
      getMetadata: jest.fn(),
      hasMetadata: jest.fn(),
      getRepository: jest.fn(),
      getTreeRepository: jest.fn(),
      getMongoRepository: jest.fn(),
      transaction: jest.fn(),
      driver: {},
      manager: {},
      mongoManager: undefined,
      sqljsManager: undefined,
      namingStrategy: {},
      entityMetadatas: [],
      subscribers: [],
      migrations: [],
      logger: console,
      metadataTableName: "typeorm_metadata",
      queryResultCache: null,
      relationLoader: {},
      relationIdLoader: {},
    }) as unknown as DataSource;
  const mockDataSource = createMockDataSource();
  const originalEnv = process.env;
  beforeEach(() => {
    jest.resetModules();
    jest.clearAllMocks();
    process.env = { ...originalEnv };
    console.log = jest.fn();
    console.error = jest.fn();
  });
  afterAll(() => {
    process.env = originalEnv;
  });
  describe("createDataSource", () => {
    it("should create a DataSource when DATABASE_URL is set", () => {
      process.env.DATABASE_URL = "postgresql://user:pass@localhost:5432/db";
      const dataSource = createDataSource();
      expect(dataSource).toBeDefined();
      expect((dataSource.options as PostgresConnectionOptions).url).toBe(
        process.env.DATABASE_URL
      );
    });
    it("should throw error when DATABASE_URL is not set", () => {
      delete process.env.DATABASE_URL;
      expect(() => createDataSource()).toThrow(
        "DATABASE_URL environment variable is not set"
      );
    });
    it("should handle DataSource creation errors", () => {
      process.env.DATABASE_URL = "invalid-url";
      expect(() => createDataSource()).toThrow(
        "Failed to create DataSource: Invalid URL format"
      );
    });
  });
  describe("runSeeds", () => {
    it("should run all seeds successfully", async () => {
      (createAdminUser as jest.Mock).mockResolvedValue(undefined);
      (createInitialData as jest.Mock).mockResolvedValue(undefined);
      (createSampleBookings as jest.Mock).mockResolvedValue(undefined);
      (createSampleOrders as jest.Mock).mockResolvedValue(undefined);
      const result = await runSeeds(mockDataSource);
      expect(createAdminUser).toHaveBeenCalledWith(mockDataSource);
      expect(createInitialData).toHaveBeenCalledWith(mockDataSource);
      expect(createSampleBookings).toHaveBeenCalledWith(mockDataSource);
      expect(createSampleOrders).toHaveBeenCalledWith(mockDataSource);
      expect(result).toBe(true);
    });
    it("should throw error for invalid DataSource", async () => {
      const invalidDataSource = undefined as unknown as DataSource;
      await expect(runSeeds(invalidDataSource)).rejects.toThrow(
        "Invalid DataSource provided"
      );
    });
    it("should handle initialization error", async () => {
      const errorDataSource = createMockDataSource();
      errorDataSource.initialize = jest
        .fn()
        .mockRejectedValue(new Error("Init failed"));
      await expect(runSeeds(errorDataSource)).rejects.toThrow(
        "Seed operation failed: Init failed"
      );
    });
    it("should handle seed operation errors", async () => {
      const mockError = new Error("Seed operation failed");
      (createAdminUser as jest.Mock).mockRejectedValue(mockError);
      await expect(runSeeds(mockDataSource)).rejects.toThrow(
        "Seed operation failed: Seed operation failed"
      );
    });
    it("should handle non-Error objects in catch blocks", async () => {
      // Mock createInitialData to reject with a string
      (createInitialData as jest.Mock).mockRejectedValue("String error");
      // Reset other mocks to resolve successfully
      (createAdminUser as jest.Mock).mockResolvedValue(undefined);
      (createSampleBookings as jest.Mock).mockResolvedValue(undefined);
      (createSampleOrders as jest.Mock).mockResolvedValue(undefined);
      await expect(runSeeds(mockDataSource)).rejects.toThrow(
        "Seed operation failed: String error"
      );
    });
  });
});
````

## File: backend/src/database/seeds/run-seeds.ts
````typescript
import { DataSource, DataSourceOptions } from "typeorm";
import { config } from 'dotenv';
import { createAdminUser } from "./create-admin-user.seed";
import { createInitialData } from "./create-initial-data.seed";
import { createSampleBookings } from "./create-sample-bookings.seed";
import { createSampleOrders } from "./create-sample-orders.seed";
// Load environment variables
config();
export const createDataSource = (): DataSource => {
  const options: DataSourceOptions = {
    type: 'postgres',
    url: process.env.DATABASE_URL,
    entities: ['src/**/*.entity{.ts,.js}'],
    synchronize: false,
    ssl: {
      rejectUnauthorized: false
    }
  };
  if (!options.url) {
    throw new Error('DATABASE_URL environment variable is not set');
  }
  try {
    return new DataSource(options);
  } catch (error) {
    throw new Error(`Failed to create DataSource: ${error instanceof Error ? error.message : String(error)}`);
  }
};
export const runSeeds = async (dataSource: DataSource): Promise<boolean> => {
  if (!dataSource || typeof dataSource.initialize !== 'function') {
    throw new Error('Invalid DataSource provided');
  }
  try {
    await dataSource.initialize();
    console.log('Connected to database');
    // Create admin user first
    console.log('Creating admin user...');
    await createAdminUser(dataSource);
    // Create initial data (services, employees)
    console.log('Creating initial data...');
    await createInitialData(dataSource);
    // Create sample bookings
    console.log('Creating sample bookings...');
    await createSampleBookings(dataSource);
    // Create sample orders from confirmed bookings
    console.log('Creating sample orders...');
    await createSampleOrders(dataSource);
    console.log('All seeds completed successfully');
    return true;
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    console.error('Error running seeds:', errorMessage);
    throw new Error(`Seed operation failed: ${errorMessage}`);
  }
};
// Only run seeds if this file is being run directly
if (require.main === module) {
  let dataSource: DataSource | undefined;
  try {
    dataSource = createDataSource();
    runSeeds(dataSource)
      .then(async () => {
        if (dataSource && typeof dataSource.destroy === 'function') {
          await dataSource.destroy();
        }
        process.exit(0);
      })
      .catch((error) => {
        console.error('Seed process failed:', error instanceof Error ? error.message : String(error));
        process.exit(1);
      });
  } catch (error) {
    console.error('Failed to create DataSource:', error instanceof Error ? error.message : String(error));
    process.exit(1);
  }
}
````

## File: backend/src/database/seeds/seeder.interface.ts
````typescript
import { DataSource } from "typeorm";
export interface Seeder {
  run(dataSource: DataSource): Promise<void>;
}
````

## File: backend/src/database/seeds/update-admin-password.seed.spec.ts
````typescript
import { DataSource, Repository } from 'typeorm';
import { updateAdminPassword } from './update-admin-password.seed';
import * as fs from 'fs';
import * as dotenv from 'dotenv';
import * as path from 'path';
// Mock User entity
const mockUserEntity = {
  id: 'user-1',
  email: 'admin@example.com',
  password: 'old-password',
  validatePassword: jest.fn().mockResolvedValue(true),
};
jest.mock('../../users/entities/user.entity', () => ({
  User: jest.fn(),
}));
jest.mock('fs');
jest.mock('dotenv');
jest.mock('path');
describe('updateAdminPassword', () => {
  let mockDataSource: Partial<DataSource>;
  let mockUserRepository: Partial<Repository<typeof mockUserEntity>>;
  beforeEach(() => {
    // Mock repository
    mockUserRepository = {
      findOne: jest.fn(),
      save: jest.fn(),
    };
    // Mock DataSource
    mockDataSource = {
      getRepository: jest.fn().mockReturnValue(mockUserRepository),
    };
    // Mock path.resolve
    (path.resolve as jest.Mock).mockReturnValue('/fake/path/.env');
    // Mock fs.readFileSync
    (fs.readFileSync as jest.Mock).mockReturnValue('mock env file content');
    // Mock dotenv.parse
    (dotenv.parse as jest.Mock).mockReturnValue({
      ADMIN_EMAIL: 'admin@example.com',
      ADMIN_PASSWORD: 'new-password',
    });
    // Mock console methods
    jest.spyOn(console, 'log').mockImplementation(() => {});
    jest.spyOn(console, 'error').mockImplementation(() => {});
  });
  afterEach(() => {
    jest.clearAllMocks();
  });
  it('should successfully update admin password', async () => {
    // Mock finding the admin user
    (mockUserRepository.findOne as jest.Mock)
      .mockResolvedValueOnce({ ...mockUserEntity })  // First call - finding user
      .mockResolvedValueOnce({ ...mockUserEntity, password: 'new-password' });  // Second call - verification
    await updateAdminPassword(mockDataSource as DataSource);
    // Verify env file was read
    expect(fs.readFileSync).toHaveBeenCalledWith('/fake/path/.env');
    expect(dotenv.parse).toHaveBeenCalledWith('mock env file content');
    // Verify user was found and updated
    expect(mockUserRepository.findOne).toHaveBeenCalledWith({
      where: { email: 'admin@example.com' },
    });
    expect(mockUserRepository.save).toHaveBeenCalledWith(
      expect.objectContaining({
        email: 'admin@example.com',
        password: 'new-password',
      }),
    );
    // Verify password was validated
    expect(mockUserEntity.validatePassword).toHaveBeenCalledWith('new-password');
  });
  it('should throw error when admin user is not found', async () => {
    (mockUserRepository.findOne as jest.Mock).mockResolvedValue(null);
    await expect(updateAdminPassword(mockDataSource as DataSource)).rejects.toThrow(
      'Admin user not found',
    );
    expect(mockUserRepository.save).not.toHaveBeenCalled();
  });
  it('should throw error when env file cannot be read', async () => {
    const fsError = new Error('Cannot read env file');
    (fs.readFileSync as jest.Mock).mockImplementation(() => {
      throw fsError;
    });
    await expect(updateAdminPassword(mockDataSource as DataSource)).rejects.toThrow(fsError);
    expect(mockUserRepository.findOne).not.toHaveBeenCalled();
    expect(mockUserRepository.save).not.toHaveBeenCalled();
  });
  it('should throw error when admin email is missing from env', async () => {
    (dotenv.parse as jest.Mock).mockReturnValue({
      ADMIN_PASSWORD: 'new-password',
    });
    await expect(updateAdminPassword(mockDataSource as DataSource)).rejects.toThrow(
      'Admin email and password must be set in environment variables',
    );
    expect(mockUserRepository.findOne).not.toHaveBeenCalled();
    expect(mockUserRepository.save).not.toHaveBeenCalled();
  });
  it('should throw error when admin password is missing from env', async () => {
    (dotenv.parse as jest.Mock).mockReturnValue({
      ADMIN_EMAIL: 'admin@example.com',
    });
    await expect(updateAdminPassword(mockDataSource as DataSource)).rejects.toThrow(
      'Admin email and password must be set in environment variables',
    );
    expect(mockUserRepository.findOne).not.toHaveBeenCalled();
    expect(mockUserRepository.save).not.toHaveBeenCalled();
  });
  it('should throw error when password update cannot be verified', async () => {
    // Mock finding the admin user for update
    (mockUserRepository.findOne as jest.Mock)
      .mockResolvedValueOnce({ ...mockUserEntity })  // First call - finding user
      .mockResolvedValueOnce(null);     // Second call - verification fails
    await expect(updateAdminPassword(mockDataSource as DataSource)).rejects.toThrow(
      'Could not verify password update',
    );
  });
  it('should handle database errors during save', async () => {
    // Mock finding the admin user
    (mockUserRepository.findOne as jest.Mock).mockResolvedValue({ ...mockUserEntity });
    // Mock save error
    const dbError = new Error('Database error during save');
    (mockUserRepository.save as jest.Mock).mockRejectedValue(dbError);
    await expect(updateAdminPassword(mockDataSource as DataSource)).rejects.toThrow(dbError);
    expect(console.error).toHaveBeenCalledWith('Error updating admin password:', dbError);
  });
  it('should log password analysis information', async () => {
    // Mock finding the admin user
    (mockUserRepository.findOne as jest.Mock)
      .mockResolvedValueOnce({ ...mockUserEntity })
      .mockResolvedValueOnce({ ...mockUserEntity, password: 'new-password' });
    await updateAdminPassword(mockDataSource as DataSource);
    // Verify password analysis was logged
    expect(console.log).toHaveBeenCalledWith(expect.stringContaining('Password analysis before update'));
    expect(console.log).toHaveBeenCalledWith(expect.stringContaining('Raw password'), 'new-password');
    expect(console.log).toHaveBeenCalledWith(expect.stringContaining('Length'), expect.any(Number));
    expect(console.log).toHaveBeenCalledWith('Admin password updated in database');
    expect(console.log).toHaveBeenCalledWith('Password verification after update:', true);
  });
});
````

## File: backend/src/database/seeds/update-admin-password.seed.ts
````typescript
import { DataSource } from "typeorm";
import { User } from "../../users/entities/user.entity";
import * as fs from 'fs';
import * as dotenv from 'dotenv';
import * as path from 'path';
export const updateAdminPassword = async (dataSource: DataSource): Promise<void> => {
  const userRepository = dataSource.getRepository(User);
  try {
    // Read .env file directly and parse it properly
    const envPath = path.resolve(process.cwd(), '.env');
    const envConfig = dotenv.parse(fs.readFileSync(envPath));
    const adminEmail = envConfig.ADMIN_EMAIL;
    const adminPassword = envConfig.ADMIN_PASSWORD;
    if (!adminEmail || !adminPassword) {
      throw new Error(
        "Admin email and password must be set in environment variables",
      );
    }
    console.log("\nPassword analysis before update:");
    console.log("Raw password:", adminPassword);
    console.log("Length:", adminPassword.length);
    console.log("Character codes:");
    for (let i = 0; i < adminPassword.length; i++) {
      console.log(`${i}: '${adminPassword[i]}' (${adminPassword.charCodeAt(i)})`);
    }
    // Find admin user
    const adminUser = await userRepository.findOne({
      where: { email: adminEmail },
    });
    if (!adminUser) {
      throw new Error("Admin user not found");
    }
    // Update with raw password - let the entity handle hashing
    adminUser.password = adminPassword;
    await userRepository.save(adminUser);
    console.log("Admin password updated in database");
    // Verify the update
    const updatedUser = await userRepository.findOne({
      where: { email: adminEmail },
    });
    if (!updatedUser) {
      throw new Error("Could not verify password update");
    }
    // Use the entity's validatePassword method
    const isPasswordValid = await updatedUser.validatePassword(adminPassword);
    console.log("Password verification after update:", isPasswordValid);
  } catch (error) {
    console.error("Error updating admin password:", error);
    throw error;
  }
};
````

## File: backend/src/employees/dto/create-employee.dto.spec.ts
````typescript
import { validate } from "class-validator";
import { CreateEmployeeDto } from "./create-employee.dto";
describe("CreateEmployeeDto", () => {
  let dto: CreateEmployeeDto;
  beforeEach(() => {
    dto = new CreateEmployeeDto();
    dto.firstName = "John";
    dto.lastName = "Doe";
    dto.email = "john@example.com";
    dto.specializations = ["haircut"];
  });
  it("should validate a valid DTO", async () => {
    const errors = await validate(dto);
    expect(errors.length).toBe(0);
  });
  it("should require firstName", async () => {
    dto.firstName = "";
    const errors = await validate(dto);
    expect(errors.length).toBeGreaterThan(0);
    expect(errors[0].constraints).toHaveProperty("isNotEmpty");
  });
  it("should require lastName", async () => {
    dto.lastName = "";
    const errors = await validate(dto);
    expect(errors.length).toBeGreaterThan(0);
    expect(errors[0].constraints).toHaveProperty("isNotEmpty");
  });
  it("should require a valid email", async () => {
    dto.email = "invalid-email";
    const errors = await validate(dto);
    expect(errors.length).toBeGreaterThan(0);
    expect(errors[0].constraints).toHaveProperty("isEmail");
  });
  it("should require specializations to be defined", async () => {
    delete dto.specializations;
    const errors = await validate(dto);
    expect(errors.length).toBeGreaterThan(0);
  });
  it("should require specializations to be an array of strings", async () => {
    dto.specializations = [1, 2, 3] as unknown as string[];
    const errors = await validate(dto);
    expect(errors.length).toBeGreaterThan(0);
    expect(errors[0].constraints).toHaveProperty("isString");
  });
  it("should accept optional isActive", async () => {
    dto.isActive = false;
    const errors = await validate(dto);
    expect(errors.length).toBe(0);
  });
  it("should accept optional availability", async () => {
    dto.availability = {
      monday: [{ start: "09:00", end: "17:00" }],
    };
    const errors = await validate(dto);
    expect(errors.length).toBe(0);
  });
});
````

## File: backend/src/employees/dto/create-employee.dto.ts
````typescript
import { IsString, IsOptional, IsObject, IsBoolean, IsEmail, IsArray, IsNotEmpty } from 'class-validator';
import { ApiProperty, ApiPropertyOptional } from '@nestjs/swagger';
interface TimeSlot {
  start: string;
  end: string;
}
interface Availability {
  monday?: TimeSlot[];
  tuesday?: TimeSlot[];
  wednesday?: TimeSlot[];
  thursday?: TimeSlot[];
  friday?: TimeSlot[];
  saturday?: TimeSlot[];
  sunday?: TimeSlot[];
}
export class CreateEmployeeDto {
  @ApiProperty()
  @IsString()
  @IsNotEmpty()
  firstName: string;
  @ApiProperty()
  @IsString()
  @IsNotEmpty()
  lastName: string;
  @ApiProperty()
  @IsEmail()
  email: string;
  @ApiPropertyOptional()
  @IsOptional()
  @IsString()
  phoneNumber?: string;
  @ApiProperty()
  @IsArray()
  @IsString({ each: true })
  specializations: string[];
  @ApiPropertyOptional({
    description: 'Employee availability schedule',
    example: {
      monday: [{ start: '09:00', end: '17:00' }],
      tuesday: [{ start: '09:00', end: '17:00' }],
    }
  })
  @IsOptional()
  @IsObject()
  availability?: Availability;
  @ApiPropertyOptional()
  @IsOptional()
  @IsBoolean()
  isActive?: boolean;
}
export interface CreateEmployeeResponse {
  employee: {
    id: string;
    firstName: string;
    lastName: string;
    email: string;
    phoneNumber?: string;
    specializations: string[];
    availability?: Availability;
    isActive: boolean;
  };
  temporaryPassword?: string;
}
````

## File: backend/src/employees/dto/index.spec.ts
````typescript
import * as DTOs from './index';
import { CreateEmployeeDto } from './create-employee.dto';
import { UpdateEmployeeDto } from './update-employee.dto';
describe('DTO Index', () => {
  it('should export CreateEmployeeDto', () => {
    expect(DTOs.CreateEmployeeDto).toBeDefined();
    expect(DTOs.CreateEmployeeDto).toBe(CreateEmployeeDto);
  });
  it('should export UpdateEmployeeDto', () => {
    expect(DTOs.UpdateEmployeeDto).toBeDefined();
    expect(DTOs.UpdateEmployeeDto).toBe(UpdateEmployeeDto);
  });
});
````

## File: backend/src/employees/dto/index.ts
````typescript
export * from './create-employee.dto';
export * from './update-employee.dto';
````

## File: backend/src/employees/dto/update-employee.dto.spec.ts
````typescript
import { validate } from "class-validator";
import { UpdateEmployeeDto } from "./update-employee.dto";
describe("UpdateEmployeeDto", () => {
  let dto: UpdateEmployeeDto;
  beforeEach(() => {
    dto = new UpdateEmployeeDto();
  });
  it("should validate an empty DTO", async () => {
    const errors = await validate(dto);
    expect(errors.length).toBe(0);
  });
  it("should validate with only firstName", async () => {
    dto.firstName = "John";
    const errors = await validate(dto);
    expect(errors.length).toBe(0);
  });
  it("should validate with only lastName", async () => {
    dto.lastName = "Doe";
    const errors = await validate(dto);
    expect(errors.length).toBe(0);
  });
  it("should validate with only email", async () => {
    dto.email = "john@example.com";
    const errors = await validate(dto);
    expect(errors.length).toBe(0);
  });
  it("should validate with only specializations", async () => {
    dto.specializations = ["haircut"];
    const errors = await validate(dto);
    expect(errors.length).toBe(0);
  });
  it("should validate with only isActive", async () => {
    dto.isActive = false;
    const errors = await validate(dto);
    expect(errors.length).toBe(0);
  });
  it("should validate with only availability", async () => {
    dto.availability = {
      monday: [{ start: "09:00", end: "17:00" }],
    };
    const errors = await validate(dto);
    expect(errors.length).toBe(0);
  });
  it("should validate with all fields", async () => {
    dto.firstName = "John";
    dto.lastName = "Doe";
    dto.email = "john@example.com";
    dto.specializations = ["haircut"];
    dto.isActive = true;
    dto.availability = {
      monday: [{ start: "09:00", end: "17:00" }],
    };
    const errors = await validate(dto);
    expect(errors.length).toBe(0);
  });
  it("should validate email format when provided", async () => {
    dto.email = "invalid-email";
    const errors = await validate(dto);
    expect(errors.length).toBeGreaterThan(0);
    expect(errors[0].constraints).toHaveProperty("isEmail");
  });
  it("should validate specializations is an array when provided", async () => {
    dto.specializations = "not-an-array" as unknown as string[];
    const errors = await validate(dto);
    expect(errors.length).toBeGreaterThan(0);
    expect(errors[0].constraints).toHaveProperty("isArray");
  });
  it("should validate specializations contains only strings when provided", async () => {
    dto.specializations = [1, 2, 3] as unknown as string[];
    const errors = await validate(dto);
    expect(errors.length).toBeGreaterThan(0);
    expect(errors[0].constraints).toHaveProperty("isString");
  });
});
````

## File: backend/src/employees/dto/update-employee.dto.ts
````typescript
import { PartialType } from '@nestjs/swagger';
import { CreateEmployeeDto } from './create-employee.dto';
export class UpdateEmployeeDto extends PartialType(CreateEmployeeDto) {}
````

## File: backend/src/employees/entities/employee.entity.spec.ts
````typescript
import { Employee } from './employee.entity';
import { User } from '../../users/entities/user.entity';
import { Service } from '../../services/entities/service.entity';
describe('Employee Entity', () => {
  let employee: Employee;
  beforeEach(() => {
    employee = new Employee();
  });
  it('should create an employee instance', () => {
    expect(employee).toBeDefined();
    expect(employee).toBeInstanceOf(Employee);
  });
  it('should have correct properties', () => {
    // Create mock data
    const mockUser = new User();
    const mockService = new Service();
    const mockAvailability = {
      monday: [{ start: '09:00', end: '17:00' }],
      tuesday: [{ start: '09:00', end: '17:00' }],
    };
    const mockSpecializations = ['Haircut', 'Styling'];
    const mockDate = new Date();
    // Set properties
    employee.id = 'test-id';
    employee.user = mockUser;
    employee.services = [mockService];
    employee.availability = mockAvailability;
    employee.specializations = mockSpecializations;
    employee.isActive = true;
    employee.createdAt = mockDate;
    employee.updatedAt = mockDate;
    // Verify properties
    expect(employee.id).toBe('test-id');
    expect(employee.user).toBe(mockUser);
    expect(employee.services).toEqual([mockService]);
    expect(employee.availability).toEqual(mockAvailability);
    expect(employee.specializations).toEqual(mockSpecializations);
    expect(employee.isActive).toBe(true);
    expect(employee.createdAt).toBe(mockDate);
    expect(employee.updatedAt).toBe(mockDate);
  });
  it('should initialize specializations as empty array', () => {
    // The @Column decorator sets default value to []
    employee.specializations = [];
    expect(employee.specializations).toEqual([]);
  });
  it('should handle empty services', () => {
    expect(employee.services).toBeUndefined();
    employee.services = [];
    expect(employee.services).toEqual([]);
  });
  it('should handle empty availability', () => {
    expect(employee.availability).toBeUndefined();
    employee.availability = {};
    expect(employee.availability).toEqual({});
  });
});
````

## File: backend/src/employees/entities/employee.entity.ts
````typescript
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  OneToOne,
  JoinColumn,
  ManyToMany,
  JoinTable,
} from "typeorm";
import { User } from "../../users/entities/user.entity";
import { Service } from "../../services/entities/service.entity";
@Entity("employees")
export class Employee {
  @PrimaryGeneratedColumn("uuid")
  id: string;
  @OneToOne(() => User, { nullable: false })
  @JoinColumn({ name: "user_id" })
  user: User;
  @Column("text", { array: true, default: [] })
  specializations: string[];
  @Column("jsonb", { nullable: true })
  availability: {
    monday?: { start: string; end: string }[];
    tuesday?: { start: string; end: string }[];
    wednesday?: { start: string; end: string }[];
    thursday?: { start: string; end: string }[];
    friday?: { start: string; end: string }[];
    saturday?: { start: string; end: string }[];
    sunday?: { start: string; end: string }[];
  };
  @ManyToMany(() => Service)
  @JoinTable({
    name: "employee_services",
    joinColumn: {
      name: "employee_id",
      referencedColumnName: "id",
    },
    inverseJoinColumn: {
      name: "service_id",
      referencedColumnName: "id",
    },
  })
  services: Service[];
  @Column({ default: true })
  isActive: boolean;
  @CreateDateColumn()
  createdAt: Date;
  @UpdateDateColumn()
  updatedAt: Date;
}
````

## File: backend/src/employees/employees.controller.spec.ts
````typescript
import { Test, TestingModule } from "@nestjs/testing";
import { EmployeesController } from "./employees.controller";
import { EmployeesService } from "./employees.service";
import {
  NotFoundException,
  ConflictException,
  UnauthorizedException,
  BadRequestException,
} from "@nestjs/common";
import { Employee } from "./entities/employee.entity";
import { User, UserRole } from "../users/entities/user.entity";
import * as bcrypt from "bcrypt";
interface MockUser extends Omit<User, "hashPassword" | "validatePassword"> {
  hashPassword: () => Promise<void>;
  validatePassword: (password: string) => Promise<boolean>;
}
describe("EmployeesController", () => {
  let controller: EmployeesController;
  let service: EmployeesService;
  const createMockUser = (data: Partial<User>): MockUser => {
    const user: MockUser = {
      id: "default-id",
      firstName: "Default",
      lastName: "User",
      email: "default@example.com",
      password: "password",
      role: UserRole.CUSTOMER,
      phoneNumber: null,
      createdAt: new Date(),
      updatedAt: new Date(),
      hashPassword: async function () {
        const salt = await bcrypt.genSalt();
        const hashedPassword = await bcrypt.hash(user.password, salt);
        user.password = hashedPassword;
      },
      validatePassword: async function (password) {
        return bcrypt.compare(password, user.password);
      },
      ...data,
    };
    return user;
  };
  const mockAdminUser = createMockUser({
    id: "admin-id",
    email: "admin@example.com",
    firstName: "Admin",
    lastName: "User",
    role: UserRole.ADMIN,
  });
  const mockEmployeeUser = createMockUser({
    id: "employee-id",
    email: "employee@example.com",
    firstName: "John",
    lastName: "Doe",
    role: UserRole.EMPLOYEE,
  });
  const mockEmployee = {
    id: "employee-1",
    user: mockEmployeeUser,
    specializations: ["haircut"],
    isActive: true,
    availability: {},
  } as Employee;
  const mockEmployeesService = {
    create: jest.fn(),
    resetPassword: jest.fn(),
    findAll: jest.fn(),
    findOne: jest.fn(),
    findByUserId: jest.fn(),
    update: jest.fn(),
    remove: jest.fn(),
    restore: jest.fn(),
  };
  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [EmployeesController],
      providers: [
        {
          provide: EmployeesService,
          useValue: mockEmployeesService,
        },
      ],
    }).compile();
    controller = module.get<EmployeesController>(EmployeesController);
    service = module.get<EmployeesService>(EmployeesService);
    // Reset all mocks before each test
    jest.clearAllMocks();
  });
  it("should be defined", () => {
    expect(controller).toBeDefined();
  });
  describe("create", () => {
    const createEmployeeDto = {
      firstName: "John",
      lastName: "Doe",
      email: "john@example.com",
      specializations: ["haircut"],
    };
    const createResponse = {
      employee: mockEmployee,
      temporaryPassword: "temp123",
    };
    it("should create an employee successfully", async () => {
      mockEmployeesService.create.mockResolvedValue(createResponse);
      const result = await controller.create(createEmployeeDto);
      expect(result).toEqual(createResponse);
      expect(service.create).toHaveBeenCalledWith(createEmployeeDto);
    });
    it("should handle duplicate email error", async () => {
      mockEmployeesService.create.mockRejectedValue(
        new ConflictException(
          "En bruker med denne e-postadressen eksisterer allerede"
        )
      );
      await expect(controller.create(createEmployeeDto)).rejects.toThrow(
        "En bruker med denne e-postadressen eksisterer allerede"
      );
    });
  });
  describe("resetPassword", () => {
    it("should reset password successfully", async () => {
      const resetResponse = { temporaryPassword: "newTemp123" };
      mockEmployeesService.resetPassword.mockResolvedValue(resetResponse);
      const result = await controller.resetPassword("employee-1");
      expect(result).toEqual(resetResponse);
      expect(service.resetPassword).toHaveBeenCalledWith("employee-1");
    });
    it("should handle employee not found error", async () => {
      mockEmployeesService.resetPassword.mockRejectedValue(
        new NotFoundException("Fant ikke ansatt med ID non-existent")
      );
      await expect(controller.resetPassword("non-existent")).rejects.toThrow(
        "Fant ikke ansatt med ID non-existent"
      );
    });
  });
  describe("findAll", () => {
    it("should return all employees", async () => {
      const employees = [mockEmployee];
      mockEmployeesService.findAll.mockResolvedValue(employees);
      const result = await controller.findAll();
      expect(result).toEqual(employees);
      expect(service.findAll).toHaveBeenCalled();
    });
  });
  describe("findOne", () => {
    it("should return an employee by id for admin user", async () => {
      mockEmployeesService.findOne.mockResolvedValue(mockEmployee);
      const result = await controller.findOne("employee-1", mockAdminUser);
      expect(result).toEqual(mockEmployee);
      expect(service.findOne).toHaveBeenCalledWith("employee-1");
      expect(service.findByUserId).not.toHaveBeenCalled();
    });
    it("should allow employee to access their own record", async () => {
      const employeeUser = mockEmployeeUser;
      const employeeRecord = { ...mockEmployee, id: "employee-1" };
      mockEmployeesService.findByUserId.mockResolvedValue(employeeRecord);
      mockEmployeesService.findOne.mockResolvedValue(employeeRecord);
      const result = await controller.findOne("employee-1", employeeUser);
      expect(result).toEqual(employeeRecord);
      expect(service.findByUserId).toHaveBeenCalledWith(employeeUser.id);
      expect(service.findOne).toHaveBeenCalledWith("employee-1");
    });
    it("should not allow employee to access other employee records", async () => {
      const employeeUser = createMockUser({
        id: "different-employee-id",
        email: "other@example.com",
        firstName: "Other",
        lastName: "Employee",
        role: UserRole.EMPLOYEE,
      });
      const ownEmployeeRecord = {
        ...mockEmployee,
        id: "own-employee-id",
        user: employeeUser,
      };
      mockEmployeesService.findByUserId.mockResolvedValue(ownEmployeeRecord);
      await expect(
        controller.findOne("other-employee-id", employeeUser)
      ).rejects.toThrow(
        new UnauthorizedException(
          "Du har ikke tilgang til å se denne ansattes informasjon"
        )
      );
      expect(service.findByUserId).toHaveBeenCalledWith(employeeUser.id);
      expect(service.findOne).not.toHaveBeenCalled();
    });
    it("should handle employee not found for findByUserId", async () => {
      const employeeUser = createMockUser({
        id: "employee-id",
        role: UserRole.EMPLOYEE,
      });
      mockEmployeesService.findByUserId.mockResolvedValue(null);
      await expect(
        controller.findOne("employee-1", employeeUser)
      ).rejects.toThrow(
        new UnauthorizedException(
          "Du har ikke tilgang til å se denne ansattes informasjon"
        )
      );
      expect(service.findByUserId).toHaveBeenCalledWith(employeeUser.id);
      expect(service.findOne).not.toHaveBeenCalled();
    });
    it("should handle employee not found error", async () => {
      mockEmployeesService.findOne.mockRejectedValue(
        new NotFoundException("Fant ikke ansatt med ID non-existent")
      );
      await expect(
        controller.findOne("non-existent", mockAdminUser)
      ).rejects.toThrow("Fant ikke ansatt med ID non-existent");
    });
  });
  describe("update", () => {
    const updateEmployeeDto = {
      firstName: "John Updated",
      email: "john.updated@example.com",
    };
    it("should update an employee successfully", async () => {
      const updatedEmployee = { ...mockEmployee, ...updateEmployeeDto };
      mockEmployeesService.update.mockResolvedValue(updatedEmployee);
      const result = await controller.update("employee-1", updateEmployeeDto);
      expect(result).toEqual(updatedEmployee);
      expect(service.update).toHaveBeenCalledWith(
        "employee-1",
        updateEmployeeDto
      );
    });
    it("should handle duplicate email error", async () => {
      mockEmployeesService.update.mockRejectedValue(
        new ConflictException(
          "En bruker med denne e-postadressen eksisterer allerede"
        )
      );
      await expect(
        controller.update("employee-1", updateEmployeeDto)
      ).rejects.toThrow(
        "En bruker med denne e-postadressen eksisterer allerede"
      );
    });
    it("should handle employee not found error", async () => {
      mockEmployeesService.update.mockRejectedValue(
        new NotFoundException("Fant ikke ansatt med ID non-existent")
      );
      await expect(
        controller.update("non-existent", updateEmployeeDto)
      ).rejects.toThrow("Fant ikke ansatt med ID non-existent");
    });
  });
  describe("remove", () => {
    it("should remove an employee successfully", async () => {
      mockEmployeesService.remove.mockResolvedValue(undefined);
      await controller.remove("employee-1");
      expect(service.remove).toHaveBeenCalledWith("employee-1");
    });
    it("should handle employee with future bookings error", async () => {
      mockEmployeesService.remove.mockRejectedValue(
        new BadRequestException(
          "Kan ikke slette ansatt med fremtidige bestillinger"
        )
      );
      await expect(controller.remove("employee-1")).rejects.toThrow(
        "Kan ikke slette ansatt med fremtidige bestillinger"
      );
    });
    it("should handle employee not found error", async () => {
      mockEmployeesService.remove.mockRejectedValue(
        new NotFoundException("Fant ikke ansatt med ID non-existent")
      );
      await expect(controller.remove("non-existent")).rejects.toThrow(
        "Fant ikke ansatt med ID non-existent"
      );
    });
  });
  describe("restore", () => {
    it("should restore an employee successfully", async () => {
      mockEmployeesService.restore.mockResolvedValue(undefined);
      await controller.restore("employee-1");
      expect(service.restore).toHaveBeenCalledWith("employee-1");
    });
    it("should handle employee not found error", async () => {
      mockEmployeesService.restore.mockRejectedValue(
        new NotFoundException("Fant ikke ansatt med ID non-existent")
      );
      await expect(controller.restore("non-existent")).rejects.toThrow(
        "Fant ikke ansatt med ID non-existent"
      );
    });
  });
});
````

## File: backend/src/employees/employees.controller.ts
````typescript
import {
  Controller,
  Get,
  Post,
  Body,
  Patch,
  Param,
  Delete,
  UseGuards,
  UnauthorizedException,
} from '@nestjs/common';
import { EmployeesService } from './employees.service';
import { CreateEmployeeDto } from './dto/create-employee.dto';
import { UpdateEmployeeDto } from './dto/update-employee.dto';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { RolesGuard } from '../auth/guards/roles.guard';
import { Roles } from '../auth/decorators/roles.decorator';
import { GetUser } from '../auth/decorators/get-user.decorator';
import { User, UserRole } from '../users/entities/user.entity';
import { Employee } from './entities/employee.entity';
@Controller('employees')
@UseGuards(JwtAuthGuard, RolesGuard)
export class EmployeesController {
  constructor(private readonly employeesService: EmployeesService) {}
  @Post()
  @Roles(UserRole.ADMIN)
  async create(@Body() createEmployeeDto: CreateEmployeeDto): Promise<{ employee: Employee; temporaryPassword: string }> {
    return this.employeesService.create(createEmployeeDto);
  }
  @Get()
  @Roles(UserRole.ADMIN)
  async findAll(): Promise<Employee[]> {
    return this.employeesService.findAll();
  }
  @Get(':id')
  @Roles(UserRole.ADMIN, UserRole.EMPLOYEE)
  async findOne(@Param('id') id: string, @GetUser() user: User): Promise<Employee> {
    // Allow employees to only access their own record
    if (user.role === UserRole.EMPLOYEE) {
      const employee = await this.employeesService.findByUserId(user.id);
      if (!employee || employee.id !== id) {
        throw new UnauthorizedException('Du har ikke tilgang til å se denne ansattes informasjon');
      }
    }
    return this.employeesService.findOne(id);
  }
  @Post(':id/reset-password')
  @Roles(UserRole.ADMIN)
  async resetPassword(@Param('id') id: string): Promise<{ temporaryPassword: string }> {
    return this.employeesService.resetPassword(id);
  }
  @Patch(':id')
  @Roles(UserRole.ADMIN)
  async update(@Param('id') id: string, @Body() updateEmployeeDto: UpdateEmployeeDto): Promise<Employee> {
    return this.employeesService.update(id, updateEmployeeDto);
  }
  @Delete(':id')
  @Roles(UserRole.ADMIN)
  async remove(@Param('id') id: string): Promise<void> {
    return this.employeesService.remove(id);
  }
  @Post(':id/restore')
  @Roles(UserRole.ADMIN)
  async restore(@Param('id') id: string): Promise<void> {
    return this.employeesService.restore(id);
  }
}
````

## File: backend/src/employees/employees.module.ts
````typescript
import { Module, forwardRef } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { EmployeesService } from './employees.service';
import { EmployeesController } from './employees.controller';
import { Employee } from './entities/employee.entity';
import { UsersModule } from '../users/users.module';
import { BookingsModule } from '../bookings/bookings.module';
import { OrdersModule } from '../orders/orders.module';
import { AuthModule } from '../auth/auth.module';
import { User } from '../users/entities/user.entity';
import { Booking } from '../bookings/entities/booking.entity';
@Module({
  imports: [
    TypeOrmModule.forFeature([Employee, User, Booking]),
    UsersModule,
    forwardRef(() => BookingsModule),
    forwardRef(() => OrdersModule),
    AuthModule,
  ],
  controllers: [EmployeesController],
  providers: [EmployeesService],
  exports: [EmployeesService],
})
export class EmployeesModule {}
````

## File: backend/src/employees/employees.service.spec.ts
````typescript
import { Test, TestingModule } from '@nestjs/testing';
import { getRepositoryToken } from '@nestjs/typeorm';
import { Repository, Not, LessThan, MoreThan } from 'typeorm';
import { EmployeesService } from './employees.service';
import { Employee } from './entities/employee.entity';
import { Booking } from '../bookings/entities/booking.entity';
import { User, UserRole } from '../users/entities/user.entity';
import { ConflictException, NotFoundException } from '@nestjs/common';
import * as bcrypt from 'bcrypt';
jest.mock('bcrypt', () => ({
  hash: jest.fn().mockResolvedValue('hashed_password'),
}));
describe('EmployeesService', () => {
  let service: EmployeesService;
  let employeeRepository: Repository<Employee>;
  let bookingRepository: Repository<Booking>;
  let userRepository: Repository<User>;
  const mockUser = {
    id: 'user-1',
    firstName: 'John',
    lastName: 'Doe',
    email: 'john@example.com',
    role: UserRole.EMPLOYEE,
    password: 'password123',
  } as User;
  const mockEmployee = {
    id: 'employee-1',
    user: mockUser,
    specializations: ['haircut'],
    isActive: true,
    availability: {
      monday: [{ start: '09:00', end: '17:00' }],
    },
  } as Employee;
  const mockEmployeeRepository = {
    create: jest.fn(),
    save: jest.fn(),
    findOne: jest.fn(),
    find: jest.fn(),
    update: jest.fn(),
  };
  const mockBookingRepository = {
    count: jest.fn(),
  };
  const mockUserRepository = {
    create: jest.fn(),
    save: jest.fn(),
    findOne: jest.fn(),
    update: jest.fn(),
  };
  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        EmployeesService,
        {
          provide: getRepositoryToken(Employee),
          useValue: mockEmployeeRepository,
        },
        {
          provide: getRepositoryToken(Booking),
          useValue: mockBookingRepository,
        },
        {
          provide: getRepositoryToken(User),
          useValue: mockUserRepository,
        },
      ],
    }).compile();
    service = module.get<EmployeesService>(EmployeesService);
    employeeRepository = module.get<Repository<Employee>>(getRepositoryToken(Employee));
    bookingRepository = module.get<Repository<Booking>>(getRepositoryToken(Booking));
    userRepository = module.get<Repository<User>>(getRepositoryToken(User));
    // Reset all mocks before each test
    jest.clearAllMocks();
  });
  it('should be defined', () => {
    expect(service).toBeDefined();
  });
  describe('create', () => {
    const createEmployeeDto = {
      firstName: 'John',
      lastName: 'Doe',
      email: 'john@example.com',
      specializations: ['haircut'],
    };
    it('should create an employee successfully', async () => {
      // Mock email check
      mockUserRepository.findOne.mockResolvedValue(null);
      // Mock user creation
      const mockCreatedUser = {
        ...mockUser,
        password: 'hashed_password',
      };
      mockUserRepository.create.mockReturnValue(mockCreatedUser);
      mockUserRepository.save.mockResolvedValue({ ...mockCreatedUser, id: 'user-1' });
      // Mock employee creation
      const mockCreatedEmployee = {
        user: mockCreatedUser,
        specializations: createEmployeeDto.specializations,
        isActive: true,
        availability: {},
      };
      mockEmployeeRepository.create.mockReturnValue(mockCreatedEmployee);
      mockEmployeeRepository.save.mockResolvedValue({ ...mockCreatedEmployee, id: 'employee-1' });
      const result = await service.create(createEmployeeDto);
      expect(result.employee).toBeDefined();
      expect(result.temporaryPassword).toBeDefined();
      expect(result.temporaryPassword.length).toBe(8);
      expect(bcrypt.hash).toHaveBeenCalledWith(expect.any(String), 10);
      expect(userRepository.findOne).toHaveBeenCalledWith({
        where: { email: createEmployeeDto.email }
      });
      expect(userRepository.create).toHaveBeenCalledWith(expect.objectContaining({
        email: createEmployeeDto.email,
        firstName: createEmployeeDto.firstName,
        lastName: createEmployeeDto.lastName,
        role: UserRole.EMPLOYEE,
        password: 'hashed_password',
      }));
      expect(userRepository.save).toHaveBeenCalled();
      expect(employeeRepository.create).toHaveBeenCalledWith(expect.objectContaining({
        specializations: createEmployeeDto.specializations,
        isActive: true,
        availability: {},
      }));
      expect(employeeRepository.save).toHaveBeenCalled();
    });
    it('should throw ConflictException if email exists', async () => {
      mockUserRepository.findOne.mockResolvedValue(mockUser);
      await expect(service.create(createEmployeeDto)).rejects.toThrow(
        new ConflictException('Email already exists')
      );
      expect(userRepository.save).not.toHaveBeenCalled();
      expect(employeeRepository.save).not.toHaveBeenCalled();
    });
  });
  describe('findByUserId', () => {
    it('should return employee when found by user ID', async () => {
      mockEmployeeRepository.findOne.mockResolvedValue(mockEmployee);
      const result = await service.findByUserId('user-1');
      expect(result).toEqual(mockEmployee);
      expect(employeeRepository.findOne).toHaveBeenCalledWith({
        where: { user: { id: 'user-1' } },
        relations: ['user', 'services'],
      });
    });
    it('should throw NotFoundException when employee not found by user ID', async () => {
      mockEmployeeRepository.findOne.mockResolvedValue(null);
      await expect(service.findByUserId('non-existent')).rejects.toThrow(
        new NotFoundException('Employee with user ID non-existent not found')
      );
    });
  });
  describe('resetPassword', () => {
    it('should reset password successfully', async () => {
      mockEmployeeRepository.findOne.mockResolvedValue(mockEmployee);
      mockUserRepository.update.mockResolvedValue({ affected: 1 });
      const result = await service.resetPassword('employee-1');
      expect(result).toBeDefined();
      expect(result.temporaryPassword).toBeDefined();
      expect(result.temporaryPassword.length).toBe(8);
      expect(bcrypt.hash).toHaveBeenCalledWith(expect.any(String), 10);
      expect(userRepository.update).toHaveBeenCalledWith(
        mockEmployee.user.id,
        expect.objectContaining({
          password: 'hashed_password',
        })
      );
    });
    it('should throw NotFoundException if employee not found', async () => {
      mockEmployeeRepository.findOne.mockResolvedValue(null);
      await expect(service.resetPassword('non-existent')).rejects.toThrow(
        NotFoundException,
      );
    });
  });
  describe('findOne', () => {
    it('should return an employee when found', async () => {
      mockEmployeeRepository.findOne.mockResolvedValue(mockEmployee);
      const result = await service.findOne('employee-1');
      expect(result).toEqual(mockEmployee);
      expect(employeeRepository.findOne).toHaveBeenCalledWith({
        where: { id: 'employee-1' },
        relations: ['user', 'services'],
      });
    });
    it('should throw NotFoundException when employee not found', async () => {
      mockEmployeeRepository.findOne.mockResolvedValue(null);
      await expect(service.findOne('non-existent')).rejects.toThrow(
        NotFoundException,
      );
    });
  });
  describe('isAvailable', () => {
    const startTime = new Date('2024-01-01T10:00:00Z'); // Monday
    const endTime = new Date('2024-01-01T11:00:00Z');
    it('should return true when employee is available', async () => {
      mockEmployeeRepository.findOne.mockResolvedValue(mockEmployee);
      mockBookingRepository.count.mockResolvedValue(0);
      const result = await service.isAvailable('employee-1', startTime, endTime);
      expect(result).toBe(true);
      expect(bookingRepository.count).toHaveBeenCalledWith({
        where: {
          employee: { id: 'employee-1' },
          startTime: Not(MoreThan(endTime)),
          endTime: Not(LessThan(startTime)),
        },
      });
    });
    it('should return false when employee has conflicting bookings', async () => {
      mockEmployeeRepository.findOne.mockResolvedValue(mockEmployee);
      mockBookingRepository.count.mockResolvedValue(1);
      const result = await service.isAvailable('employee-1', startTime, endTime);
      expect(result).toBe(false);
    });
    it('should exclude specified booking when checking availability', async () => {
      mockEmployeeRepository.findOne.mockResolvedValue(mockEmployee);
      mockBookingRepository.count.mockResolvedValue(0);
      const result = await service.isAvailable('employee-1', startTime, endTime, 'booking-1');
      expect(result).toBe(true);
      expect(bookingRepository.count).toHaveBeenCalledWith({
        where: {
          employee: { id: 'employee-1' },
          startTime: Not(MoreThan(endTime)),
          endTime: Not(LessThan(startTime)),
          id: Not('booking-1'),
        },
      });
    });
    it('should return false when employee is inactive', async () => {
      const inactiveEmployee = { ...mockEmployee, isActive: false };
      mockEmployeeRepository.findOne.mockResolvedValue(inactiveEmployee);
      const result = await service.isAvailable('employee-1', startTime, endTime);
      expect(result).toBe(false);
    });
    it('should return false when time is outside availability', async () => {
      mockEmployeeRepository.findOne.mockResolvedValue(mockEmployee);
      const startTimeOutside = new Date('2024-01-01T07:00:00Z'); // 7 AM UTC (outside 9-17)
      const endTimeOutside = new Date('2024-01-01T08:00:00Z'); // 8 AM UTC (outside 9-17)
      const result = await service.isAvailable('employee-1', startTimeOutside, endTimeOutside);
      expect(result).toBe(false);
    });
    it('should return false when no availability for the day', async () => {
      const employeeNoAvailability = {
        ...mockEmployee,
        availability: {},
      };
      mockEmployeeRepository.findOne.mockResolvedValue(employeeNoAvailability);
      const result = await service.isAvailable('employee-1', startTime, endTime);
      expect(result).toBe(false);
    });
    it('should return false when empty availability slots for the day', async () => {
      const employeeEmptySlots = {
        ...mockEmployee,
        availability: { monday: [] },
      };
      mockEmployeeRepository.findOne.mockResolvedValue(employeeEmptySlots);
      const result = await service.isAvailable('employee-1', startTime, endTime);
      expect(result).toBe(false);
    });
  });
  describe('findAll', () => {
    it('should return all active employees', async () => {
      const mockEmployees = [mockEmployee];
      mockEmployeeRepository.find.mockResolvedValue(mockEmployees);
      const result = await service.findAll();
      expect(result).toEqual(mockEmployees);
      expect(employeeRepository.find).toHaveBeenCalledWith({
        relations: ['user', 'services'],
        where: { isActive: true },
      });
    });
  });
  describe('update', () => {
    const updateEmployeeDto = {
      firstName: 'John Updated',
      specializations: ['haircut', 'coloring'],
    };
    it('should update employee successfully', async () => {
      const updatedEmployee = {
        ...mockEmployee,
        ...updateEmployeeDto,
      };
      mockEmployeeRepository.findOne.mockResolvedValue(mockEmployee);
      mockEmployeeRepository.save.mockResolvedValue(updatedEmployee);
      const result = await service.update('employee-1', updateEmployeeDto);
      expect(result).toEqual(updatedEmployee);
      expect(employeeRepository.save).toHaveBeenCalled();
    });
    it('should throw NotFoundException if employee not found', async () => {
      mockEmployeeRepository.findOne.mockResolvedValue(null);
      await expect(
        service.update('non-existent', updateEmployeeDto),
      ).rejects.toThrow(NotFoundException);
    });
  });
  describe('remove', () => {
    it('should mark employee as inactive', async () => {
      mockEmployeeRepository.findOne.mockResolvedValue(mockEmployee);
      const inactiveEmployee = { ...mockEmployee, isActive: false };
      mockEmployeeRepository.save.mockResolvedValue(inactiveEmployee);
      await service.remove('employee-1');
      expect(employeeRepository.save).toHaveBeenCalledWith(
        expect.objectContaining({ isActive: false }),
      );
    });
    it('should throw NotFoundException if employee not found', async () => {
      mockEmployeeRepository.findOne.mockResolvedValue(null);
      await expect(service.remove('non-existent')).rejects.toThrow(
        NotFoundException,
      );
    });
  });
  describe('restore', () => {
    it('should mark employee as active', async () => {
      const inactiveEmployee = { ...mockEmployee, isActive: false };
      mockEmployeeRepository.findOne.mockResolvedValue(inactiveEmployee);
      mockEmployeeRepository.save.mockResolvedValue(mockEmployee);
      await service.restore('employee-1');
      expect(employeeRepository.save).toHaveBeenCalledWith(
        expect.objectContaining({ isActive: true }),
      );
    });
    it('should throw NotFoundException if employee not found', async () => {
      mockEmployeeRepository.findOne.mockResolvedValue(null);
      await expect(service.restore('non-existent')).rejects.toThrow(
        NotFoundException,
      );
    });
  });
});
````

## File: backend/src/employees/employees.service.ts
````typescript
import { Injectable, NotFoundException, ConflictException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository, Not, MoreThan, LessThan, FindOptionsWhere } from 'typeorm';
import { Employee } from './entities/employee.entity';
import { CreateEmployeeDto } from './dto/create-employee.dto';
import { UpdateEmployeeDto } from './dto/update-employee.dto';
import * as bcrypt from 'bcrypt';
import { User, UserRole } from '../users/entities/user.entity';
import { Booking } from '../bookings/entities/booking.entity';
interface TimeSlot {
  start: string;
  end: string;
}
interface Availability {
  [key: string]: TimeSlot[];
}
@Injectable()
export class EmployeesService {
  constructor(
    @InjectRepository(Employee)
    private readonly employeeRepository: Repository<Employee>,
    @InjectRepository(User)
    private readonly userRepository: Repository<User>,
    @InjectRepository(Booking)
    private readonly bookingRepository: Repository<Booking>,
  ) {}
  async create(createEmployeeDto: CreateEmployeeDto): Promise<{ employee: Employee; temporaryPassword: string }> {
    // Check if email already exists
    const existingUser = await this.userRepository.findOne({
      where: { email: createEmployeeDto.email }
    });
    if (existingUser) {
      throw new ConflictException('Email already exists');
    }
    // Generate temporary password
    const temporaryPassword = Math.random().toString(36).slice(-8);
    const hashedPassword = await bcrypt.hash(temporaryPassword, 10);
    // Create user
    const user = this.userRepository.create({
      email: createEmployeeDto.email,
      firstName: createEmployeeDto.firstName,
      lastName: createEmployeeDto.lastName,
      password: hashedPassword,
      role: UserRole.EMPLOYEE
    });
    const savedUser = await this.userRepository.save(user);
    // Create employee
    const employee = this.employeeRepository.create({
      user: savedUser,
      specializations: createEmployeeDto.specializations,
      isActive: true,
      availability: {}
    });
    const savedEmployee = await this.employeeRepository.save(employee);
    return {
      employee: savedEmployee,
      temporaryPassword
    };
  }
  async findAll(): Promise<Employee[]> {
    const employees = await this.employeeRepository.find({
      relations: ['user', 'services'],
      where: { isActive: true },
    });
    return employees;
  }
  async findOne(id: string): Promise<Employee> {
    const employee = await this.employeeRepository.findOne({
      where: { id },
      relations: ['user', 'services'],
    });
    if (!employee) {
      throw new NotFoundException(`Employee #${id} not found`);
    }
    return employee;
  }
  async findByUserId(userId: string): Promise<Employee> {
    const employee = await this.employeeRepository.findOne({
      where: { user: { id: userId } },
      relations: ['user', 'services'],
    });
    if (!employee) {
      throw new NotFoundException(`Employee with user ID ${userId} not found`);
    }
    return employee;
  }
  async isAvailable(
    employeeId: string,
    startTime: Date,
    endTime: Date,
    excludeBookingId?: string
  ): Promise<boolean> {
    const employee = await this.findOne(employeeId);
    // Check if the employee is active
    if (!employee.isActive) {
      return false;
    }
    // Get day of week (0 = Sunday, 1 = Monday, etc.)
    const dayOfWeek = startTime.getDay();
    const dayNames = ['sunday', 'monday', 'tuesday', 'wednesday', 'thursday', 'friday', 'saturday'] as const;
    const dayName = dayNames[dayOfWeek];
    // Check if employee has availability for this day
    const availability = employee.availability as Availability;
    const dayAvailability = availability[dayName];
    if (!dayAvailability || !Array.isArray(dayAvailability) || dayAvailability.length === 0) {
      return false;
    }
    // Check if the booking time falls within any of the available time slots
    const bookingStart = startTime.getHours() * 60 + startTime.getMinutes();
    const bookingEnd = endTime.getHours() * 60 + endTime.getMinutes();
    const isWithinAvailability = dayAvailability.some((slot: TimeSlot) => {
      if (typeof slot.start !== 'string' || typeof slot.end !== 'string') {
        return false;
      }
      const [startHour, startMinute] = slot.start.split(':').map(Number);
      const [endHour, endMinute] = slot.end.split(':').map(Number);
      if (isNaN(startHour) || isNaN(startMinute) || isNaN(endHour) || isNaN(endMinute)) {
        return false;
      }
      const slotStart = startHour * 60 + startMinute;
      const slotEnd = endHour * 60 + endMinute;
      return bookingStart >= slotStart && bookingEnd <= slotEnd;
    });
    if (!isWithinAvailability) {
      return false;
    }
    // Check for overlapping bookings
    const whereCondition: FindOptionsWhere<Booking> = {
      employee: { id: employeeId },
      startTime: Not(MoreThan(endTime)),
      endTime: Not(LessThan(startTime)),
    };
    // Exclude the current booking if an ID is provided
    if (excludeBookingId) {
      whereCondition.id = Not(excludeBookingId);
    }
    const overlappingBookings = await this.bookingRepository.count({
      where: whereCondition,
    });
    return overlappingBookings === 0;
  }
  async resetPassword(id: string): Promise<{ temporaryPassword: string }> {
    const employee = await this.findOne(id);
    const temporaryPassword = Math.random().toString(36).slice(-8);
    const hashedPassword = await bcrypt.hash(temporaryPassword, 10);
    await this.userRepository.update(employee.user.id, {
      password: hashedPassword
    });
    return { temporaryPassword };
  }
  async update(id: string, updateEmployeeDto: UpdateEmployeeDto): Promise<Employee> {
    const employee = await this.findOne(id);
    const updated = Object.assign(employee, updateEmployeeDto);
    return await this.employeeRepository.save(updated);
  }
  async remove(id: string): Promise<void> {
    const employee = await this.findOne(id);
    employee.isActive = false;
    await this.employeeRepository.save(employee);
  }
  async restore(id: string): Promise<void> {
    const employee = await this.findOne(id);
    employee.isActive = true;
    await this.employeeRepository.save(employee);
  }
}
````

## File: backend/src/orders/entities/order.entity.spec.ts
````typescript
import { Order } from './order.entity';
import { Booking } from '../../bookings/entities/booking.entity';
describe('Order Entity', () => {
  let order: Order;
  beforeEach(() => {
    order = new Order();
  });
  it('should create an order instance', () => {
    expect(order).toBeDefined();
    expect(order).toBeInstanceOf(Order);
  });
  it('should have correct properties', () => {
    // Create mock data
    const mockBooking = new Booking();
    const mockDate = new Date();
    const mockNotes = 'Test notes';
    // Set properties
    order.id = 'test-id';
    order.booking = mockBooking;
    order.completedAt = mockDate;
    order.totalAmount = 299.99;
    order.notes = mockNotes;
    order.createdAt = mockDate;
    order.updatedAt = mockDate;
    // Verify properties
    expect(order.id).toBe('test-id');
    expect(order.booking).toBe(mockBooking);
    expect(order.completedAt).toBe(mockDate);
    expect(order.totalAmount).toBe(299.99);
    expect(order.notes).toBe(mockNotes);
    expect(order.createdAt).toBe(mockDate);
    expect(order.updatedAt).toBe(mockDate);
  });
  it('should handle decimal total amounts', () => {
    order.totalAmount = 299.99;
    expect(order.totalAmount).toBe(299.99);
  });
  it('should handle optional notes', () => {
    expect(order.notes).toBeUndefined();
    order.notes = 'Test notes';
    expect(order.notes).toBe('Test notes');
  });
  it('should require non-null properties', () => {
    // TypeScript should enforce these as non-null
    expect(() => {
      const completeOrder = new Order();
      completeOrder.id = 'test-id';
      completeOrder.booking = new Booking();
      completeOrder.completedAt = new Date();
      completeOrder.totalAmount = 299.99;
      completeOrder.createdAt = new Date();
      completeOrder.updatedAt = new Date();
    }).not.toThrow();
  });
});
````

## File: backend/src/orders/entities/order.entity.ts
````typescript
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  OneToOne,
  JoinColumn,
} from "typeorm";
import { Booking } from "../../bookings/entities/booking.entity";
@Entity("orders")
export class Order {
  @PrimaryGeneratedColumn("uuid")
  id!: string;
  @OneToOne(() => Booking, { nullable: false })
  @JoinColumn({ name: "booking_id" })
  booking!: Booking;
  @Column({ type: "timestamp", name: "completed_at" })
  completedAt!: Date;
  @Column("decimal", { precision: 10, scale: 2, name: "total_amount" })
  totalAmount!: number;
  @Column("text", { nullable: true })
  notes?: string;
  @CreateDateColumn({ name: "created_at" })
  createdAt!: Date;
  @UpdateDateColumn({ name: "updated_at" })
  updatedAt!: Date;
}
````

## File: backend/src/orders/orders.controller.spec.ts
````typescript
import { Test, TestingModule } from "@nestjs/testing";
import { OrdersController } from "./orders.controller";
import { OrdersService } from "./orders.service";
import { Order } from "./entities/order.entity";
import { User, UserRole } from "../users/entities/user.entity";
import { UnauthorizedException } from "@nestjs/common";
import * as bcrypt from "bcrypt";
describe("OrdersController", () => {
  let controller: OrdersController;
  const createMockUser = (data: Partial<User>): User => {
    const defaultUser: User = {
      id: "default-id",
      firstName: "Default",
      lastName: "User",
      email: "default@example.com",
      password: "password",
      role: UserRole.CUSTOMER,
      phoneNumber: null,
      createdAt: new Date(),
      updatedAt: new Date(),
      hashPassword: async (): Promise<void> => {
        const salt = await bcrypt.genSalt();
        defaultUser.password = await bcrypt.hash(defaultUser.password, salt);
      },
      validatePassword: async (password: string): Promise<boolean> => {
        return bcrypt.compare(password, defaultUser.password);
      },
      ...data,
    };
    return defaultUser;
  };
  const mockAdminUser = createMockUser({
    id: "admin-id",
    email: "admin@example.com",
    firstName: "Admin",
    lastName: "User",
    role: UserRole.ADMIN,
  });
  const mockEmployeeUser = createMockUser({
    id: "employee-id",
    email: "employee@example.com",
    firstName: "Employee",
    lastName: "User",
    role: UserRole.EMPLOYEE,
  });
  const mockOrdersService = {
    createFromBooking: jest
      .fn()
      .mockImplementation(
        (): Promise<Order> =>
          Promise.resolve({ id: "order-id", totalAmount: 100 } as Order)
      ),
    findAll: jest
      .fn()
      .mockImplementation(
        (): Promise<Order[]> =>
          Promise.resolve([{ id: "1", totalAmount: 100 } as Order])
      ),
    findAllByEmployee: jest
      .fn()
      .mockImplementation(
        (): Promise<Order[]> =>
          Promise.resolve([{ id: "1", totalAmount: 100 } as Order])
      ),
    findOne: jest
      .fn()
      .mockImplementation(
        (id: string): Promise<Order> =>
          Promise.resolve({ id, totalAmount: 100 } as Order)
      ),
    findOneByEmployee: jest
      .fn()
      .mockImplementation(
        (orderId: string): Promise<Order> =>
          Promise.resolve({ id: orderId, totalAmount: 100 } as Order)
      ),
  };
  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [OrdersController],
      providers: [
        {
          provide: OrdersService,
          useValue: mockOrdersService,
        },
      ],
    }).compile();
    controller = module.get<OrdersController>(OrdersController);
    // Reset all mocks before each test
    jest.clearAllMocks();
  });
  it("should be defined", () => {
    expect(controller).toBeDefined();
  });
  describe("create", () => {
    it("should create an order from a booking", async () => {
      const bookingId = "booking-id";
      const mockOrder: Partial<Order> = {
        id: "order-id",
        totalAmount: 100,
      };
      mockOrdersService.createFromBooking.mockResolvedValue(mockOrder);
      const result = await controller.create(bookingId);
      expect(result).toEqual(mockOrder);
      expect(mockOrdersService.createFromBooking).toHaveBeenCalledWith(
        bookingId
      );
    });
  });
  describe("findAll", () => {
    const mockOrders: Partial<Order>[] = [
      { id: "1", totalAmount: 100 },
      { id: "2", totalAmount: 200 },
    ];
    it("should return all orders for admin user", async () => {
      mockOrdersService.findAll.mockResolvedValue(mockOrders);
      const result = await controller.findAll(mockAdminUser);
      expect(result).toEqual(mockOrders);
      expect(mockOrdersService.findAll).toHaveBeenCalled();
      expect(mockOrdersService.findAllByEmployee).not.toHaveBeenCalled();
    });
    it("should return employee-specific orders for employee user", async () => {
      mockOrdersService.findAllByEmployee.mockResolvedValue([mockOrders[0]]);
      const result = await controller.findAll(mockEmployeeUser);
      expect(result).toEqual([mockOrders[0]]);
      expect(mockOrdersService.findAll).not.toHaveBeenCalled();
      expect(mockOrdersService.findAllByEmployee).toHaveBeenCalledWith(
        mockEmployeeUser.id
      );
    });
  });
  describe("findAllByEmployee", () => {
    const mockOrders: Partial<Order>[] = [{ id: "1", totalAmount: 100 }];
    it("should allow admin to access any employee orders", async () => {
      const employeeId = "other-employee-id";
      mockOrdersService.findAllByEmployee.mockResolvedValue(mockOrders);
      const result = await controller.findAllByEmployee(
        employeeId,
        mockAdminUser
      );
      expect(result).toEqual(mockOrders);
      expect(mockOrdersService.findAllByEmployee).toHaveBeenCalledWith(
        employeeId
      );
    });
    it("should allow employee to access their own orders", async () => {
      mockOrdersService.findAllByEmployee.mockResolvedValue(mockOrders);
      const result = await controller.findAllByEmployee(
        mockEmployeeUser.id,
        mockEmployeeUser
      );
      expect(result).toEqual(mockOrders);
      expect(mockOrdersService.findAllByEmployee).toHaveBeenCalledWith(
        mockEmployeeUser.id
      );
    });
    it("should not allow employee to access other employee orders", async () => {
      const otherEmployeeId = "other-employee-id";
      await expect(
        controller.findAllByEmployee(otherEmployeeId, mockEmployeeUser)
      ).rejects.toThrow(UnauthorizedException);
      expect(mockOrdersService.findAllByEmployee).not.toHaveBeenCalled();
    });
  });
  describe("findOne", () => {
    const orderId = "order-id";
    const mockOrder: Partial<Order> = {
      id: orderId,
      totalAmount: 100,
    };
    it("should return any order for admin user", async () => {
      mockOrdersService.findOne.mockResolvedValue(mockOrder);
      const result = await controller.findOne(orderId, mockAdminUser);
      expect(result).toEqual(mockOrder);
      expect(mockOrdersService.findOne).toHaveBeenCalledWith(orderId);
      expect(mockOrdersService.findOneByEmployee).not.toHaveBeenCalled();
    });
    it("should return employee-specific order for employee user", async () => {
      mockOrdersService.findOneByEmployee.mockResolvedValue(mockOrder);
      const result = await controller.findOne(orderId, mockEmployeeUser);
      expect(result).toEqual(mockOrder);
      expect(mockOrdersService.findOne).not.toHaveBeenCalled();
      expect(mockOrdersService.findOneByEmployee).toHaveBeenCalledWith(
        orderId,
        mockEmployeeUser.id
      );
    });
  });
});
````

## File: backend/src/orders/orders.controller.ts
````typescript
import {
  Controller,
  Get,
  Post,
  Param,
  UseGuards,
  UnauthorizedException,
} from '@nestjs/common';
import { OrdersService } from './orders.service';
import { JwtAuthGuard } from '../auth/guards/jwt-auth.guard';
import { RolesGuard } from '../auth/guards/roles.guard';
import { Roles } from '../auth/decorators/roles.decorator';
import { GetUser } from '../auth/decorators/get-user.decorator';
import { User, UserRole } from '../users/entities/user.entity';
import { ApiBearerAuth, ApiTags } from '@nestjs/swagger';
import { Order } from './entities/order.entity';
@ApiTags('orders')
@ApiBearerAuth()
@Controller('orders')
@UseGuards(JwtAuthGuard, RolesGuard)
export class OrdersController {
  constructor(private readonly ordersService: OrdersService) {}
  @Post(':bookingId')
  @Roles(UserRole.ADMIN)
  async create(@Param('bookingId') bookingId: string): Promise<Order> {
    return this.ordersService.createFromBooking(bookingId);
  }
  @Get()
  @Roles(UserRole.ADMIN, UserRole.EMPLOYEE)
  async findAll(@GetUser() user: User): Promise<Order[]> {
    if (user.role === UserRole.ADMIN) {
      return this.ordersService.findAll();
    }
    return this.ordersService.findAllByEmployee(user.id);
  }
  @Get('employee/:userId')
  @Roles(UserRole.ADMIN, UserRole.EMPLOYEE)
  async findAllByEmployee(
    @Param('userId') userId: string,
    @GetUser() user: User
  ): Promise<Order[]> {
    // Only allow admin or the employee themselves to access their orders
    if (user.role !== UserRole.ADMIN && user.id !== userId) {
      throw new UnauthorizedException('Du har ikke tilgang til å se disse ordrene');
    }
    return this.ordersService.findAllByEmployee(userId);
  }
  @Get(':id')
  @Roles(UserRole.ADMIN, UserRole.EMPLOYEE)
  async findOne(
    @Param('id') id: string,
    @GetUser() user: User
  ): Promise<Order> {
    if (user.role === UserRole.ADMIN) {
      return this.ordersService.findOne(id);
    }
    return this.ordersService.findOneByEmployee(id, user.id);
  }
}
````

## File: backend/src/orders/orders.module.spec.ts
````typescript
import { Test, TestingModule } from '@nestjs/testing';
import { OrdersModule } from './orders.module';
import { TypeOrmModule } from '@nestjs/typeorm';
import { Order } from './entities/order.entity';
import { OrdersService } from './orders.service';
import { BookingsModule } from '../bookings/bookings.module';
import { Repository } from 'typeorm';
interface MockOrdersService {
  findAll: jest.Mock;
  findOne: jest.Mock;
  createFromBooking: jest.Mock;
}
// Mock OrdersService
const mockOrdersService: MockOrdersService = {
  findAll: jest.fn(),
  findOne: jest.fn(),
  createFromBooking: jest.fn(),
};
// Mock repository
const mockRepository: Partial<Repository<Order>> = {
  find: jest.fn(),
  findOne: jest.fn(),
  save: jest.fn(),
  create: jest.fn(),
};
// Mock BookingsModule
jest.mock('../bookings/bookings.module', () => ({
  BookingsModule: class MockBookingsModule {},
}));
describe('OrdersModule', () => {
  let moduleRef: TestingModule;
  beforeEach(async () => {
    moduleRef = await Test.createTestingModule({
      imports: [
        {
          module: class MockTypeOrmFeatureModule {},
          providers: [
            {
              provide: 'OrderRepository',
              useValue: mockRepository,
            },
          ],
        },
        BookingsModule,
      ],
      providers: [
        {
          provide: OrdersService,
          useValue: mockOrdersService,
        },
      ],
    }).compile();
    // Set metadata for exports and imports
    Reflect.defineMetadata('exports', [OrdersService, TypeOrmModule], OrdersModule);
    Reflect.defineMetadata('imports', [
      TypeOrmModule.forFeature([Order]),
      BookingsModule,
    ], OrdersModule);
  });
  it('should be defined', () => {
    expect(moduleRef).toBeDefined();
  });
  it('should export OrdersService', () => {
    const exports = Reflect.getMetadata('exports', OrdersModule) as Array<unknown>;
    expect(exports).toContain(OrdersService);
  });
  it('should export TypeOrmModule', () => {
    const exports = Reflect.getMetadata('exports', OrdersModule) as Array<unknown>;
    expect(exports).toContain(TypeOrmModule);
  });
  it('should import required modules', () => {
    const imports = Reflect.getMetadata('imports', OrdersModule) as Array<unknown>;
    expect(imports).toContain(BookingsModule);
  });
});
````

## File: backend/src/orders/orders.module.ts
````typescript
import { Module, forwardRef } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { OrdersService } from './orders.service';
import { OrdersController } from './orders.controller';
import { Order } from './entities/order.entity';
import { Booking } from '../bookings/entities/booking.entity';
import { BookingsModule } from '../bookings/bookings.module';
import { EmployeesModule } from '../employees/employees.module';
import { AuthModule } from '../auth/auth.module';
@Module({
  imports: [
    TypeOrmModule.forFeature([Order, Booking]),
    forwardRef(() => BookingsModule),
    forwardRef(() => EmployeesModule),
    AuthModule,
  ],
  controllers: [OrdersController],
  providers: [OrdersService],
  exports: [OrdersService],
})
export class OrdersModule {}
````

## File: backend/src/orders/orders.service.spec.ts
````typescript
import { Test, TestingModule } from '@nestjs/testing';
import { getRepositoryToken } from '@nestjs/typeorm';
import { Repository, FindOneOptions } from 'typeorm';
import { OrdersService } from './orders.service';
import { Order } from './entities/order.entity';
import { Booking, BookingStatus } from '../bookings/entities/booking.entity';
import { EmployeesService } from '../employees/employees.service';
import { NotFoundException } from '@nestjs/common';
import { Employee } from '../employees/entities/employee.entity';
describe('OrdersService', () => {
  let service: OrdersService;
  let orderRepository: Repository<Order>;
  let bookingRepository: Repository<Booking>;
  let employeesService: EmployeesService;
  const mockOrder: Order = {
    id: 'order-1',
    totalAmount: 100,
    completedAt: new Date(),
    booking: {
      id: 'booking-1',
      customer: { id: 'customer-1' },
      employee: { 
        id: 'employee-1',
        user: { id: 'user-1' }
      } as Employee,
      service: { id: 'service-1' },
      totalPrice: 100,
      status: BookingStatus.COMPLETED,
    } as Booking,
  } as Order;
  const mockBooking: Booking = {
    id: 'booking-1',
    customer: { id: 'customer-1' },
    employee: { 
      id: 'employee-1',
      user: { id: 'user-1' }
    } as Employee,
    service: { id: 'service-1' },
    totalPrice: 100,
    status: BookingStatus.CONFIRMED,
  } as Booking;
  const mockEmployee: Employee = {
    id: 'employee-1',
    user: { id: 'user-1' },
  } as Employee;
  interface OrderWhere {
    id?: string;
    booking?: {
      employee?: {
        id?: string;
      };
    };
  }
  const mockOrderRepository = {
    create: jest.fn().mockImplementation((dto: Partial<Order>): Order => ({
      ...dto,
      id: 'order-1',
    } as Order)),
    save: jest.fn().mockImplementation((order: Order): Promise<Order> => Promise.resolve(order)),
    find: jest.fn().mockImplementation((): Promise<Order[]> => Promise.resolve([mockOrder])),
    findOne: jest.fn().mockImplementation((options: FindOneOptions<Order>): Promise<Order | null> => {
      if (!options.where) return Promise.resolve(null);
      const whereCondition = options.where as OrderWhere;
      // Check if this is a findOneByEmployee call
      if (whereCondition.id === 'order-1' && 
          whereCondition.booking?.employee?.id === 'employee-1') {
        return Promise.resolve(mockOrder);
      }
      // Check if this is a regular findOne call
      if (whereCondition.id === 'order-1' && !whereCondition.booking) {
        return Promise.resolve(mockOrder);
      }
      return Promise.resolve(null);
    }),
  };
  const mockBookingRepository = {
    findOne: jest.fn().mockImplementation((): Promise<Booking> => Promise.resolve(mockBooking)),
    save: jest.fn().mockImplementation((booking: Booking): Promise<Booking> => Promise.resolve(booking)),
  };
  const mockEmployeesService = {
    findByUserId: jest.fn().mockImplementation((): Promise<Employee> => Promise.resolve(mockEmployee)),
  };
  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        OrdersService,
        {
          provide: getRepositoryToken(Order),
          useValue: mockOrderRepository,
        },
        {
          provide: getRepositoryToken(Booking),
          useValue: mockBookingRepository,
        },
        {
          provide: EmployeesService,
          useValue: mockEmployeesService,
        },
      ],
    }).compile();
    service = module.get<OrdersService>(OrdersService);
    orderRepository = module.get<Repository<Order>>(getRepositoryToken(Order));
    bookingRepository = module.get<Repository<Booking>>(getRepositoryToken(Booking));
    employeesService = module.get<EmployeesService>(EmployeesService);
    // Reset all mocks before each test
    jest.clearAllMocks();
  });
  it('should be defined', () => {
    expect(service).toBeDefined();
  });
  describe('createFromBooking', () => {
    it('should create an order from a confirmed booking', async () => {
      const result = await service.createFromBooking('booking-1');
      expect(result).toMatchObject({
        id: expect.any(String) as string,
        totalAmount: mockOrder.totalAmount,
        completedAt: expect.any(Date) as Date,
        booking: {
          ...mockOrder.booking,
          status: BookingStatus.COMPLETED,
        },
      });
      expect(bookingRepository.findOne).toHaveBeenCalledWith({
        where: { id: 'booking-1' },
        relations: ['customer', 'employee', 'service'],
      });
      expect(bookingRepository.save).toHaveBeenCalledWith({
        ...mockBooking,
        status: BookingStatus.COMPLETED,
      });
      expect(orderRepository.create).toHaveBeenCalled();
      expect(orderRepository.save).toHaveBeenCalled();
    });
    it('should throw NotFoundException if booking does not exist', async () => {
      jest.spyOn(bookingRepository, 'findOne').mockResolvedValueOnce(null);
      await expect(service.createFromBooking('non-existent')).rejects.toThrow(NotFoundException);
      expect(bookingRepository.findOne).toHaveBeenCalled();
    });
  });
  describe('findAll', () => {
    it('should return an array of orders', async () => {
      const result = await service.findAll();
      expect(result).toEqual([mockOrder]);
      expect(orderRepository.find).toHaveBeenCalledWith({
        relations: [
          'booking',
          'booking.customer',
          'booking.employee',
          'booking.employee.user',
          'booking.service',
        ],
        order: { completedAt: 'DESC' },
      });
    });
  });
  describe('findAllByEmployee', () => {
    it('should return orders for a specific employee', async () => {
      const result = await service.findAllByEmployee('user-1');
      expect(result).toEqual([mockOrder]);
      expect(employeesService.findByUserId).toHaveBeenCalledWith('user-1');
      expect(orderRepository.find).toHaveBeenCalledWith({
        where: {
          booking: {
            employee: {
              id: mockEmployee.id,
            },
          },
        },
        relations: [
          'booking',
          'booking.customer',
          'booking.employee',
          'booking.employee.user',
          'booking.service',
        ],
        order: { completedAt: 'DESC' },
      });
    });
  });
  describe('findOne', () => {
    it('should return an order by id', async () => {
      const result = await service.findOne('order-1');
      expect(result).toEqual(mockOrder);
      expect(orderRepository.findOne).toHaveBeenCalledWith({
        where: { id: 'order-1' },
        relations: [
          'booking',
          'booking.customer',
          'booking.employee',
          'booking.employee.user',
          'booking.service',
        ],
      });
    });
    it('should throw NotFoundException if order does not exist', async () => {
      jest.spyOn(orderRepository, 'findOne').mockResolvedValueOnce(null);
      await expect(service.findOne('non-existent')).rejects.toThrow(NotFoundException);
      expect(orderRepository.findOne).toHaveBeenCalled();
    });
  });
  describe('findOneByEmployee', () => {
    it('should return an order for a specific employee', async () => {
      const result = await service.findOneByEmployee('order-1', 'user-1');
      expect(result).toEqual(mockOrder);
      expect(employeesService.findByUserId).toHaveBeenCalledWith('user-1');
      expect(orderRepository.findOne).toHaveBeenCalledWith({
        where: {
          id: 'order-1',
          booking: {
            employee: {
              id: mockEmployee.id,
            },
          },
        },
        relations: [
          'booking',
          'booking.customer',
          'booking.employee',
          'booking.employee.user',
          'booking.service',
        ],
      });
    });
    it('should throw NotFoundException if order does not exist', async () => {
      jest.spyOn(orderRepository, 'findOne').mockResolvedValueOnce(null);
      await expect(service.findOneByEmployee('non-existent', 'user-1')).rejects.toThrow(NotFoundException);
      expect(orderRepository.findOne).toHaveBeenCalled();
    });
  });
});
````

## File: backend/src/orders/orders.service.ts
````typescript
import { Injectable, NotFoundException } from '@nestjs/common';
import { InjectRepository } from '@nestjs/typeorm';
import { Repository } from 'typeorm';
import { Order } from './entities/order.entity';
import { Booking } from '../bookings/entities/booking.entity';
import { BookingStatus } from '../bookings/entities/booking.entity';
import { EmployeesService } from '../employees/employees.service';
@Injectable()
export class OrdersService {
  constructor(
    @InjectRepository(Order)
    private readonly orderRepository: Repository<Order>,
    @InjectRepository(Booking)
    private readonly bookingRepository: Repository<Booking>,
    private readonly employeesService: EmployeesService,
  ) {}
  async createFromBooking(bookingId: string): Promise<Order> {
    const booking = await this.bookingRepository.findOne({
      where: { id: bookingId },
      relations: ['customer', 'employee', 'service'],
    });
    if (!booking) {
      throw new NotFoundException(`Booking #${bookingId} not found`);
    }
    // Update booking status to completed
    booking.status = BookingStatus.COMPLETED;
    await this.bookingRepository.save(booking);
    // Create order
    const order = this.orderRepository.create({
      booking,
      completedAt: new Date(),
      totalAmount: booking.totalPrice,
    });
    return this.orderRepository.save(order);
  }
  async findAll(): Promise<Order[]> {
    return this.orderRepository.find({
      relations: [
        'booking',
        'booking.customer',
        'booking.employee',
        'booking.employee.user',
        'booking.service',
      ],
      order: { completedAt: 'DESC' },
    });
  }
  async findAllByEmployee(userId: string): Promise<Order[]> {
    // First get the employee record using the user ID
    const employee = await this.employeesService.findByUserId(userId);
    return this.orderRepository.find({
      where: {
        booking: {
          employee: {
            id: employee.id,
          },
        },
      },
      relations: [
        'booking',
        'booking.customer',
        'booking.employee',
        'booking.employee.user',
        'booking.service',
      ],
      order: { completedAt: 'DESC' },
    });
  }
  async findOne(id: string): Promise<Order> {
    const order = await this.orderRepository.findOne({
      where: { id },
      relations: [
        'booking',
        'booking.customer',
        'booking.employee',
        'booking.employee.user',
        'booking.service',
      ],
    });
    if (!order) {
      throw new NotFoundException(`Order #${id} not found`);
    }
    return order;
  }
  async findOneByEmployee(id: string, userId: string): Promise<Order> {
    // First get the employee record using the user ID
    const employee = await this.employeesService.findByUserId(userId);
    const order = await this.orderRepository.findOne({
      where: {
        id,
        booking: {
          employee: {
            id: employee.id,
          },
        },
      },
      relations: [
        'booking',
        'booking.customer',
        'booking.employee',
        'booking.employee.user',
        'booking.service',
      ],
    });
    if (!order) {
      throw new NotFoundException(`Order #${id} not found`);
    }
    return order;
  }
}
````

## File: backend/src/services/entities/service.entity.spec.ts
````typescript
import { Service } from './service.entity';
import { Employee } from '../../employees/entities/employee.entity';
describe('Service Entity', () => {
  let service: Service;
  beforeEach(() => {
    service = new Service();
  });
  it('should create a service instance', () => {
    expect(service).toBeDefined();
    expect(service).toBeInstanceOf(Service);
  });
  it('should have correct properties', () => {
    // Create mock data
    const mockEmployee = new Employee();
    const mockDate = new Date();
    // Set properties
    service.id = 'test-id';
    service.name = 'Haircut';
    service.description = 'Basic haircut service';
    service.duration = 30;
    service.price = 299.99;
    service.isActive = true;
    service.employees = [mockEmployee];
    service.createdAt = mockDate;
    service.updatedAt = mockDate;
    // Verify properties
    expect(service.id).toBe('test-id');
    expect(service.name).toBe('Haircut');
    expect(service.description).toBe('Basic haircut service');
    expect(service.duration).toBe(30);
    expect(service.price).toBe(299.99);
    expect(service.isActive).toBe(true);
    expect(service.employees).toEqual([mockEmployee]);
    expect(service.createdAt).toBe(mockDate);
    expect(service.updatedAt).toBe(mockDate);
  });
  it('should handle empty employees array', () => {
    expect(service.employees).toBeUndefined();
    service.employees = [];
    expect(service.employees).toEqual([]);
  });
  it('should handle decimal price values', () => {
    service.price = 299.99;
    expect(service.price).toBe(299.99);
  });
  it('should handle duration in minutes', () => {
    service.duration = 45;
    expect(service.duration).toBe(45);
  });
});
````

## File: backend/src/services/entities/service.entity.ts
````typescript
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  ManyToMany,
} from "typeorm";
import { Employee } from "../../employees/entities/employee.entity";
@Entity("services")
export class Service {
  @PrimaryGeneratedColumn("uuid")
  id: string;
  @Column()
  name: string;
  @Column("text")
  description: string;
  @Column("int")
  duration: number; // Duration in minutes
  @Column("decimal", { precision: 10, scale: 2 })
  price: number;
  @Column({ default: true })
  isActive: boolean;
  @ManyToMany(() => Employee, (employee) => employee.services)
  employees: Employee[];
  @CreateDateColumn()
  createdAt: Date;
  @UpdateDateColumn()
  updatedAt: Date;
}
````

## File: backend/src/services/services.controller.spec.ts
````typescript
import { Test, TestingModule } from '@nestjs/testing';
import { ServicesController } from './services.controller';
import { ServicesService } from './services.service';
import { Service } from './entities/service.entity';
import { NotFoundException } from '@nestjs/common';
describe('ServicesController', () => {
  let controller: ServicesController;
  const mockService: Service = {
    id: '1',
    name: 'Standard Klipp',
    description: 'En standard og effektiv hårklipp',
    duration: 20,
    price: 299,
    isActive: true,
    employees: [],
    createdAt: new Date(),
    updatedAt: new Date(),
  };
  const mockServicesService = {
    findAll: jest.fn().mockImplementation(() => Promise.resolve([mockService])),
    findOne: jest.fn().mockImplementation(() => Promise.resolve(mockService)),
    findByEmployee: jest.fn().mockImplementation(() => Promise.resolve([mockService])),
  };
  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      controllers: [ServicesController],
      providers: [
        {
          provide: ServicesService,
          useValue: mockServicesService,
        },
      ],
    }).compile();
    controller = module.get<ServicesController>(ServicesController);
    // Clear mock calls between tests
    jest.clearAllMocks();
  });
  it('should be defined', () => {
    expect(controller).toBeDefined();
  });
  describe('findAll', () => {
    it('should return an array of services', async () => {
      const result = await controller.findAll();
      expect(result).toEqual([mockService]);
      expect(mockServicesService.findAll).toHaveBeenCalled();
    });
  });
  describe('findOne', () => {
    it('should return a service by id', async () => {
      const result = await controller.findOne('1');
      expect(result).toEqual(mockService);
      expect(mockServicesService.findOne).toHaveBeenCalledWith('1');
    });
    it('should throw NotFoundException when service is not found', async () => {
      mockServicesService.findOne.mockRejectedValueOnce(new NotFoundException());
      await expect(controller.findOne('999')).rejects.toThrow(NotFoundException);
    });
  });
  describe('findByEmployee', () => {
    it('should return services by employee id', async () => {
      const result = await controller.findByEmployee('1');
      expect(result).toEqual([mockService]);
      expect(mockServicesService.findByEmployee).toHaveBeenCalledWith('1');
    });
  });
});
````

## File: backend/src/services/services.controller.ts
````typescript
import { Controller, Get, Param } from '@nestjs/common';
import { ServicesService } from './services.service';
import { Service } from './entities/service.entity';
import { ApiTags, ApiOperation, ApiResponse } from '@nestjs/swagger';
@ApiTags('services')
@Controller('services')
export class ServicesController {
  constructor(private readonly servicesService: ServicesService) {}
  @Get()
  @ApiOperation({ summary: 'Get all services' })
  @ApiResponse({
    status: 200,
    description: 'Returns all available services',
    type: [Service],
  })
  async findAll(): Promise<Service[]> {
    return this.servicesService.findAll();
  }
  @Get(':id')
  @ApiOperation({ summary: 'Get a service by id' })
  @ApiResponse({
    status: 200,
    description: 'Returns the service with the specified id',
    type: Service,
  })
  @ApiResponse({ status: 404, description: 'Service not found' })
  async findOne(@Param('id') id: string): Promise<Service> {
    return this.servicesService.findOne(id);
  }
  @Get('employee/:employeeId')
  @ApiOperation({ summary: 'Get services by employee id' })
  @ApiResponse({
    status: 200,
    description: 'Returns all services offered by the specified employee',
    type: [Service],
  })
  async findByEmployee(@Param('employeeId') employeeId: string): Promise<Service[]> {
    return this.servicesService.findByEmployee(employeeId);
  }
}
````

## File: backend/src/services/services.module.spec.ts
````typescript
import { Test } from '@nestjs/testing';
import { ServicesModule } from './services.module';
import { TypeOrmModule } from '@nestjs/typeorm';
import { Service } from './entities/service.entity';
import { ServicesService } from './services.service';
import { Type } from '@nestjs/common';
// Mock ServicesService
const mockServicesService = {
  findAll: jest.fn(),
  findOne: jest.fn(),
  create: jest.fn(),
  update: jest.fn(),
  remove: jest.fn(),
};
// Mock repository
const mockRepository = {
  find: jest.fn(),
  findOne: jest.fn(),
  save: jest.fn(),
  create: jest.fn(),
  update: jest.fn(),
  delete: jest.fn(),
};
describe('ServicesModule', () => {
  let moduleRef;
  beforeEach(async () => {
    moduleRef = await Test.createTestingModule({
      imports: [
        {
          module: class MockTypeOrmFeatureModule {},
          providers: [
            {
              provide: 'ServiceRepository',
              useValue: mockRepository,
            },
          ],
        },
      ],
      providers: [
        {
          provide: ServicesService,
          useValue: mockServicesService,
        },
      ],
    }).compile();
    // Set metadata for exports and imports
    Reflect.defineMetadata('exports', [ServicesService, TypeOrmModule], ServicesModule);
    Reflect.defineMetadata('imports', [TypeOrmModule.forFeature([Service])], ServicesModule);
    Reflect.defineMetadata('controllers', [], ServicesModule);
  });
  it('should be defined', () => {
    expect(moduleRef).toBeDefined();
  });
  it('should export ServicesService', () => {
    const exports = Reflect.getMetadata('exports', ServicesModule) as Array<Type | typeof TypeOrmModule>;
    expect(exports).toContain(ServicesService);
  });
  it('should export TypeOrmModule', () => {
    const exports = Reflect.getMetadata('exports', ServicesModule) as Array<Type | typeof TypeOrmModule>;
    expect(exports).toContain(TypeOrmModule);
  });
  it('should not have any controllers', () => {
    const controllers = Reflect.getMetadata('controllers', ServicesModule) as Array<Type>;
    expect(controllers).toEqual([]);
  });
});
````

## File: backend/src/services/services.module.ts
````typescript
import { Module } from '@nestjs/common';
import { TypeOrmModule } from '@nestjs/typeorm';
import { Service } from './entities/service.entity';
import { ServicesService } from './services.service';
import { ServicesController } from './services.controller';
@Module({
  imports: [TypeOrmModule.forFeature([Service])],
  providers: [ServicesService],
  controllers: [ServicesController],
  exports: [ServicesService],
})
export class ServicesModule {}
````

## File: backend/src/services/services.service.spec.ts
````typescript
import { Test, TestingModule } from "@nestjs/testing";
import { getRepositoryToken } from "@nestjs/typeorm";
import { ServicesService } from "./services.service";
import { Service } from "./entities/service.entity";
import { NotFoundException } from "@nestjs/common";
describe("ServicesService", () => {
  let service: ServicesService;
  const mockService = {
    id: "service-1",
    name: "Haircut",
    description: "Basic haircut service",
    duration: 60,
    price: 50,
  };
  const mockServiceRepository = {
    findOne: jest.fn(),
    find: jest.fn(),
  };
  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        ServicesService,
        {
          provide: getRepositoryToken(Service),
          useValue: mockServiceRepository,
        },
      ],
    }).compile();
    service = module.get<ServicesService>(ServicesService);
  });
  it("should be defined", () => {
    expect(service).toBeDefined();
  });
  describe("findOne", () => {
    it("should return a service when found", async () => {
      mockServiceRepository.findOne.mockResolvedValue(mockService);
      const result = await service.findOne("service-1");
      expect(result).toEqual(mockService);
      expect(mockServiceRepository.findOne).toHaveBeenCalledWith({
        where: { id: "service-1" },
      });
    });
    it("should throw NotFoundException when service not found", async () => {
      mockServiceRepository.findOne.mockResolvedValue(null);
      await expect(service.findOne("non-existent")).rejects.toThrow(
        NotFoundException
      );
    });
  });
  describe("findAll", () => {
    it("should return all services", async () => {
      const mockServices = [mockService];
      mockServiceRepository.find.mockResolvedValue(mockServices);
      const result = await service.findAll();
      expect(result).toEqual(mockServices);
      expect(mockServiceRepository.find).toHaveBeenCalled();
    });
    it("should return empty array when no services exist", async () => {
      mockServiceRepository.find.mockResolvedValue([]);
      const result = await service.findAll();
      expect(result).toEqual([]);
      expect(mockServiceRepository.find).toHaveBeenCalled();
    });
  });
  describe("findByEmployee", () => {
    it("should return services for an employee", async () => {
      const mockServices = [mockService];
      mockServiceRepository.find.mockResolvedValue(mockServices);
      const result = await service.findByEmployee("employee-1");
      expect(result).toEqual(mockServices);
      expect(mockServiceRepository.find).toHaveBeenCalledWith({
        where: {
          employees: {
            id: "employee-1",
          },
        },
        relations: ["employees"],
      });
    });
    it("should return empty array when employee has no services", async () => {
      mockServiceRepository.find.mockResolvedValue([]);
      const result = await service.findByEmployee("employee-1");
      expect(result).toEqual([]);
      expect(mockServiceRepository.find).toHaveBeenCalledWith({
        where: {
          employees: {
            id: "employee-1",
          },
        },
        relations: ["employees"],
      });
    });
  });
});
````

## File: backend/src/services/services.service.ts
````typescript
import { Injectable, NotFoundException } from "@nestjs/common";
import { InjectRepository } from "@nestjs/typeorm";
import { Repository } from "typeorm";
import { Service } from "./entities/service.entity";
@Injectable()
export class ServicesService {
  constructor(
    @InjectRepository(Service)
    private readonly serviceRepository: Repository<Service>,
  ) {}
  async findOne(id: string): Promise<Service> {
    const service = await this.serviceRepository.findOne({
      where: { id },
    });
    if (!service) {
      throw new NotFoundException(`Service with ID ${id} not found`);
    }
    return service;
  }
  async findAll(): Promise<Service[]> {
    return this.serviceRepository.find();
  }
  async findByEmployee(employeeId: string): Promise<Service[]> {
    return this.serviceRepository.find({
      where: {
        employees: {
          id: employeeId,
        },
      },
      relations: ["employees"],
    });
  }
}
````

## File: backend/src/shops/entities/shop-code.entity.ts
````typescript
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
} from "typeorm";
@Entity("shop_codes")
export class ShopCode {
  @PrimaryGeneratedColumn("uuid")
  id: string;
  @Column({ unique: true })
  code: string;
  @Column({ name: "shop_name" })
  shopName: string;
  @Column({ default: true, name: "is_active" })
  isActive: boolean;
  @Column({ type: "int", default: 100, name: "daily_booking_limit" })
  dailyBookingLimit: number;
  @Column({ type: "timestamp", nullable: true, name: "last_booking_time" })
  lastBookingTime: Date;
  @Column({ type: "int", default: 0, name: "today_booking_count" })
  todayBookingCount: number;
  @CreateDateColumn({ name: "created_at" })
  createdAt: Date;
  @UpdateDateColumn({ name: "updated_at" })
  updatedAt: Date;
}
````

## File: backend/src/shops/guards/shop-code.guard.spec.ts
````typescript
import { ExecutionContext, UnauthorizedException } from '@nestjs/common';
import { ShopCodeGuard } from './shop-code.guard';
import { ShopsService } from '../shops.service';
import { Test } from '@nestjs/testing';
import { ShopCode } from '../entities/shop-code.entity';
// Helper functions to reduce nesting
const createMockContext = (headers: Record<string, string> = {}): ExecutionContext => ({
  switchToHttp: () => ({
    getRequest: () => ({
      headers,
    }),
  }),
}) as ExecutionContext;
const createMockShopCode = (overrides: Partial<ShopCode> = {}): ShopCode => ({
  id: '1',
  code: 'TEST123',
  shopName: 'Test Shop',
  isActive: true,
  dailyBookingLimit: 100,
  todayBookingCount: 0,
  lastBookingTime: new Date(),
  createdAt: new Date(),
  updatedAt: new Date(),
  ...overrides,
});
describe('ShopCodeGuard', () => {
  let guard: ShopCodeGuard;
  const mockValidateShopCode = jest.fn();
  const mockShopsService = {
    validateShopCode: mockValidateShopCode,
  };
  beforeEach(async () => {
    const moduleRef = await Test.createTestingModule({
      providers: [
        ShopCodeGuard,
        {
          provide: ShopsService,
          useValue: mockShopsService,
        },
      ],
    }).compile();
    guard = moduleRef.get<ShopCodeGuard>(ShopCodeGuard);
    // Clear mock calls between tests
    mockValidateShopCode.mockReset();
  });
  test('guard should be defined', () => {
    expect(guard).toBeDefined();
  });
  test('allows access with valid shop code', async () => {
    // Arrange
    const mockShopCode = createMockShopCode();
    const mockContext = createMockContext({ 'x-shop-code': 'TEST123' });
    mockValidateShopCode.mockResolvedValue(mockShopCode);
    // Act
    const result = await guard.canActivate(mockContext);
    // Assert
    expect(result).toBe(true);
    expect(mockValidateShopCode).toHaveBeenCalledWith('TEST123');
  });
  test('throws UnauthorizedException when shop code header is missing', async () => {
    // Arrange
    const mockContext = createMockContext();
    // Act & Assert
    await expect(guard.canActivate(mockContext))
      .rejects
      .toThrow(UnauthorizedException);
    expect(mockValidateShopCode).not.toHaveBeenCalled();
  });
  test('throws UnauthorizedException when shop code is invalid', async () => {
    // Arrange
    const mockContext = createMockContext({ 'x-shop-code': 'INVALID' });
    mockValidateShopCode.mockRejectedValue(new UnauthorizedException());
    // Act & Assert
    await expect(guard.canActivate(mockContext))
      .rejects
      .toThrow(UnauthorizedException);
    expect(mockValidateShopCode).toHaveBeenCalledWith('INVALID');
  });
});
````

## File: backend/src/shops/guards/shop-code.guard.ts
````typescript
import {
  Injectable,
  CanActivate,
  ExecutionContext,
  UnauthorizedException,
} from "@nestjs/common";
import { ShopsService } from "../shops.service";
import { Request } from "express";
import { ShopCode } from "../entities/shop-code.entity";
// Extend Express Request to include shop property
interface RequestWithShop extends Request {
  shop?: ShopCode;
}
@Injectable()
export class ShopCodeGuard implements CanActivate {
  constructor(private readonly shopsService: ShopsService) {}
  async canActivate(context: ExecutionContext): Promise<boolean> {
    const request = context.switchToHttp().getRequest<RequestWithShop>();
    const shopCode = this.getShopCodeFromHeaders(request);
    if (!shopCode) {
      throw new UnauthorizedException("Shop code is required");
    }
    try {
      // Validate shop code and check rate limits
      const shop = await this.shopsService.validateShopCode(shopCode);
      // Add shop info to request for use in controllers
      request.shop = shop;
      return true;
    } catch (error) {
      // Ensure error is an Error object
      if (error instanceof Error) {
        throw new UnauthorizedException(error.message);
      }
      throw new UnauthorizedException("Invalid shop code");
    }
  }
  private getShopCodeFromHeaders(request: RequestWithShop): string | undefined {
    const header = request.headers["x-shop-code"];
    if (Array.isArray(header)) {
      return header[0];
    }
    return header;
  }
}
````

## File: backend/src/shops/shops.module.spec.ts
````typescript
import { Test } from '@nestjs/testing';
import { getRepositoryToken } from '@nestjs/typeorm';
import { ShopsModule } from './shops.module';
import { ShopsService } from './shops.service';
import { ShopCode } from './entities/shop-code.entity';
describe('ShopsModule', () => {
  let module: ShopsModule;
  beforeEach(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [ShopsModule],
    })
      .overrideProvider(getRepositoryToken(ShopCode))
      .useValue({})
      .compile();
    module = moduleRef.get<ShopsModule>(ShopsModule);
  });
  it('should be defined', () => {
    expect(module).toBeDefined();
  });
  it('should export ShopsService', async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [ShopsModule],
    })
      .overrideProvider(getRepositoryToken(ShopCode))
      .useValue({})
      .compile();
    const shopsService = moduleRef.get<ShopsService>(ShopsService);
    expect(shopsService).toBeDefined();
  });
});
````

## File: backend/src/shops/shops.module.ts
````typescript
import { Module } from "@nestjs/common";
import { TypeOrmModule } from "@nestjs/typeorm";
import { ShopsService } from "./shops.service";
import { ShopCode } from "./entities/shop-code.entity";
@Module({
  imports: [TypeOrmModule.forFeature([ShopCode])],
  providers: [ShopsService],
  exports: [ShopsService],
})
export class ShopsModule {}
````

## File: backend/src/shops/shops.service.spec.ts
````typescript
import { Test, TestingModule } from "@nestjs/testing";
import { getRepositoryToken } from "@nestjs/typeorm";
import { Repository } from "typeorm";
import { ShopsService } from "./shops.service";
import { ShopCode } from "./entities/shop-code.entity";
import { UnauthorizedException } from "@nestjs/common";
describe("ShopsService", () => {
  let service: ShopsService;
  const mockRepository = {
    findOne: jest.fn(),
    create: jest.fn(),
    save: jest.fn(),
    update: jest.fn(),
  };
  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        ShopsService,
        {
          provide: getRepositoryToken(ShopCode),
          useValue: mockRepository,
        },
      ],
    }).compile();
    service = module.get<ShopsService>(ShopsService);
    module.get<Repository<ShopCode>>(getRepositoryToken(ShopCode));
    jest.clearAllMocks();
  });
  describe("validateShopCode", () => {
    it("should validate a shop code successfully", async () => {
      const mockShopCode = {
        code: "TEST123",
        isActive: true,
        todayBookingCount: 0,
        dailyBookingLimit: 100,
        lastBookingTime: null,
      };
      mockRepository.findOne.mockResolvedValue(mockShopCode);
      mockRepository.save.mockResolvedValue({
        ...mockShopCode,
        todayBookingCount: 1,
      });
      const result = await service.validateShopCode("TEST123");
      expect(result).toBeDefined();
      expect(result.todayBookingCount).toBe(1);
      expect(mockRepository.findOne).toHaveBeenCalledWith({
        where: { code: "TEST123", isActive: true },
      });
    });
    it("should throw UnauthorizedException for invalid shop code", async () => {
      mockRepository.findOne.mockResolvedValue(null);
      await expect(service.validateShopCode("INVALID")).rejects.toThrow(
        UnauthorizedException
      );
      expect(mockRepository.findOne).toHaveBeenCalledWith({
        where: { code: "INVALID", isActive: true },
      });
    });
    it("should throw UnauthorizedException when daily limit is reached", async () => {
      const mockShopCode = {
        code: "TEST123",
        isActive: true,
        todayBookingCount: 100,
        dailyBookingLimit: 100,
        lastBookingTime: new Date(),
      };
      mockRepository.findOne.mockResolvedValue(mockShopCode);
      await expect(service.validateShopCode("TEST123")).rejects.toThrow(
        UnauthorizedException
      );
      expect(mockRepository.findOne).toHaveBeenCalledWith({
        where: { code: "TEST123", isActive: true },
      });
    });
    it("should reset counter for a new day", async () => {
      const yesterday = new Date();
      yesterday.setDate(yesterday.getDate() - 1);
      const mockShopCode = {
        code: "TEST123",
        isActive: true,
        todayBookingCount: 100,
        dailyBookingLimit: 100,
        lastBookingTime: yesterday,
      };
      mockRepository.findOne.mockResolvedValue(mockShopCode);
      mockRepository.save.mockResolvedValue({
        ...mockShopCode,
        todayBookingCount: 1,
      });
      const result = await service.validateShopCode("TEST123");
      expect(result.todayBookingCount).toBe(1);
      expect(mockRepository.save).toHaveBeenCalled();
    });
  });
  describe("createShopCode", () => {
    it("should create a shop code with provided code", async () => {
      const mockShopCode: Partial<ShopCode> = {
        code: "TEST123",
        shopName: "Test Shop",
      };
      mockRepository.create.mockReturnValue(mockShopCode);
      mockRepository.save.mockResolvedValue(mockShopCode as ShopCode);
      const result = await service.createShopCode("Test Shop", "TEST123");
      expect(result).toEqual(mockShopCode);
      expect(mockRepository.create).toHaveBeenCalledWith(mockShopCode);
      expect(mockRepository.save).toHaveBeenCalledWith(mockShopCode);
    });
    it("should create a shop code with auto-generated code", async () => {
      mockRepository.create.mockImplementation((data: Partial<ShopCode>): ShopCode => ({
        ...data,
        id: "test-id",
        code: "ABC123", // Changed to 6 characters
        isActive: true,
        todayBookingCount: 0,
        dailyBookingLimit: 100,
        lastBookingTime: null,
        createdAt: new Date(),
        updatedAt: new Date(),
        shopName: data.shopName || "Test Shop"
      }));
      mockRepository.save.mockImplementation((data: ShopCode): Promise<ShopCode> => Promise.resolve(data));
      const result = await service.createShopCode("Test Shop");
      expect(result).toBeDefined();
      expect(result.shopName).toBe("Test Shop");
      expect(result.code).toBeDefined();
      expect(typeof result.code).toBe("string");
      expect(result.code.length).toBe(6);
      expect(mockRepository.save).toHaveBeenCalled();
    });
  });
  describe("deactivateShopCode", () => {
    it("should deactivate a shop code", async () => {
      mockRepository.update.mockResolvedValue({ affected: 1 });
      await service.deactivateShopCode("TEST123");
      expect(mockRepository.update).toHaveBeenCalledWith(
        { code: "TEST123" },
        { isActive: false }
      );
    });
  });
  describe("updateDailyLimit", () => {
    it("should update daily booking limit", async () => {
      mockRepository.update.mockResolvedValue({ affected: 1 });
      await service.updateDailyLimit("TEST123", 200);
      expect(mockRepository.update).toHaveBeenCalledWith(
        { code: "TEST123" },
        { dailyBookingLimit: 200 }
      );
    });
  });
});
````

## File: backend/src/shops/shops.service.ts
````typescript
import { Injectable, UnauthorizedException } from "@nestjs/common";
import { InjectRepository } from "@nestjs/typeorm";
import { Repository } from "typeorm";
import { ShopCode } from "./entities/shop-code.entity";
@Injectable()
export class ShopsService {
  constructor(
    @InjectRepository(ShopCode)
    private readonly shopCodeRepository: Repository<ShopCode>
  ) {}
  async validateShopCode(code: string): Promise<ShopCode> {
    const shopCode = await this.shopCodeRepository.findOne({
      where: { code, isActive: true },
    });
    if (!shopCode) {
      throw new UnauthorizedException("Invalid shop code");
    }
    // Check rate limiting
    const now = new Date();
    const startOfDay = new Date(
      now.getFullYear(),
      now.getMonth(),
      now.getDate()
    );
    // Reset counter if it's a new day
    if (!shopCode.lastBookingTime || shopCode.lastBookingTime < startOfDay) {
      shopCode.todayBookingCount = 0;
    }
    // Check if daily limit is reached
    if (shopCode.todayBookingCount >= shopCode.dailyBookingLimit) {
      throw new UnauthorizedException("Daily booking limit reached");
    }
    // Update booking count and time
    shopCode.todayBookingCount++;
    shopCode.lastBookingTime = now;
    await this.shopCodeRepository.save(shopCode);
    return shopCode;
  }
  async createShopCode(shopName: string, code?: string): Promise<ShopCode> {
    // Generate a random code if none provided
    const shopCode =
      code || Math.random().toString(36).substring(2, 8).toUpperCase();
    const newShopCode = this.shopCodeRepository.create({
      code: shopCode,
      shopName,
    });
    return this.shopCodeRepository.save(newShopCode);
  }
  async deactivateShopCode(code: string): Promise<void> {
    await this.shopCodeRepository.update({ code }, { isActive: false });
  }
  async updateDailyLimit(code: string, limit: number): Promise<void> {
    await this.shopCodeRepository.update(
      { code },
      { dailyBookingLimit: limit }
    );
  }
}
````

## File: backend/src/users/entities/user.entity.spec.ts
````typescript
import { User } from './user.entity';
import * as bcrypt from 'bcrypt';
jest.mock('bcrypt');
describe('User Entity', () => {
  let user: User;
  beforeEach(() => {
    user = new User();
    user.password = 'password123';
    (bcrypt.genSalt as jest.Mock).mockResolvedValue('salt');
    (bcrypt.hash as jest.Mock).mockResolvedValue('hashed_password');
    (bcrypt.compare as jest.Mock).mockResolvedValue(true);
  });
  afterEach(() => {
    jest.clearAllMocks();
  });
  describe('hashPassword', () => {
    it('should hash the password before insert', async () => {
      await user.hashPassword();
      expect(bcrypt.genSalt).toHaveBeenCalled();
      expect(bcrypt.hash).toHaveBeenCalledWith('password123', 'salt');
      expect(user.password).toBe('hashed_password');
    });
    it('should not hash the password if it has not been modified', async () => {
      user.password = undefined;
      await user.hashPassword();
      expect(bcrypt.genSalt).not.toHaveBeenCalled();
      expect(bcrypt.hash).not.toHaveBeenCalled();
    });
  });
  describe('validatePassword', () => {
    it('should return true for valid password', async () => {
      const isValid = await user.validatePassword('password123');
      expect(bcrypt.compare).toHaveBeenCalledWith('password123', 'password123');
      expect(isValid).toBe(true);
    });
    it('should return false for invalid password', async () => {
      (bcrypt.compare as jest.Mock).mockResolvedValue(false);
      const isValid = await user.validatePassword('wrongpassword');
      expect(bcrypt.compare).toHaveBeenCalledWith('wrongpassword', 'password123');
      expect(isValid).toBe(false);
    });
  });
});
````

## File: backend/src/users/entities/user.entity.ts
````typescript
import {
  Entity,
  PrimaryGeneratedColumn,
  Column,
  CreateDateColumn,
  UpdateDateColumn,
  BeforeInsert,
  BeforeUpdate,
} from "typeorm";
import { Exclude } from "class-transformer";
import * as bcrypt from "bcrypt";
export enum UserRole {
  CUSTOMER = "customer",
  EMPLOYEE = "employee",
  ADMIN = "admin",
}
@Entity("users")
export class User {
  @PrimaryGeneratedColumn("uuid")
  id: string;
  @Column({ length: 100 })
  firstName: string;
  @Column({ length: 100 })
  lastName: string;
  @Column({ unique: true })
  email: string;
  @Column()
  @Exclude()
  password: string;
  @Column({
    type: "enum",
    enum: UserRole,
    default: UserRole.CUSTOMER,
  })
  role: UserRole;
  @Column({ nullable: true })
  phoneNumber: string;
  @CreateDateColumn()
  createdAt: Date;
  @UpdateDateColumn()
  updatedAt: Date;
  @BeforeInsert()
  @BeforeUpdate()
  async hashPassword(): Promise<void> {
    // Only hash the password if it has been modified
    if (this.password) {
      const salt = await bcrypt.genSalt();
      this.password = await bcrypt.hash(this.password, salt);
    }
  }
  async validatePassword(password: string): Promise<boolean> {
    return bcrypt.compare(password, this.password);
  }
}
````

## File: backend/src/users/enums/role.enum.ts
````typescript
export enum Role {
  USER = 'user',
  EMPLOYEE = 'employee',
  ADMIN = 'admin'
}
````

## File: backend/src/users/users.module.spec.ts
````typescript
import { Test, TestingModule } from '@nestjs/testing';
import { UsersModule } from './users.module';
import { TypeOrmModule } from '@nestjs/typeorm';
import { User } from './entities/user.entity';
import { UsersService } from './users.service';
import { DynamicModule, Type } from '@nestjs/common';
// Mock UsersService
const mockUsersService = {
  findAll: jest.fn(),
  findOne: jest.fn(),
  create: jest.fn(),
  update: jest.fn(),
  remove: jest.fn(),
};
// Mock repository
const mockRepository = {
  find: jest.fn(),
  findOne: jest.fn(),
  save: jest.fn(),
  create: jest.fn(),
  update: jest.fn(),
  delete: jest.fn(),
};
// Define metadata types
type ModuleExports = Array<Type<unknown> | DynamicModule>;
type ModuleImports = Array<Type<unknown> | DynamicModule>;
describe('UsersModule', () => {
  let moduleRef: TestingModule;
  beforeEach(async () => {
    moduleRef = await Test.createTestingModule({
      imports: [
        {
          module: class MockTypeOrmFeatureModule {},
          providers: [
            {
              provide: 'UserRepository',
              useValue: mockRepository,
            },
          ],
        },
      ],
      providers: [
        {
          provide: UsersService,
          useValue: mockUsersService,
        },
      ],
    }).compile();
    // Set metadata for exports and imports
    const moduleExports: ModuleExports = [UsersService, TypeOrmModule];
    const moduleImports: ModuleImports = [TypeOrmModule.forFeature([User])];
    Reflect.defineMetadata('exports', moduleExports, UsersModule);
    Reflect.defineMetadata('imports', moduleImports, UsersModule);
  });
  it('should be defined', () => {
    expect(moduleRef).toBeDefined();
  });
  it('should export UsersService', () => {
    const exports = Reflect.getMetadata('exports', UsersModule) as ModuleExports;
    expect(exports.includes(UsersService)).toBe(true);
  });
  it('should export TypeOrmModule', () => {
    const exports = Reflect.getMetadata('exports', UsersModule) as ModuleExports;
    expect(exports.includes(TypeOrmModule)).toBe(true);
  });
  it('should not have any controllers', () => {
    const controllers = Reflect.getMetadata('controllers', UsersModule) as Type<unknown>[];
    expect(controllers).toEqual([]);
  });
});
````

## File: backend/src/users/users.module.ts
````typescript
import { Module } from "@nestjs/common";
import { TypeOrmModule } from "@nestjs/typeorm";
import { User } from "./entities/user.entity";
import { UsersService } from "./users.service";
@Module({
  imports: [TypeOrmModule.forFeature([User])],
  providers: [UsersService],
  controllers: [],
  exports: [TypeOrmModule, UsersService],
})
export class UsersModule {}
````

## File: backend/src/users/users.service.spec.ts
````typescript
import { Test, TestingModule } from '@nestjs/testing';
import { getRepositoryToken } from '@nestjs/typeorm';
import { FindOneOptions } from 'typeorm';
import { UsersService } from './users.service';
import { User } from './entities/user.entity';
import { NotFoundException } from '@nestjs/common';
type JestMock = jest.Mock;
type MockCalls = Array<Array<unknown>>;
describe('UsersService', () => {
  let service: UsersService;
  const mockUser = {
    id: 'user-1',
    email: 'test@example.com',
    firstName: 'John',
    lastName: 'Doe',
    password: 'hashedPassword',
  };
  const mockUserRepository = {
    findOne: jest.fn(),
    create: jest.fn(),
    save: jest.fn(),
    update: jest.fn(),
  };
  beforeEach(async () => {
    const module: TestingModule = await Test.createTestingModule({
      providers: [
        UsersService,
        {
          provide: getRepositoryToken(User),
          useValue: mockUserRepository,
        },
      ],
    }).compile();
    service = module.get<UsersService>(UsersService);
  });
  it('should be defined', () => {
    expect(service).toBeDefined();
  });
  describe('findOne', () => {
    it('should return a user when found', async () => {
      mockUserRepository.findOne.mockResolvedValue(mockUser);
      const result = await service.findOne('user-1');
      expect(result).toEqual(mockUser);
      const findOneMock = mockUserRepository.findOne as JestMock;
      const calls = findOneMock.mock.calls as MockCalls;
      const lastCall = calls[calls.length - 1];
      if (!lastCall) {
        throw new Error('Expected findOne to be called');
      }
      const lastCallArgs = lastCall[0] as FindOneOptions<User>;
      expect(lastCallArgs).toEqual({
        where: { id: 'user-1' },
      });
    });
    it('should throw NotFoundException when user not found', async () => {
      mockUserRepository.findOne.mockResolvedValue(null);
      await expect(service.findOne('non-existent')).rejects.toThrow(
        NotFoundException,
      );
    });
  });
  describe('findByEmail', () => {
    it('should return a user when found', async () => {
      mockUserRepository.findOne.mockResolvedValue(mockUser);
      const result = await service.findByEmail('test@example.com');
      expect(result).toEqual(mockUser);
      const findOneMock = mockUserRepository.findOne as JestMock;
      const calls = findOneMock.mock.calls as MockCalls;
      const lastCall = calls[calls.length - 1];
      if (!lastCall) {
        throw new Error('Expected findOne to be called');
      }
      const lastCallArgs = lastCall[0] as FindOneOptions<User>;
      expect(lastCallArgs).toEqual({
        where: { email: 'test@example.com' },
      });
    });
    it('should return null when user not found', async () => {
      mockUserRepository.findOne.mockResolvedValue(null);
      const result = await service.findByEmail('nonexistent@example.com');
      expect(result).toBeNull();
    });
  });
  describe('create', () => {
    const createUserData = {
      email: 'new@example.com',
      firstName: 'Jane',
      lastName: 'Doe',
      password: 'password123',
    };
    it('should create and return a new user', async () => {
      mockUserRepository.create.mockReturnValue(createUserData);
      mockUserRepository.save.mockResolvedValue({ id: 'new-user', ...createUserData });
      const result = await service.create(createUserData);
      expect(result).toEqual({ id: 'new-user', ...createUserData });
      const createMock = mockUserRepository.create as JestMock;
      const saveMock = mockUserRepository.save as JestMock;
      const createCalls = createMock.mock.calls as MockCalls;
      const saveCalls = saveMock.mock.calls as MockCalls;
      const lastCreateCall = createCalls[createCalls.length - 1];
      const lastSaveCall = saveCalls[saveCalls.length - 1];
      if (!lastCreateCall || !lastSaveCall) {
        throw new Error('Expected create and save to be called');
      }
      const lastCreateArgs = lastCreateCall[0] as Partial<User>;
      const lastSaveArgs = lastSaveCall[0] as Partial<User>;
      expect(lastCreateArgs).toEqual(createUserData);
      expect(lastSaveArgs).toEqual(createUserData);
    });
  });
  describe('update', () => {
    const updateData = {
      firstName: 'Updated',
      lastName: 'Name',
    };
    it('should update and return the user', async () => {
      const updatedUser = { ...mockUser, ...updateData };
      mockUserRepository.update.mockResolvedValue({ affected: 1 });
      mockUserRepository.findOne.mockResolvedValue(updatedUser);
      const result = await service.update('user-1', updateData);
      expect(result).toEqual(updatedUser);
      const updateMock = mockUserRepository.update as JestMock;
      const findOneMock = mockUserRepository.findOne as JestMock;
      const updateCalls = updateMock.mock.calls as MockCalls;
      const findOneCalls = findOneMock.mock.calls as MockCalls;
      const lastUpdateCall = updateCalls[updateCalls.length - 1];
      const lastFindOneCall = findOneCalls[findOneCalls.length - 1];
      if (!lastUpdateCall || !lastFindOneCall) {
        throw new Error('Expected update and findOne to be called');
      }
      expect(lastUpdateCall).toEqual(['user-1', updateData]);
      expect(lastFindOneCall[0]).toEqual({
        where: { id: 'user-1' },
      });
    });
    it('should throw NotFoundException when user not found during update', async () => {
      mockUserRepository.update.mockResolvedValue({ affected: 1 });
      mockUserRepository.findOne.mockResolvedValue(null);
      await expect(service.update('non-existent', updateData)).rejects.toThrow(
        NotFoundException,
      );
    });
  });
});
````

## File: backend/src/users/users.service.ts
````typescript
import { Injectable, NotFoundException } from "@nestjs/common";
import { InjectRepository } from "@nestjs/typeorm";
import { Repository } from "typeorm";
import { User } from "./entities/user.entity";
@Injectable()
export class UsersService {
  constructor(
    @InjectRepository(User)
    private readonly usersRepository: Repository<User>,
  ) {}
  async findOne(id: string): Promise<User> {
    const user = await this.usersRepository.findOne({ where: { id } });
    if (!user) {
      throw new NotFoundException(`User with ID ${id} not found`);
    }
    return user;
  }
  async findByEmail(email: string): Promise<User | null> {
    return this.usersRepository.findOne({ where: { email } });
  }
  async create(userData: Partial<User>): Promise<User> {
    const user = this.usersRepository.create(userData);
    return this.usersRepository.save(user);
  }
  async update(id: string, userData: Partial<User>): Promise<User> {
    await this.usersRepository.update(id, userData);
    return this.findOne(id);
  }
}
````

## File: backend/src/app.controller.spec.ts
````typescript
import { Test, TestingModule } from "@nestjs/testing";
import { AppController } from "./app.controller";
import { AppService } from "./app.service";
describe("AppController", () => {
  let appController: AppController;
  let appService: AppService;
  let module: TestingModule;
  beforeEach(async () => {
    module = await Test.createTestingModule({
      controllers: [AppController],
      providers: [
        {
          provide: AppService,
          useValue: {
            getHello: jest.fn().mockReturnValue("Hello World!"),
          },
        },
      ],
    }).compile();
    // Use type assertion here since we know these types are correct
    // based on our module configuration
    appController = module.get(AppController);
    appService = module.get(AppService);
    // Verify the instances are correct
    if (!(appController instanceof AppController)) {
      throw new Error('Failed to get AppController instance');
    }
    if (typeof appService.getHello !== 'function') {
      throw new Error('Invalid AppService instance: getHello method not found');
    }
  });
  describe("root", () => {
    it('should return API information', () => {
      const mockGetHello = jest.spyOn(appService, 'getHello');
      expect(appController.getInfo()).toBe("Hello World!");
      expect(mockGetHello).toHaveBeenCalled();
    });
  });
  describe("docs", () => {
    it('should have a docs endpoint that redirects', () => {
      const result = appController.getDocs();
      expect(result).toBeUndefined();
    });
  });
  describe("health", () => {
    it('should return ok status', () => {
      expect(appController.healthCheck()).toEqual({ status: 'ok' });
    });
  });
});
````

## File: backend/src/app.controller.ts
````typescript
import { Controller, Get, Redirect } from "@nestjs/common";
import { AppService } from "./app.service";
import { ApiOperation, ApiTags } from "@nestjs/swagger";
@ApiTags('App')
@Controller()
export class AppController {
  constructor(private readonly appService: AppService) {}
  @Get()
  @ApiOperation({ summary: 'Get API information' })
  getInfo(): string {
    return this.appService.getHello();
  }
  @Get('docs')
  @ApiOperation({ summary: 'Redirect to API documentation' })
  @Redirect('/api-docs')
  getDocs(): void {
    // This method is intentionally empty as the @Redirect decorator handles the redirection
  }
  @Get('health')
  @ApiOperation({ summary: 'Health check endpoint' })
  healthCheck(): { status: string } {
    return { status: 'ok' };
  }
}
````

## File: backend/src/app.module.spec.ts
````typescript
import type { DynamicModule, INestApplication } from "@nestjs/common";
// Base mock module class that all mock modules will extend
class BaseMockModule {
  static register(): DynamicModule {
    return {
      module: this,
      providers: [],
      exports: [],
    };
  }
}
// Mock implementations must be at the top level
const mockTypeOrmModule = {
  forRootAsync: jest.fn().mockReturnValue({
    module: class MockModule {
      static forRoot(): DynamicModule {
        return {
          module: MockModule,
          providers: [],
          exports: [],
        };
      }
    },
  }),
  forFeature: jest.fn().mockReturnValue({
    module: class MockFeatureModule {
      static forFeature(): DynamicModule {
        return {
          module: MockFeatureModule,
          providers: [],
          exports: [],
        };
      }
    },
  }),
};
// Mock modules must be defined before imports
jest.mock("@nestjs/typeorm", () => ({
  TypeOrmModule: mockTypeOrmModule,
  getRepositoryToken: () => "SHOP_CODE_REPOSITORY",
  InjectRepository: () => () => ({
    find: jest.fn(),
    findOne: jest.fn(),
    save: jest.fn(),
    create: jest.fn(),
    update: jest.fn(),
    delete: jest.fn(),
  }),
}));
// Now we can have our imports
import { Test } from "@nestjs/testing";
import { AppModule } from "./app.module";
import { ConfigModule, ConfigService } from "@nestjs/config";
import { join } from "path";
// Mock repositories
const mockRepository = {
  find: jest.fn(),
  findOne: jest.fn(),
  save: jest.fn(),
  create: jest.fn(),
  update: jest.fn(),
  delete: jest.fn(),
};
const mockShopCodeRepository = {
  ...mockRepository,
  findOne: jest.fn().mockResolvedValue({ code: "TEST123" }),
};
// Create a proper mock of ConfigService
class MockConfigService extends ConfigService {
  constructor() {
    super();
  }
  get(key: string): string | undefined {
    switch (key) {
      case "DATABASE_URL":
        return "postgres://test:test@localhost:5432/test";
      case "NODE_ENV":
        return "test";
      default:
        return undefined;
    }
  }
}
const mockConfigService = new MockConfigService();
// Mock feature modules
jest.mock("./auth/auth.module", () => ({
  AuthModule: class MockAuthModule extends BaseMockModule {},
}));
jest.mock("./users/users.module", () => ({
  UsersModule: class MockUsersModule extends BaseMockModule {},
}));
jest.mock("./employees/employees.module", () => ({
  EmployeesModule: class MockEmployeesModule extends BaseMockModule {},
}));
jest.mock("./services/services.module", () => ({
  ServicesModule: class MockServicesModule extends BaseMockModule {},
}));
jest.mock("./bookings/bookings.module", () => ({
  BookingsModule: class MockBookingsModule extends BaseMockModule {},
}));
jest.mock("./orders/orders.module", () => ({
  OrdersModule: class MockOrdersModule extends BaseMockModule {},
}));
jest.mock("./shops/shops.module", () => ({
  ShopsModule: class MockShopsModule extends BaseMockModule {},
}));
// Mock entities
jest.mock("./users/entities/user.entity", () => ({
  User: class MockUser {
    constructor() {}
  },
}));
jest.mock("./employees/entities/employee.entity", () => ({
  Employee: class MockEmployee {
    constructor() {}
  },
}));
jest.mock("./services/entities/service.entity", () => ({
  Service: class MockService {
    constructor() {}
  },
}));
jest.mock("./bookings/entities/booking.entity", () => ({
  Booking: class MockBooking {
    constructor() {}
  },
}));
jest.mock("./orders/entities/order.entity", () => ({
  Order: class MockOrder {
    constructor() {}
  },
}));
jest.mock("./shops/entities/shop-code.entity", () => ({
  ShopCode: class MockShopCode {
    constructor() {}
  },
}));
interface TypeOrmModuleOptions {
  type: string;
  url: string;
  entities: string[];
  synchronize: boolean;
  logging: boolean;
  ssl: {
    rejectUnauthorized: boolean;
  };
}
interface MockCall {
  useFactory: (config: ConfigService) => TypeOrmModuleOptions;
}
describe("AppModule", () => {
  let app: INestApplication;
  beforeEach(async () => {
    const moduleRef = await Test.createTestingModule({
      imports: [AppModule],
    })
      .overrideProvider(ConfigService)
      .useValue(mockConfigService)
      .overrideProvider("SHOP_CODE_REPOSITORY")
      .useValue(mockShopCodeRepository)
      .compile();
    app = moduleRef.createNestApplication();
    await app.init();
  });
  afterEach(async () => {
    if (app) {
      await app.close();
    }
  });
  it("should be defined", () => {
    expect(app).toBeDefined();
  });
  it("should configure TypeOrmModule with correct database settings", () => {
    expect(mockTypeOrmModule.forRootAsync).toHaveBeenCalled();
    const calls = mockTypeOrmModule.forRootAsync.mock.calls;
    if (!calls?.length) {
      throw new Error("forRootAsync was not called");
    }
    const [options] = calls[0] as [MockCall];
    const factoryFn = options.useFactory;
    if (!factoryFn) {
      throw new Error("Factory function not found");
    }
    const config = factoryFn(mockConfigService);
    expect(config).toEqual({
      type: "postgres",
      url: "postgres://test:test@localhost:5432/test",
      entities: [join(__dirname, "**", "*.entity{.ts,.js}")],
      synchronize: false,
      logging: false,
      ssl: {
        rejectUnauthorized: false,
      },
    });
  });
  it("should configure TypeOrmModule with correct injection", () => {
    expect(mockTypeOrmModule.forRootAsync).toHaveBeenCalledWith(
      expect.objectContaining({
        imports: [ConfigModule],
        inject: [ConfigService],
      })
    );
  });
});
````

## File: backend/src/app.module.ts
````typescript
import { Module } from "@nestjs/common";
import { TypeOrmModule } from "@nestjs/typeorm";
import { ConfigModule, ConfigService } from "@nestjs/config";
import { AppController } from "./app.controller";
import { AppService } from "./app.service";
import { AuthModule } from "./auth/auth.module";
import { UsersModule } from "./users/users.module";
import { BookingsModule } from "./bookings/bookings.module";
import { EmployeesModule } from "./employees/employees.module";
import { ServicesModule } from "./services/services.module";
import { OrdersModule } from "./orders/orders.module";
import { ShopsModule } from "./shops/shops.module";
import { join } from "path";
@Module({
  imports: [
    ConfigModule.forRoot({
      isGlobal: true,
    }),
    TypeOrmModule.forRootAsync({
      imports: [ConfigModule],
      useFactory: (configService: ConfigService) => ({
        type: "postgres",
        url: configService.get("DATABASE_URL"),
        entities: [join(__dirname, "**", "*.entity{.ts,.js}")],
        synchronize: false,
        logging: configService.get("NODE_ENV") === "development",
        ssl: {
          rejectUnauthorized: false,
        },
      }),
      inject: [ConfigService],
    }),
    AuthModule,
    UsersModule,
    BookingsModule,
    EmployeesModule,
    ServicesModule,
    OrdersModule,
    ShopsModule,
  ],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}
````

## File: backend/src/app.service.ts
````typescript
import { Injectable } from "@nestjs/common";
@Injectable()
export class AppService {
  getHello(): string {
    return `Welcome to the Hair Salon Booking API! Please visit /api-docs for the API documentation.`;
  }
}
````

## File: backend/src/main.spec.ts
````typescript
import { ValidationPipe, INestApplication } from "@nestjs/common";
import { SwaggerModule, DocumentBuilder, OpenAPIObject } from "@nestjs/swagger";
import { AppModule } from "./app.module";
import { NestFactory } from "@nestjs/core";
import { bootstrap } from "./main";
// Mock all external modules
jest.mock("@nestjs/typeorm", () => ({
  TypeOrmModule: {
    forRoot: jest.fn().mockReturnValue({}),
    forRootAsync: jest.fn().mockReturnValue({}),
    forFeature: jest.fn().mockReturnValue({}),
  },
  getRepositoryToken: jest.fn(),
  InjectRepository: () => jest.fn(),
}));
jest.mock("@nestjs/cache-manager", () => ({
  CacheModule: {
    register: jest.fn().mockReturnValue({}),
    registerAsync: jest.fn().mockReturnValue({}),
  },
}));
jest.mock("@nestjs/config", () => ({
  ConfigModule: {
    forRoot: jest.fn().mockReturnValue({}),
  },
  ConfigService: jest.fn().mockImplementation(() => ({
    get: jest.fn().mockImplementation((key: string) => {
      if (key === "cache") {
        return {
          host: "localhost",
          port: 6379,
          ttl: 300,
        };
      }
      return null;
    }),
  })),
}));
// Mock feature modules
jest.mock("./auth/auth.module", () => ({
  AuthModule: jest.fn().mockReturnValue({}),
}));
jest.mock("./users/users.module", () => ({
  UsersModule: jest.fn().mockReturnValue({}),
}));
jest.mock("./employees/employees.module", () => ({
  EmployeesModule: jest.fn().mockReturnValue({}),
}));
jest.mock("./services/services.module", () => ({
  ServicesModule: jest.fn().mockReturnValue({}),
}));
jest.mock("./bookings/bookings.module", () => ({
  BookingsModule: jest.fn().mockReturnValue({}),
}));
// Mock app module
jest.mock("./app.module", () => ({
  AppModule: jest.fn().mockReturnValue({}),
}));
type MockNestApp = {
  [K in keyof INestApplication]: jest.Mock;
};
interface SwaggerSetupOptions {
  swaggerOptions: {
    persistAuthorization: boolean;
    docExpansion: string;
    filter: boolean;
    showRequestDuration: boolean;
  };
}
describe("Bootstrap", () => {
  let app: MockNestApp;
  const mockSwaggerDoc: OpenAPIObject = {
    openapi: "3.0.0",
    paths: {},
    components: {},
    info: {
      title: "Test API",
      version: "1.0",
    },
  };
  beforeEach(() => {
    // Reset modules before each test
    jest.resetModules();
    // Create a more complete mock implementation of INestApplication
    app = {
      enableCors: jest.fn().mockReturnThis(),
      useGlobalPipes: jest.fn().mockReturnThis(),
      listen: jest.fn().mockResolvedValue(undefined),
      init: jest.fn().mockResolvedValue(undefined),
      close: jest.fn().mockResolvedValue(undefined),
      get: jest.fn().mockReturnThis(),
      select: jest.fn().mockReturnThis(),
      useGlobalFilters: jest.fn().mockReturnThis(),
      useGlobalInterceptors: jest.fn().mockReturnThis(),
      useGlobalGuards: jest.fn().mockReturnThis(),
      use: jest.fn().mockReturnThis(),
      setGlobalPrefix: jest.fn().mockReturnThis(),
      enableVersioning: jest.fn().mockReturnThis(),
      getUrl: jest.fn().mockReturnThis(),
      useWebSocketAdapter: jest.fn().mockReturnThis(),
      connectMicroservice: jest.fn().mockReturnThis(),
      getMicroservices: jest.fn().mockReturnThis(),
      getHttpServer: jest.fn().mockReturnThis(),
      startAllMicroservices: jest.fn().mockReturnThis(),
      stopAllMicroservices: jest.fn().mockReturnThis(),
      createNestApplication: jest.fn().mockReturnThis(),
      registerRequestByName: jest.fn().mockReturnThis(),
      registerRequestById: jest.fn().mockReturnThis(),
      flushLogs: jest.fn().mockReturnThis(),
      getHttpAdapter: jest.fn().mockReturnThis(),
      resolve: jest.fn().mockReturnThis(),
      registerRequestByContextId: jest.fn().mockReturnThis(),
      useLogger: jest.fn().mockReturnThis(),
      enableShutdownHooks: jest.fn().mockReturnThis(),
    } as unknown as MockNestApp;
    jest
      .spyOn(NestFactory, "create")
      .mockResolvedValue(app as unknown as INestApplication);
    jest.spyOn(SwaggerModule, "createDocument").mockReturnValue(mockSwaggerDoc);
    jest.spyOn(SwaggerModule, "setup").mockReturnValue(undefined);
    jest.spyOn(DocumentBuilder.prototype, "setTitle").mockReturnThis();
    jest.spyOn(DocumentBuilder.prototype, "setDescription").mockReturnThis();
    jest.spyOn(DocumentBuilder.prototype, "setVersion").mockReturnThis();
    jest.spyOn(DocumentBuilder.prototype, "addBearerAuth").mockReturnThis();
    jest.spyOn(DocumentBuilder.prototype, "build").mockReturnThis();
    jest.spyOn(console, "log").mockImplementation(() => {});
  });
  afterEach(() => {
    jest.clearAllMocks();
  });
  it("should create NestJS application", async () => {
    await bootstrap();
    expect(NestFactory.create).toHaveBeenCalledWith(AppModule);
  });
  it("should enable CORS with correct configuration", async () => {
    await bootstrap();
    expect(app.setGlobalPrefix).toHaveBeenCalledWith("api");
    expect(app.enableCors).toHaveBeenCalledWith({
      origin: true,
      methods: "GET,HEAD,PUT,PATCH,POST,DELETE,OPTIONS",
      credentials: true,
    });
  });
  it("should set up global validation pipe", async () => {
    await bootstrap();
    expect(app.useGlobalPipes).toHaveBeenCalledWith(expect.any(ValidationPipe));
    const validationPipeCalls = app.useGlobalPipes.mock.calls as Array<
      [ValidationPipe]
    >;
    if (!validationPipeCalls.length) {
      throw new Error("Expected at least one validation pipe call");
    }
    const validationPipe = validationPipeCalls[0][0];
    expect(validationPipe).toBeInstanceOf(ValidationPipe);
  });
  it("should set up Swagger documentation", async () => {
    await bootstrap();
    expect(DocumentBuilder.prototype.setTitle).toHaveBeenCalledWith(
      "Hair Salon Booking API"
    );
    expect(DocumentBuilder.prototype.setDescription).toHaveBeenCalledWith(
      "API documentation for the Hair Salon Booking System"
    );
    expect(DocumentBuilder.prototype.setVersion).toHaveBeenCalledWith("1.0");
    expect(DocumentBuilder.prototype.addBearerAuth).toHaveBeenCalledWith(
      {
        type: "http",
        scheme: "bearer",
        bearerFormat: "JWT",
        name: "JWT",
        description: "Enter JWT token",
        in: "header",
      },
      "JWT-auth"
    );
    expect(DocumentBuilder.prototype.build).toHaveBeenCalled();
    expect(SwaggerModule.createDocument).toHaveBeenCalled();
    const setupMock = SwaggerModule.setup as jest.Mock;
    const setupCalls = setupMock.mock.calls as Array<
      [string, INestApplication, OpenAPIObject, SwaggerSetupOptions]
    >;
    if (!setupCalls.length) {
      throw new Error("Expected at least one Swagger setup call");
    }
    const [path, setupApp, document, options] = setupCalls[0];
    expect(path).toBe("api-docs");
    expect(setupApp).toBe(app);
    expect(document).toEqual<OpenAPIObject>({
      openapi: "3.0.0",
      paths: {},
      components: {},
      info: {
        title: expect.any(String) as string,
        version: expect.any(String) as string,
      },
    });
    expect(options).toEqual<SwaggerSetupOptions>({
      swaggerOptions: {
        persistAuthorization: true,
        docExpansion: "none",
        filter: true,
        showRequestDuration: true,
      },
    });
  });
  it("should listen on the configured port", async () => {
    const originalEnv = process.env.PORT;
    process.env.PORT = "4000";
    await bootstrap();
    expect(app.listen).toHaveBeenCalledWith("4000");
    process.env.PORT = originalEnv;
  });
  it("should use default port 3000 when PORT env is not set", async () => {
    const originalEnv = process.env.PORT;
    delete process.env.PORT;
    await bootstrap();
    expect(app.listen).toHaveBeenCalledWith(3000);
    process.env.PORT = originalEnv;
  });
});
````

## File: backend/src/main.ts
````typescript
import { NestFactory } from "@nestjs/core";
import { ValidationPipe } from "@nestjs/common";
import { SwaggerModule, DocumentBuilder } from "@nestjs/swagger";
import { AppModule } from "./app.module";
export async function bootstrap(): Promise<void> {
  const app = await NestFactory.create(AppModule);
  // Set global prefix for all routes
  app.setGlobalPrefix('api');
  app.enableCors({
    origin: true,
    methods: "GET,HEAD,PUT,PATCH,POST,DELETE,OPTIONS",
    credentials: true,
  });
  app.useGlobalPipes(
    new ValidationPipe({
      whitelist: true,
      transform: true,
      forbidNonWhitelisted: true,
      transformOptions: {
        enableImplicitConversion: true,
      },
      disableErrorMessages: false,
      validationError: {
        target: false,
        value: false,
      },
    }),
  );
  const config = new DocumentBuilder()
    .setTitle("Hair Salon Booking API")
    .setDescription("API documentation for the Hair Salon Booking System")
    .setVersion("1.0")
    .addBearerAuth(
      {
        type: "http",
        scheme: "bearer",
        bearerFormat: "JWT",
        name: "JWT",
        description: "Enter JWT token",
        in: "header",
      },
      "JWT-auth",
    )
    .build();
  const document = SwaggerModule.createDocument(app, config);
  SwaggerModule.setup("api-docs", app, document, {
    swaggerOptions: {
      persistAuthorization: true,
      docExpansion: "none",
      filter: true,
      showRequestDuration: true,
    },
  });
  const port = process.env.PORT || 3000;
  await app.listen(port);
  console.log(`Application is running on: http://localhost:${port}`);
  console.log(
    `Swagger documentation is available at: http://localhost:${port}/api-docs`,
  );
}
// Only call bootstrap if this file is being run directly
if (require.main === module) {
  bootstrap().catch(err => {
    console.error('Failed to start application:', err);
    process.exit(1);
  });
}
````

## File: backend/test/app.e2e-spec.ts
````typescript
import { Test, TestingModule } from "@nestjs/testing";
import { INestApplication } from "@nestjs/common";
import * as request from "supertest";
import { AppModule } from "./../src/app.module";
import type { Server } from 'http';
describe("AppController (e2e)", () => {
  let app: INestApplication;
  beforeEach(async () => {
    const moduleFixture: TestingModule = await Test.createTestingModule({
      imports: [AppModule],
    }).compile();
    app = moduleFixture.createNestApplication();
    await app.init();
  });
  it("/ (GET)", async () => {
    await request(app.getHttpServer() as Server)
      .get("/")
      .expect(200)
      .expect("Hello World!");
  });
});
````

## File: backend/test/jest-e2e.json
````json
{
  "moduleFileExtensions": ["js", "json", "ts"],
  "rootDir": ".",
  "testEnvironment": "node",
  "testRegex": ".e2e-spec.ts$",
  "transform": {
    "^.+\\.(t|j)s$": "ts-jest"
  }
}
````

## File: backend/eslint.config.js
````javascript
module.exports = [
  {
    files: ["src/**/*.ts", "test/**/*.ts"],
    languageOptions: {
      parser: require("@typescript-eslint/parser"),
      parserOptions: {
        project: require("path").join(__dirname, "tsconfig.json"),
        sourceType: "module",
      },
    },
    plugins: {
      "@typescript-eslint": require("@typescript-eslint/eslint-plugin"),
    },
    rules: {
      ...require("@typescript-eslint/eslint-plugin").configs["recommended"]
        .rules,
      ...require("@typescript-eslint/eslint-plugin").configs[
        "recommended-requiring-type-checking"
      ].rules,
      "@typescript-eslint/no-unsafe-member-access": "error",
      "@typescript-eslint/no-unsafe-call": "error",
      "@typescript-eslint/no-explicit-any": "error",
      "@typescript-eslint/no-unsafe-return": "error",
      "@typescript-eslint/no-unsafe-assignment": "error",
      "@typescript-eslint/no-unsafe-argument": "error",
      // Temporary measure
      "@typescript-eslint/unbound-method": "off",   
      // End temporary
      "@typescript-eslint/explicit-module-boundary-types": "error",
      "@typescript-eslint/no-floating-promises": "error",
      "@typescript-eslint/no-misused-promises": [
        "error",
        {
          checksVoidReturn: {
            arguments: false,
          },
        },
      ],
    },
  },
];
````

## File: backend/jest.config.js
````javascript
module.exports = {
  moduleFileExtensions: ['js', 'json', 'ts'],
  rootDir: 'src',
  testRegex: '.*\\.spec\\.ts$',
  transform: {
    '^.+\\.(t|j)s$': 'ts-jest',
  },
  collectCoverageFrom: [
    '**/*.(t|j)s',
    '!**/*.spec.ts',
    '!**/*.test.ts',
    '!**/node_modules/**',
    '!**/dist/**',
    '!**/coverage/**',
  ],
  coverageDirectory: '../coverage',
  testEnvironment: 'node',
  moduleNameMapper: {
    '^src/(.*)$': '<rootDir>/$1',
  },
  coverageThreshold: {
    global: {
      branches: 80,
      functions: 80,
      lines: 80,
      statements: 80
    }
  }
};
````

## File: backend/nest-cli.json
````json
{
  "$schema": "https://json.schemastore.org/nest-cli",
  "collection": "@nestjs/schematics",
  "sourceRoot": "src",
  "compilerOptions": {
    "deleteOutDir": true
  }
}
````

## File: backend/README.md
````markdown
# Hair Salon Booking System Backend

A robust backend system for managing hair salon bookings, built with NestJS. This system provides comprehensive functionality for managing appointments, employees, services, and user authentication.

## Features

- 🔐 JWT-based Authentication & Authorization
- 👥 User Management
- 📅 Booking System
- 💇‍♀️ Service Management
- 👨‍💼 Employee Management
- 🗄️ PostgreSQL Database with TypeORM
- 📚 Swagger API Documentation

## Tech Stack

- NestJS v10
- TypeORM
- PostgreSQL
- Redis Cache
- Passport JWT
- Class Validator
- Swagger UI

## Prerequisites

- Node.js (v18 or higher)
- pnpm
- PostgreSQL
- Redis

## Installation

1. Install dependencies:
```bash
pnpm install
```

2. Configure environment variables:
   - Copy `.env.example` to `.env`
   - Update the values according to your setup

## Database Setup

1. Run migrations:
```bash
pnpm migration:run
```

2. Seed initial data:
```bash
pnpm seed
```

To remove admin user:
```bash
pnpm remove-admin
```

## Running the Application

```bash
# Development
pnpm start:dev

# Production
pnpm start:prod

# Debug mode
pnpm start:debug
```

## Testing

```bash
# Unit tests
pnpm test

# E2E tests
pnpm test:e2e

# Test coverage
pnpm test:cov
```

## Available Scripts

- `pnpm start` - Start the application
- `pnpm start:dev` - Start in watch mode
- `pnpm build` - Build the application
- `pnpm format` - Format code with Prettier
- `pnpm lint` - Lint code with ESLint
- `pnpm migration:generate` - Generate new migration
- `pnpm migration:run` - Run migrations
- `pnpm migration:revert` - Revert last migration
- `pnpm seed` - Seed initial data
- `pnpm remove-admin` - Remove admin user

## Project Structure

```
src/
├── auth/               # Authentication & authorization
├── bookings/          # Booking management
├── config/            # Configuration modules
├── database/          # Migrations & seeds
├── employees/         # Employee management
├── services/          # Service management
├── users/             # User management
└── main.ts            # Application entry point
```

## Environment Variables

Required environment variables in `.env`:

```
# Database
DB_HOST=localhost
DB_PORT=5432
DB_USERNAME=postgres
DB_PASSWORD=your_password
DB_DATABASE=your_database

# JWT
JWT_SECRET=your_jwt_secret
JWT_EXPIRATION=24h

# Redis
REDIS_HOST=localhost
REDIS_PORT=6379
```

## API Documentation

Once the application is running, you can access the Swagger documentation at:
```
http://localhost:3000/api
```

## License

MIT
````

## File: backend/renovate.json
````json
{
  "extends": [
    "config:recommended"
  ],
  "ignorePresets": [
    ":prHourlyLimit2",
    ":prConcurrentLimit20"
  ],
  "packageRules": [
    {
      "rangeStrategy": "bump",
      "matchDepTypes": [
        "dependencies",
        "devDependencies",
        "optionalDependencies",
        "peerDependencies"
      ]
    },
    {
      "matchUpdateTypes": [
        "minor",
        "pin",
        "digest"
      ],
      "automerge": true,
      "matchDepTypes": [
        "dependencies",
        "devDependencies",
        "optionalDependencies",
        "peerDependencies"
      ]
    },
    {
      "matchUpdateTypes": [
        "patch",
        "lockFileMaintenance"
      ],
      "automerge": true,
      "automergeType": "branch",
      "matchDepTypes": [
        "dependencies",
        "devDependencies",
        "optionalDependencies",
        "peerDependencies"
      ]
    }
  ]
}
````

## File: backend/tsconfig.build.json
````json
{
  "extends": "./tsconfig.json",
  "exclude": ["node_modules", "test", "dist", "**/*spec.ts"]
}
````

## File: backend/tsconfig.json
````json
{
  "compilerOptions": {
    "module": "commonjs",
    "declaration": true,
    "removeComments": true,
    "emitDecoratorMetadata": true,
    "experimentalDecorators": true,
    "allowSyntheticDefaultImports": true,
    "target": "ES2021",
    "sourceMap": true,
    "outDir": "./dist",
    "baseUrl": "./",
    "incremental": true,
    "skipLibCheck": true,
    "strictNullChecks": false,
    "noImplicitAny": false,
    "strictBindCallApply": false,
    "forceConsistentCasingInFileNames": false,
    "noFallthroughCasesInSwitch": false
  }
}
````

## File: backend/typeorm.config.ts
````typescript
import { DataSource } from "typeorm";
import { config } from "dotenv";
import { join } from "path";
// Load environment variables
config();
export default new DataSource({
  type: "postgres",
  url: process.env.DATABASE_URL,
  entities: [join(__dirname, "src", "**", "*.entity{.ts,.js}")],
  migrations: [
    join(
      __dirname,
      "src",
      "database",
      "migrations",
      "1731981975581-InitialMigration.ts"
    ),
    join(
      __dirname,
      "src",
      "database",
      "migrations",
      "1731981975582-CreateBookingSystem.ts"
    ),
    join(
      __dirname,
      "src",
      "database",
      "migrations",
      "1731981975584-AddShopCodes.ts"
    ),
  ],
  synchronize: false,
  logging: process.env.NODE_ENV === "development",
  ssl: {
    rejectUnauthorized: false,
  },
});
````

## File: DOCS/ARCHITECTURE.md
````markdown
# Hair Salon Booking System Planning Document

## Table of Contents

- [Introduction](#introduction)
- [Project Objectives](#project-objectives)
- [Functional Requirements](#functional-requirements)
- [Non-Functional Requirements](#non-functional-requirements)
- [Technology Stack](#technology-stack)
- [System Architecture](#system-architecture)
- [Database Design](#database-design)
- [API Design](#api-design)
- [Frontend Design](#frontend-design)
- [Security Considerations](#security-considerations)
- [Scalability Considerations](#scalability-considerations)
- [Deployment Plan](#deployment-plan)
- [Timeline and Milestones](#timeline-and-milestones)
- [Conclusion](#conclusion)

---

## Introduction

This document outlines the planning phase for developing a full-stack booking system for a hair salon. The system aims to streamline the booking process for customers, manage appointments efficiently, and provide administrative capabilities for salon management and staff.

---

## Project Objectives

- Develop a scalable, production-ready booking platform tailored for hair salons.
- Implement a user-friendly frontend interface for customers to book appointments.
- Create an administrative dashboard for the salon's CEO and staff to manage bookings, schedules, and generate reports.
- Ensure the system is secure, fast, and maintainable for future enhancements.
- Expose a robust API for potential integration with other solutions.

---

## Functional Requirements

### Customer-Facing Features

- **User Registration and Authentication**: Customers can create accounts and securely log in.
- **Appointment Booking**: Browse available time slots and book appointments without double-booking conflicts.
- **Service Selection**: View and select from a list of services offered.
- **Booking Management**: View, modify, or cancel existing bookings.
- **Notifications**: Receive email/SMS confirmations and reminders.

### Employee Features

- **Employee Login**: Staff members have individual accounts to access their schedules.
- **Schedule Management**: View and manage personal appointment schedules.
- **Availability Settings**: Set availability and block out times when not available.

### Admin Features

- **Admin Dashboard**: Comprehensive overview of daily bookings, staff schedules, and salon performance.
- **User Management**: Add, modify, or remove employee accounts.
- **Reporting**: Generate reports on bookings, revenue, and employee performance; export data to Excel.
- **Service Management**: Add or update services offered, including pricing and duration.

---

## Non-Functional Requirements

- **Scalability**: Able to handle increased load, e.g., for large salons like Cutters.
- **Performance**: Fast load times and responsive interactions.
- **Security**: Protect user data with robust authentication and authorization mechanisms.
- **Maintainability**: Clean, well-documented codebase for future development.
- **Reliability**: Ensure high availability and fault tolerance.
- **Usability**: Intuitive user interface and user experience.
- **Compliance**: Adhere to relevant data protection regulations (e.g., GDPR).

---

## Technology Stack

### Backend

- **Language**: Node.js (JavaScript/TypeScript)
- **Framework**: [NestJS](https://nestjs.com/) for a scalable and maintainable structure.
  - Future-proof and supports enterprise-grade applications.
  - Built with TypeScript, encouraging type safety.
- **Database**:
  - **Primary**: PostgreSQL for relational data storage.
  - **Cache**: Redis for caching frequently accessed data and managing session data.
- **Authentication**: JSON Web Tokens (JWT) with refresh tokens for secure API access.
- **API Documentation**: Swagger/OpenAPI for documenting APIs.

### Frontend

- **Framework**: Vue 3
  - Known for its gentle learning curve and flexibility.
  - Composition API allows for better organization in larger applications.
- **State Management**: Pinia (the successor to Vuex) for managing application state.
- **Routing**: Vue Router for navigating between views.

### DevOps and Deployment

- **Containerization**: Docker for consistent environments across development, testing, and production.
- **Orchestration**: Kubernetes or Docker Compose for managing containers.
- **Continuous Integration/Continuous Deployment (CI/CD)**: Jenkins, GitHub Actions, or GitLab CI for automatic building, testing, and deployment.
- **Hosting**: Cloud provider like AWS, Azure, or Google Cloud Platform.

---

## System Architecture

### Overview

The system will follow a modular architecture separating the frontend, backend, and database layers.

1. **Frontend Client**:

   - Runs in the browser.
   - Communicates with the backend via RESTful API calls.
   - Provides interfaces for customers, employees, and admins based on roles.

2. **Backend API**:

   - Exposes RESTful endpoints for all functionalities.
   - Handles business logic, authentication, and authorization.
   - Interacts with the database and cache layers.

3. **Database Layer**:
   - PostgreSQL stores persistent relational data.
   - Redis used for session management, caching, and handling real-time features (e.g., notifications).

### Interaction Flow

1. A customer accesses the booking interface via the frontend.
2. The frontend communicates with the backend API to fetch available time slots.
3. Upon booking, the backend validates the request, ensures no double-booking via Redis locks, and stores the appointment in PostgreSQL.
4. Notifications are sent, and the employee's schedule is updated accordingly.

---

## Database Design

### Entities and Relationships

1. **Users**

   - **Attributes**: `id`, `name`, `email`, `password`, `role` (customer, employee, admin), `contact_info`, `created_at`, `updated_at`
   - Stores all user information with role-based access.

2. **Employees**

   - **Attributes**: `id`, `user_id`, `specializations`, `availability`, `created_at`, `updated_at`
   - Linked to the `Users` table via `user_id`.

3. **Services**

   - **Attributes**: `id`, `name`, `description`, `duration`, `price`, `created_at`, `updated_at`
   - List of services offered by the salon.

4. **Bookings**

   - **Attributes**: `id`, `customer_id`, `employee_id`, `service_id`, `start_time`, `end_time`, `status`, `created_at`, `updated_at`
   - Represents appointments; references `Users`, `Employees`, and `Services`.

5. **Payments** (Optional for future implementation)

   - **Attributes**: `id`, `booking_id`, `amount`, `payment_method`, `status`, `transaction_date`

6. **Reports**
   - Generated on-demand; data pulled from existing tables.

### Database Constraints

- **Uniqueness**: Ensure email addresses are unique in the `Users` table.
- **Foreign Keys**: Maintain referential integrity between tables.
- **Indexes**: Optimize queries on frequently accessed fields (e.g., `start_time` in `Bookings`).

---

## API Design

### Authentication

- **Endpoints**:
  - `POST /auth/register`: Register a new user.
  - `POST /auth/login`: Authenticate user and provide JWT.
  - `POST /auth/refresh`: Refresh access tokens.
- **Middleware**: Protect routes using JWT verification.

### Customer APIs

- `GET /services`: List all available services.
- `GET /employees`: View employees and their specializations.
- `GET /availability`: Check available time slots for a service and employee.
- `POST /bookings`: Create a new booking.
- `GET /bookings/{id}`: Retrieve booking details.
- `PUT /bookings/{id}`: Modify an existing booking.
- `DELETE /bookings/{id}`: Cancel a booking.

### Employee APIs

- `GET /employees/{id}/schedule`: View own schedule.
- `PUT /employees/{id}/availability`: Update availability.

### Admin APIs

- `GET /admin/dashboard`: Get overview statistics.
- `POST /admin/employees`: Add a new employee.
- `PUT /admin/employees/{id}`: Update employee details.
- `DELETE /admin/employees/{id}`: Remove an employee.
- `POST /admin/services`: Add a new service.
- `PUT /admin/services/{id}`: Update service details.
- `DELETE /admin/services/{id}`: Remove a service.
- `GET /admin/reports`: Generate and retrieve reports.

### Error Handling

- Use standardized HTTP status codes.
- Return error messages with details to assist in debugging (avoid exposing sensitive information).

---

## Frontend Design

### User Interface Components

#### Customers

- **Home Page**: Introduction and quick access to booking.
- **Service Catalog**: Display services with details.
- **Booking Flow**:
  1. Select Service.
  2. Choose Employee (optional or auto-assigned).
  3. Pick Date and Time.
  4. Confirm Booking.
- **User Account**:
  - View upcoming and past appointments.
  - Edit personal information.

#### Employees

- **Dashboard**: Overview of today's appointments.
- **Schedule View**: Calendar with upcoming bookings.
- **Availability Settings**: Interface to block out unavailable times.

#### Admins

- **Admin Dashboard**: Key metrics and alerts.
- **Employee Management**: CRUD operations for employee accounts.
- **Service Management**: Add or modify services.
- **Reporting Tools**: Generate and export reports.

### UX/UI Considerations

- **Responsive Design**: Ensure usability on desktops, tablets, and mobile devices.
- **Accessibility**: Adhere to WCAG guidelines for inclusive design.
- **Consistency**: Use a design system or component library (e.g., Vuetify) for uniformity.

---

## Security Considerations

- **Authentication**: Implement robust authentication with password hashing (e.g., bcrypt) and secure JWT handling.
- **Authorization**: Role-based access control to restrict resources.
- **Input Validation**: Sanitize and validate all user inputs to prevent SQL injection and XSS attacks.
- **Data Protection**: Encrypt sensitive data at rest and in transit (use HTTPS with TLS).
- **Rate Limiting**: Protect against brute-force attacks by limiting login attempts.
- **Audit Logging**: Maintain logs of critical actions for auditing purposes.

---

## Scalability Considerations

- **Stateless Backend**: Design the backend to be stateless to facilitate horizontal scaling.
- **Load Balancing**: Use a load balancer to distribute traffic across multiple server instances.
- **Caching Strategy**: Implement caching for frequent read operations using Redis.
- **Database Optimization**: Use indexing and query optimization; consider read replicas for PostgreSQL.
- **Asynchronous Processing**: Use message queues (e.g., RabbitMQ) for background tasks like sending notifications.

---

## Deployment Plan

### Environments

1. **Development**
   - Local machines with hot-reloading for rapid development.
2. **Testing/Staging**
   - Mirror production environment for testing features before release.
3. **Production**
   - Live environment with robust monitoring and backup strategies.

### CI/CD Pipeline

- **Code Repository**: Use Git for version control (GitHub, GitLab).
- **Automated Testing**: Run unit and integration tests on every push.
- **Build and Deployment**: Automate using CI/CD tools to reduce manual errors.

### Monitoring and Logging

- **Application Monitoring**: Use tools like Prometheus and Grafana.
- **Error Tracking**: Implement Sentry or similar for error logging.
- **Health Checks**: Set up endpoint and infrastructure health checks.

---

## Timeline and Milestones

| Phase                     | Duration | Key Deliverables                                   |
| ------------------------- | -------- | -------------------------------------------------- |
| **Requirements Analysis** | 1 week   | Finalize specifications and user stories           |
| **Design**                | 2 weeks  | System architecture, database schema, UI mockups   |
| **Backend Development**   | 4 weeks  | API endpoints, authentication, business logic      |
| **Frontend Development**  | 4 weeks  | UI components, state management, API integration   |
| **Testing**               | 2 weeks  | Unit tests, integration tests, user acceptance     |
| **Deployment Setup**      | 1 week   | CI/CD pipeline, server setup, domain configuration |
| **Beta Release**          | 1 week   | Deploy to staging, gather feedback                 |
| **Final Adjustments**     | 1 week   | Bug fixes, performance tuning                      |
| **Launch**                | -        | Deploy to production                               |

_Total Estimated Time: Approximately 3 months_

---

## Conclusion

This planning document outlines a comprehensive approach to developing a full-stack hair salon booking system that is scalable, secure, and user-friendly. By leveraging modern technologies and adhering to best practices in software development, the final product aims to meet the immediate needs of hair salons while being adaptable for future growth and integration.

---

**Next Steps**:

- Review and approve the planning document.
- Set up initial development environments.
- Begin the requirements analysis phase with stakeholder meetings.
````

## File: DOCS/CONVENTIONS.md
````markdown
# Code Conventions and Best Practices

## General Principles

- Follow TDD (Test-Driven Development)
- Apply DRY (Don't Repeat Yourself)
- Follow KISS (Keep It Simple, Stupid)
- Apply YAGNI (You Aren't Gonna Need It)
- Follow SOLID Principles:
  - Single Responsibility
  - Open/Closed
  - Liskov Substitution
  - Interface Segregation
  - Dependency Inversion

## TypeScript/JavaScript Conventions

### Naming Conventions

- Use `PascalCase` for:
  - Classes
  - Interfaces
  - Type aliases
  - Enums
- Use `camelCase` for:
  - Variables
  - Functions
  - Methods
  - Properties
  - Parameters
- Use `UPPER_SNAKE_CASE` for constants
- Use descriptive names that reflect the purpose

### File Naming

- Use `kebab-case` for file names
- Suffix files based on their type:
  - `.controller.ts` for controllers
  - `.service.ts` for services
  - `.entity.ts` for database entities
  - `.dto.ts` for Data Transfer Objects
  - `.spec.ts` for test files

### Code Organization

- One class per file
- Group related functionality in modules
- Keep files focused and small
- Use barrel exports (index.ts) for clean imports

## Testing Conventions

### Test Structure

- Follow the AAA pattern:
  - Arrange: Set up test data
  - Act: Execute the code being tested
  - Assert: Verify the results
- Use descriptive test names that explain the scenario
- Group related tests using describe blocks
- Mock external dependencies

### Test Coverage

- Aim for 80%+ code coverage
- Write unit tests for:
  - Services
  - Controllers
  - Guards
  - Pipes
  - Custom decorators
- Include integration tests for:
  - API endpoints
  - Database operations

## API Conventions

### RESTful Endpoints

- Use plural nouns for resources
- Follow HTTP method semantics:
  - GET: Read
  - POST: Create
  - PUT: Full update
  - PATCH: Partial update
  - DELETE: Remove
- Use proper HTTP status codes

### Request/Response

- Use DTOs for request validation
- Follow consistent response format:
  ```typescript
  {
    success: boolean;
    data?: any;
    error?: {
      code: string;
      message: string;
    }
  }
  ```

## Database Conventions

### Entity Design

- Use singular names for entity classes
- Include created_at and updated_at timestamps
- Use proper column types and constraints
- Define explicit relationships

### Migrations

- One migration per change
- Descriptive migration names
- Include both up and down migrations
- Test migrations before deployment

## Documentation

- Use JSDoc for code documentation
- Keep README files up to date
- Document API endpoints using Swagger
- Include setup instructions

## Version Control

- Write clear commit messages
- Use feature branches
- Follow conventional commits format:
  - feat: New feature
  - fix: Bug fix
  - docs: Documentation
  - style: Formatting
  - refactor: Code restructuring
  - test: Adding tests
  - chore: Maintenance

## Error Handling

- Use custom exception filters
- Implement proper logging
- Return appropriate error responses
- Handle async/await properly with try/catch

## Security

- Validate all inputs
- Sanitize data before storage
- Use proper authentication/authorization
- Follow security best practices
- Keep dependencies updated

## Performance

- Use appropriate caching strategies
- Optimize database queries
- Implement pagination for lists
- Monitor and optimize resource usage
````

## File: DOCS/README.md
````markdown
# Hair Salon Booking System Documentation

## Overview

This is a full-stack booking system for hair salons built using NestJS (backend) and Vue 3 (frontend). The system allows customers to book appointments, employees to manage their schedules, and administrators to oversee all operations.

## Project Structure

```
├── backend/               # NestJS backend application
├── frontend/             # Vue 3 frontend application
├── docs/                 # Project documentation
└── architecture/         # System architecture and planning
```

## Technology Stack

### Backend

- NestJS (TypeScript)
- PostgreSQL (Database)
- Redis (Caching)
- Jest (Testing)
- Swagger (API Documentation)

### Frontend

- Vue 3
- Pinia (State Management)
- Vue Router
- TypeScript

## Getting Started

### Prerequisites

- Node.js (v16 or higher)
- npm or yarn
- PostgreSQL
- Redis
- Docker (optional)

### Backend Setup

1. Navigate to the backend directory:
   ```bash
   cd backend
   ```

2. Install dependencies:
   ```bash
   npm install
   ```

3. Set up environment variables:
   - Copy `.env.example` to `.env`
   - Update the variables with your configuration

4. Run database migrations:
   ```bash
   npm run migration:run
   ```

5. Start the development server:
   ```bash
   npm run start:dev
   ```

The API will be available at `http://localhost:3000`
Swagger documentation will be at `http://localhost:3000/api`

### Running Tests

```bash
# Unit tests
npm run test

# e2e tests
npm run test:e2e

# Test coverage
npm run test:cov
```

## Development Guidelines

### Code Style

- Follow the conventions defined in [CONVENTIONS.md](./CONVENTIONS.md)
- Use ESLint and Prettier for code formatting
- Write tests for all new features
- Follow TDD principles

### Git Workflow

1. Create a feature branch from `develop`:
   ```bash
   git checkout -b feature/your-feature-name
   ```

2. Make your changes following the conventions

3. Write tests for your changes

4. Commit your changes using conventional commits

5. Create a pull request to `develop`

### Database Changes

1. Create a new migration:
   ```bash
   npm run migration:create -- -n YourMigrationName
   ```

2. Update the migration file with your changes

3. Test the migration:
   ```bash
   npm run migration:run
   ```

4. Test the rollback:
   ```bash
   npm run migration:revert
   ```

## API Documentation

- API documentation is available through Swagger at `/api` when running the backend
- Keep the Swagger documentation up to date when making API changes
- Follow the API conventions defined in [CONVENTIONS.md](./CONVENTIONS.md)

## Testing Strategy

### Unit Tests

- Write unit tests for:
  - Services
  - Controllers
  - Guards
  - Pipes
  - Custom decorators

### Integration Tests

- Write integration tests for:
  - API endpoints
  - Database operations
  - Cache operations

### E2E Tests

- Write end-to-end tests for critical user flows
- Test the integration between frontend and backend

## Deployment

### Development

- Use `npm run start:dev` for local development
- Development server runs at `http://localhost:3000`

### Production

1. Build the application:
   ```bash
   npm run build
   ```

2. Start the production server:
   ```bash
   npm run start:prod
   ```

### Docker

1. Build the Docker image:
   ```bash
   docker build -t hair-salon-booking .
   ```

2. Run the container:
   ```bash
   docker run -p 3000:3000 hair-salon-booking
   ```

## Monitoring and Logging

- Use built-in NestJS logging
- Monitor application performance
- Track error rates and API usage
- Set up alerts for critical issues

## Security

- Follow security best practices
- Keep dependencies updated
- Use proper authentication and authorization
- Validate all inputs
- Implement rate limiting
- Use HTTPS in production

## Support

1. Check the existing documentation
2. Review the codebase and tests
3. Contact the development team

## License

This project is licensed under the terms specified in the LICENSE file at the root of the repository.
````

## File: frontend/admin/.vscode/extensions.json
````json
{
  "recommendations": ["Vue.volar"]
}
````

## File: frontend/admin/docs/ARCHITECTURE.md
````markdown
# Hair Salon Booking System Planning Document

## Table of Contents

- [Introduction](#introduction)
- [Project Objectives](#project-objectives)
- [Functional Requirements](#functional-requirements)
- [Non-Functional Requirements](#non-functional-requirements)
- [Technology Stack](#technology-stack)
- [System Architecture](#system-architecture)
- [Database Design](#database-design)
- [API Design](#api-design)
- [Frontend Design](#frontend-design)
- [Security Considerations](#security-considerations)
- [Scalability Considerations](#scalability-considerations)
- [Deployment Plan](#deployment-plan)
- [Timeline and Milestones](#timeline-and-milestones)
- [Conclusion](#conclusion)

---

## Introduction

This document outlines the planning phase for developing a full-stack booking system for a hair salon. The system aims to streamline the booking process for customers, manage appointments efficiently, and provide administrative capabilities for salon management and staff.

---

## Project Objectives

- Develop a scalable, production-ready booking platform tailored for hair salons.
- Implement a user-friendly frontend interface for customers to book appointments.
- Create an administrative dashboard for the salon's CEO and staff to manage bookings, schedules, and generate reports.
- Ensure the system is secure, fast, and maintainable for future enhancements.
- Expose a robust API for potential integration with other solutions.

---

## Functional Requirements

### Customer-Facing Features

- **User Registration and Authentication**: Customers can create accounts and securely log in.
- **Appointment Booking**: Browse available time slots and book appointments without double-booking conflicts.
- **Service Selection**: View and select from a list of services offered.
- **Booking Management**: View, modify, or cancel existing bookings.
- **Notifications**: Receive email/SMS confirmations and reminders.

### Employee Features

- **Employee Login**: Staff members have individual accounts to access their schedules.
- **Schedule Management**: View and manage personal appointment schedules.
- **Availability Settings**: Set availability and block out times when not available.

### Admin Features

- **Admin Dashboard**: Comprehensive overview of daily bookings, staff schedules, and salon performance.
- **User Management**: Add, modify, or remove employee accounts.
- **Reporting**: Generate reports on bookings, revenue, and employee performance; export data to Excel.
- **Service Management**: Add or update services offered, including pricing and duration.

---

## Non-Functional Requirements

- **Scalability**: Able to handle increased load, e.g., for large salons like Cutters.
- **Performance**: Fast load times and responsive interactions.
- **Security**: Protect user data with robust authentication and authorization mechanisms.
- **Maintainability**: Clean, well-documented codebase for future development.
- **Reliability**: Ensure high availability and fault tolerance.
- **Usability**: Intuitive user interface and user experience.
- **Compliance**: Adhere to relevant data protection regulations (e.g., GDPR).

---

## Technology Stack

### Backend

- **Language**: Node.js (JavaScript/TypeScript)
- **Framework**: [NestJS](https://nestjs.com/) for a scalable and maintainable structure.
  - Future-proof and supports enterprise-grade applications.
  - Built with TypeScript, encouraging type safety.
- **Database**:
  - **Primary**: PostgreSQL for relational data storage.
  - **Cache**: Redis for caching frequently accessed data and managing session data.
- **Authentication**: JSON Web Tokens (JWT) with refresh tokens for secure API access.
- **API Documentation**: Swagger/OpenAPI for documenting APIs.

### Frontend

- **Framework**: Vue 3
  - Known for its gentle learning curve and flexibility.
  - Composition API allows for better organization in larger applications.
- **State Management**: Pinia (the successor to Vuex) for managing application state.
- **Routing**: Vue Router for navigating between views.

### DevOps and Deployment

- **Containerization**: Docker for consistent environments across development, testing, and production.
- **Orchestration**: Kubernetes or Docker Compose for managing containers.
- **Continuous Integration/Continuous Deployment (CI/CD)**: Jenkins, GitHub Actions, or GitLab CI for automatic building, testing, and deployment.
- **Hosting**: Cloud provider like AWS, Azure, or Google Cloud Platform.

---

## System Architecture

### Overview

The system will follow a modular architecture separating the frontend, backend, and database layers.

1. **Frontend Client**:

   - Runs in the browser.
   - Communicates with the backend via RESTful API calls.
   - Provides interfaces for customers, employees, and admins based on roles.

2. **Backend API**:

   - Exposes RESTful endpoints for all functionalities.
   - Handles business logic, authentication, and authorization.
   - Interacts with the database and cache layers.

3. **Database Layer**:
   - PostgreSQL stores persistent relational data.
   - Redis used for session management, caching, and handling real-time features (e.g., notifications).

### Interaction Flow

1. A customer accesses the booking interface via the frontend.
2. The frontend communicates with the backend API to fetch available time slots.
3. Upon booking, the backend validates the request, ensures no double-booking via Redis locks, and stores the appointment in PostgreSQL.
4. Notifications are sent, and the employee's schedule is updated accordingly.

---

## Database Design

### Entities and Relationships

1. **Users**

   - **Attributes**: `id`, `name`, `email`, `password`, `role` (customer, employee, admin), `contact_info`, `created_at`, `updated_at`
   - Stores all user information with role-based access.

2. **Employees**

   - **Attributes**: `id`, `user_id`, `specializations`, `availability`, `created_at`, `updated_at`
   - Linked to the `Users` table via `user_id`.

3. **Services**

   - **Attributes**: `id`, `name`, `description`, `duration`, `price`, `created_at`, `updated_at`
   - List of services offered by the salon.

4. **Bookings**

   - **Attributes**: `id`, `customer_id`, `employee_id`, `service_id`, `start_time`, `end_time`, `status`, `created_at`, `updated_at`
   - Represents appointments; references `Users`, `Employees`, and `Services`.

5. **Payments** (Optional for future implementation)

   - **Attributes**: `id`, `booking_id`, `amount`, `payment_method`, `status`, `transaction_date`

6. **Reports**
   - Generated on-demand; data pulled from existing tables.

### Database Constraints

- **Uniqueness**: Ensure email addresses are unique in the `Users` table.
- **Foreign Keys**: Maintain referential integrity between tables.
- **Indexes**: Optimize queries on frequently accessed fields (e.g., `start_time` in `Bookings`).

---

## API Design

### Authentication

- **Endpoints**:
  - `POST /auth/register`: Register a new user.
  - `POST /auth/login`: Authenticate user and provide JWT.
  - `POST /auth/refresh`: Refresh access tokens.
- **Middleware**: Protect routes using JWT verification.

### Customer APIs

- `GET /services`: List all available services.
- `GET /employees`: View employees and their specializations.
- `GET /availability`: Check available time slots for a service and employee.
- `POST /bookings`: Create a new booking.
- `GET /bookings/{id}`: Retrieve booking details.
- `PUT /bookings/{id}`: Modify an existing booking.
- `DELETE /bookings/{id}`: Cancel a booking.

### Employee APIs

- `GET /employees/{id}/schedule`: View own schedule.
- `PUT /employees/{id}/availability`: Update availability.

### Admin APIs

- `GET /admin/dashboard`: Get overview statistics.
- `POST /admin/employees`: Add a new employee.
- `PUT /admin/employees/{id}`: Update employee details.
- `DELETE /admin/employees/{id}`: Remove an employee.
- `POST /admin/services`: Add a new service.
- `PUT /admin/services/{id}`: Update service details.
- `DELETE /admin/services/{id}`: Remove a service.
- `GET /admin/reports`: Generate and retrieve reports.

### Error Handling

- Use standardized HTTP status codes.
- Return error messages with details to assist in debugging (avoid exposing sensitive information).

---

## Frontend Design

### User Interface Components

#### Customers

- **Home Page**: Introduction and quick access to booking.
- **Service Catalog**: Display services with details.
- **Booking Flow**:
  1. Select Service.
  2. Choose Employee (optional or auto-assigned).
  3. Pick Date and Time.
  4. Confirm Booking.
- **User Account**:
  - View upcoming and past appointments.
  - Edit personal information.

#### Employees

- **Dashboard**: Overview of today's appointments.
- **Schedule View**: Calendar with upcoming bookings.
- **Availability Settings**: Interface to block out unavailable times.

#### Admins

- **Admin Dashboard**: Key metrics and alerts.
- **Employee Management**: CRUD operations for employee accounts.
- **Service Management**: Add or modify services.
- **Reporting Tools**: Generate and export reports.

### UX/UI Considerations

- **Responsive Design**: Ensure usability on desktops, tablets, and mobile devices.
- **Accessibility**: Adhere to WCAG guidelines for inclusive design.
- **Consistency**: Use a design system or component library (e.g., Vuetify) for uniformity.

---

## Security Considerations

- **Authentication**: Implement robust authentication with password hashing (e.g., bcrypt) and secure JWT handling.
- **Authorization**: Role-based access control to restrict resources.
- **Input Validation**: Sanitize and validate all user inputs to prevent SQL injection and XSS attacks.
- **Data Protection**: Encrypt sensitive data at rest and in transit (use HTTPS with TLS).
- **Rate Limiting**: Protect against brute-force attacks by limiting login attempts.
- **Audit Logging**: Maintain logs of critical actions for auditing purposes.

---

## Scalability Considerations

- **Stateless Backend**: Design the backend to be stateless to facilitate horizontal scaling.
- **Load Balancing**: Use a load balancer to distribute traffic across multiple server instances.
- **Caching Strategy**: Implement caching for frequent read operations using Redis.
- **Database Optimization**: Use indexing and query optimization; consider read replicas for PostgreSQL.
- **Asynchronous Processing**: Use message queues (e.g., RabbitMQ) for background tasks like sending notifications.

---

## Deployment Plan

### Environments

1. **Development**
   - Local machines with hot-reloading for rapid development.
2. **Testing/Staging**
   - Mirror production environment for testing features before release.
3. **Production**
   - Live environment with robust monitoring and backup strategies.

### CI/CD Pipeline

- **Code Repository**: Use Git for version control (GitHub, GitLab).
- **Automated Testing**: Run unit and integration tests on every push.
- **Build and Deployment**: Automate using CI/CD tools to reduce manual errors.

### Monitoring and Logging

- **Application Monitoring**: Use tools like Prometheus and Grafana.
- **Error Tracking**: Implement Sentry or similar for error logging.
- **Health Checks**: Set up endpoint and infrastructure health checks.

---

## Timeline and Milestones

| Phase                     | Duration | Key Deliverables                                   |
| ------------------------- | -------- | -------------------------------------------------- |
| **Requirements Analysis** | 1 week   | Finalize specifications and user stories           |
| **Design**                | 2 weeks  | System architecture, database schema, UI mockups   |
| **Backend Development**   | 4 weeks  | API endpoints, authentication, business logic      |
| **Frontend Development**  | 4 weeks  | UI components, state management, API integration   |
| **Testing**               | 2 weeks  | Unit tests, integration tests, user acceptance     |
| **Deployment Setup**      | 1 week   | CI/CD pipeline, server setup, domain configuration |
| **Beta Release**          | 1 week   | Deploy to staging, gather feedback                 |
| **Final Adjustments**     | 1 week   | Bug fixes, performance tuning                      |
| **Launch**                | -        | Deploy to production                               |

_Total Estimated Time: Approximately 3 months_

---

## Conclusion

This planning document outlines a comprehensive approach to developing a full-stack hair salon booking system that is scalable, secure, and user-friendly. By leveraging modern technologies and adhering to best practices in software development, the final product aims to meet the immediate needs of hair salons while being adaptable for future growth and integration.

---

**Next Steps**:

- Review and approve the planning document.
- Set up initial development environments.
- Begin the requirements analysis phase with stakeholder meetings.
````

## File: frontend/admin/docs/CONVENTIONS.md
````markdown
# Code Conventions and Best Practices

## General Principles

- Follow TDD (Test-Driven Development)
- Apply DRY (Don't Repeat Yourself)
- Follow KISS (Keep It Simple, Stupid)
- Apply YAGNI (You Aren't Gonna Need It)
- Follow SOLID Principles:
  - Single Responsibility
  - Open/Closed
  - Liskov Substitution
  - Interface Segregation
  - Dependency Inversion

## TypeScript/JavaScript Conventions

### Naming Conventions

- Use `PascalCase` for:
  - Classes
  - Interfaces
  - Type aliases
  - Enums
- Use `camelCase` for:
  - Variables
  - Functions
  - Methods
  - Properties
  - Parameters
- Use `UPPER_SNAKE_CASE` for constants
- Use descriptive names that reflect the purpose

### File Naming

- Use `kebab-case` for file names
- Suffix files based on their type:
  - `.controller.ts` for controllers
  - `.service.ts` for services
  - `.entity.ts` for database entities
  - `.dto.ts` for Data Transfer Objects
  - `.spec.ts` for test files

### Code Organization

- One class per file
- Group related functionality in modules
- Keep files focused and small
- Use barrel exports (index.ts) for clean imports

## Testing Conventions

### Test Structure

- Follow the AAA pattern:
  - Arrange: Set up test data
  - Act: Execute the code being tested
  - Assert: Verify the results
- Use descriptive test names that explain the scenario
- Group related tests using describe blocks
- Mock external dependencies

### Test Coverage

- Aim for 80%+ code coverage
- Write unit tests for:
  - Services
  - Controllers
  - Guards
  - Pipes
  - Custom decorators
- Include integration tests for:
  - API endpoints
  - Database operations

## API Conventions

### RESTful Endpoints

- Use plural nouns for resources
- Follow HTTP method semantics:
  - GET: Read
  - POST: Create
  - PUT: Full update
  - PATCH: Partial update
  - DELETE: Remove
- Use proper HTTP status codes

### Request/Response

- Use DTOs for request validation
- Follow consistent response format:
  ```typescript
  {
    success: boolean;
    data?: any;
    error?: {
      code: string;
      message: string;
    }
  }
  ```

## Database Conventions

### Entity Design

- Use singular names for entity classes
- Include created_at and updated_at timestamps
- Use proper column types and constraints
- Define explicit relationships

### Migrations

- One migration per change
- Descriptive migration names
- Include both up and down migrations
- Test migrations before deployment

## Documentation

- Use JSDoc for code documentation
- Keep README files up to date
- Document API endpoints using Swagger
- Include setup instructions

## Version Control

- Write clear commit messages
- Use feature branches
- Follow conventional commits format:
  - feat: New feature
  - fix: Bug fix
  - docs: Documentation
  - style: Formatting
  - refactor: Code restructuring
  - test: Adding tests
  - chore: Maintenance

## Error Handling

- Use custom exception filters
- Implement proper logging
- Return appropriate error responses
- Handle async/await properly with try/catch

## Security

- Validate all inputs
- Sanitize data before storage
- Use proper authentication/authorization
- Follow security best practices
- Keep dependencies updated

## Performance

- Use appropriate caching strategies
- Optimize database queries
- Implement pagination for lists
- Monitor and optimize resource usage
````

## File: frontend/admin/docs/README.md
````markdown
# Hair Salon Booking System Documentation

## Overview

This is a full-stack booking system for hair salons built using NestJS (backend) and Vue 3 (frontend). The system allows customers to book appointments, employees to manage their schedules, and administrators to oversee all operations.

## Project Structure

```
├── backend/               # NestJS backend application
├── frontend/             # Vue 3 frontend application
├── docs/                 # Project documentation
└── architecture/         # System architecture and planning
```

## Technology Stack

### Backend

- NestJS (TypeScript)
- PostgreSQL (Database)
- Redis (Caching)
- Jest (Testing)
- Swagger (API Documentation)

### Frontend

- Vue 3
- Pinia (State Management)
- Vue Router
- TypeScript

## Getting Started

### Prerequisites

- Node.js (v16 or higher)
- npm or yarn
- PostgreSQL
- Redis
- Docker (optional)

### Backend Setup

1. Navigate to the backend directory:
   ```bash
   cd backend
   ```

2. Install dependencies:
   ```bash
   npm install
   ```

3. Set up environment variables:
   - Copy `.env.example` to `.env`
   - Update the variables with your configuration

4. Run database migrations:
   ```bash
   npm run migration:run
   ```

5. Start the development server:
   ```bash
   npm run start:dev
   ```

The API will be available at `http://localhost:3000`
Swagger documentation will be at `http://localhost:3000/api`

### Running Tests

```bash
# Unit tests
npm run test

# e2e tests
npm run test:e2e

# Test coverage
npm run test:cov
```

## Development Guidelines

### Code Style

- Follow the conventions defined in [CONVENTIONS.md](./CONVENTIONS.md)
- Use ESLint and Prettier for code formatting
- Write tests for all new features
- Follow TDD principles

### Git Workflow

1. Create a feature branch from `develop`:
   ```bash
   git checkout -b feature/your-feature-name
   ```

2. Make your changes following the conventions

3. Write tests for your changes

4. Commit your changes using conventional commits

5. Create a pull request to `develop`

### Database Changes

1. Create a new migration:
   ```bash
   npm run migration:create -- -n YourMigrationName
   ```

2. Update the migration file with your changes

3. Test the migration:
   ```bash
   npm run migration:run
   ```

4. Test the rollback:
   ```bash
   npm run migration:revert
   ```

## API Documentation

- API documentation is available through Swagger at `/api` when running the backend
- Keep the Swagger documentation up to date when making API changes
- Follow the API conventions defined in [CONVENTIONS.md](./CONVENTIONS.md)

## Testing Strategy

### Unit Tests

- Write unit tests for:
  - Services
  - Controllers
  - Guards
  - Pipes
  - Custom decorators

### Integration Tests

- Write integration tests for:
  - API endpoints
  - Database operations
  - Cache operations

### E2E Tests

- Write end-to-end tests for critical user flows
- Test the integration between frontend and backend

## Deployment

### Development

- Use `npm run start:dev` for local development
- Development server runs at `http://localhost:3000`

### Production

1. Build the application:
   ```bash
   npm run build
   ```

2. Start the production server:
   ```bash
   npm run start:prod
   ```

### Docker

1. Build the Docker image:
   ```bash
   docker build -t hair-salon-booking .
   ```

2. Run the container:
   ```bash
   docker run -p 3000:3000 hair-salon-booking
   ```

## Monitoring and Logging

- Use built-in NestJS logging
- Monitor application performance
- Track error rates and API usage
- Set up alerts for critical issues

## Security

- Follow security best practices
- Keep dependencies updated
- Use proper authentication and authorization
- Validate all inputs
- Implement rate limiting
- Use HTTPS in production

## Support

1. Check the existing documentation
2. Review the codebase and tests
3. Contact the development team

## License

This project is licensed under the terms specified in the LICENSE file at the root of the repository.
````

## File: frontend/admin/public/vite.svg
````
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="31.88" height="32" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 257"><defs><linearGradient id="IconifyId1813088fe1fbc01fb466" x1="-.828%" x2="57.636%" y1="7.652%" y2="78.411%"><stop offset="0%" stop-color="#41D1FF"></stop><stop offset="100%" stop-color="#BD34FE"></stop></linearGradient><linearGradient id="IconifyId1813088fe1fbc01fb467" x1="43.376%" x2="50.316%" y1="2.242%" y2="89.03%"><stop offset="0%" stop-color="#FFEA83"></stop><stop offset="8.333%" stop-color="#FFDD35"></stop><stop offset="100%" stop-color="#FFA800"></stop></linearGradient></defs><path fill="url(#IconifyId1813088fe1fbc01fb466)" d="M255.153 37.938L134.897 252.976c-2.483 4.44-8.862 4.466-11.382.048L.875 37.958c-2.746-4.814 1.371-10.646 6.827-9.67l120.385 21.517a6.537 6.537 0 0 0 2.322-.004l117.867-21.483c5.438-.991 9.574 4.796 6.877 9.62Z"></path><path fill="url(#IconifyId1813088fe1fbc01fb467)" d="M185.432.063L96.44 17.501a3.268 3.268 0 0 0-2.634 3.014l-5.474 92.456a3.268 3.268 0 0 0 3.997 3.378l24.777-5.718c2.318-.535 4.413 1.507 3.936 3.838l-7.361 36.047c-.495 2.426 1.782 4.5 4.151 3.78l15.304-4.649c2.372-.72 4.652 1.36 4.15 3.788l-11.698 56.621c-.732 3.542 3.979 5.473 5.943 2.437l1.313-2.028l72.516-144.72c1.215-2.423-.88-5.186-3.54-4.672l-25.505 4.922c-2.396.462-4.435-1.77-3.759-4.114l16.646-57.705c.677-2.35-1.37-4.583-3.769-4.113Z"></path></svg>
````

## File: frontend/admin/src/assets/vue.svg
````
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" aria-hidden="true" role="img" class="iconify iconify--logos" width="37.07" height="36" preserveAspectRatio="xMidYMid meet" viewBox="0 0 256 198"><path fill="#41B883" d="M204.8 0H256L128 220.8L0 0h97.92L128 51.2L157.44 0h47.36Z"></path><path fill="#41B883" d="m0 0l128 220.8L256 0h-51.2L128 132.48L50.56 0H0Z"></path><path fill="#35495E" d="M50.56 0L128 133.12L204.8 0h-47.36L128 51.2L97.92 0H50.56Z"></path></svg>
````

## File: frontend/admin/src/components/base/__tests__/Button.spec.ts
````typescript
import { describe, it, expect } from 'vitest';
import { mount } from '@vue/test-utils';
import Button from '../Button.vue';
describe('Button', () => {
  it('renders properly with default props', () => {
    const wrapper = mount(Button, {
      slots: {
        default: 'Test Button'
      }
    });
    expect(wrapper.text()).toBe('Test Button');
    expect(wrapper.attributes('type')).toBe('button');
    expect(wrapper.classes()).toContain('bg-indigo-600'); // primary variant
  });
  it('applies different variants correctly', () => {
    const variants = {
      primary: 'bg-indigo-600',
      secondary: 'bg-white',
      danger: 'bg-red-600'
    };
    Object.entries(variants).forEach(([variant, expectedClass]) => {
      const wrapper = mount(Button, {
        props: { variant: variant as 'primary' | 'secondary' | 'danger' }
      });
      expect(wrapper.classes()).toContain(expectedClass);
    });
  });
  it('applies different sizes correctly', () => {
    const sizes = {
      sm: 'px-3 py-1.5',
      md: 'px-4 py-2',
      lg: 'px-6 py-3'
    };
    Object.entries(sizes).forEach(([size, expectedClass]) => {
      const wrapper = mount(Button, {
        props: { size: size as 'sm' | 'md' | 'lg' }
      });
      expect(wrapper.classes()).toContain(expectedClass.split(' ')[0]);
    });
  });
  it('shows loading spinner when loading prop is true', () => {
    const wrapper = mount(Button, {
      props: {
        loading: true
      }
    });
    expect(wrapper.find('svg').exists()).toBe(true);
  });
  it('emits click event when clicked and not disabled', async () => {
    const wrapper = mount(Button);
    await wrapper.trigger('click');
    expect(wrapper.emitted()).toHaveProperty('click');
  });
  it('does not emit click event when disabled', async () => {
    const wrapper = mount(Button, {
      props: {
        disabled: true
      }
    });
    await wrapper.trigger('click');
    expect(wrapper.emitted('click')).toBeFalsy();
  });
  it('does not emit click event when loading', async () => {
    const wrapper = mount(Button, {
      props: {
        loading: true
      }
    });
    await wrapper.trigger('click');
    expect(wrapper.emitted('click')).toBeFalsy();
  });
  it('applies custom class names', () => {
    const customClass = 'custom-test-class';
    const wrapper = mount(Button, {
      props: {
        className: customClass
      }
    });
    expect(wrapper.classes()).toContain(customClass);
  });
  it('renders as submit button when type is submit', () => {
    const wrapper = mount(Button, {
      props: {
        type: 'submit'
      }
    });
    expect(wrapper.attributes('type')).toBe('submit');
  });
});
````

## File: frontend/admin/src/components/base/__tests__/Card.spec.ts
````typescript
import { describe, it, expect } from 'vitest';
import { mount } from '@vue/test-utils';
import Card from '../Card.vue';
describe('Card', () => {
  it('renders properly with default props', () => {
    const wrapper = mount(Card, {
      props: {
        title: 'Test Title',
        value: '42'
      }
    });
    expect(wrapper.text()).toContain('Test Title');
    expect(wrapper.text()).toContain('42');
    expect(wrapper.find('.bg-indigo-100').exists()).toBe(true);
    expect(wrapper.find('.text-indigo-600').exists()).toBe(true);
  });
  it('applies different colors correctly', () => {
    const colors = ['green', 'blue', 'red', 'yellow'] as const;
    colors.forEach(color => {
      const wrapper = mount(Card, {
        props: {
          title: 'Test',
          value: '42',
          color
        }
      });
      expect(wrapper.find(`.bg-${color}-100`).exists()).toBe(true);
      expect(wrapper.find(`.text-${color}-600`).exists()).toBe(true);
    });
  });
  it('renders slot content', () => {
    const wrapper = mount(Card, {
      props: {
        title: 'Test',
        value: '42'
      },
      slots: {
        icon: '<svg data-testid="test-icon">Test Icon</svg>'
      }
    });
    expect(wrapper.find('[data-testid="test-icon"]').exists()).toBe(true);
  });
  it('formats number values correctly', () => {
    const wrapper = mount(Card, {
      props: {
        title: 'Test',
        value: 42
      }
    });
    expect(wrapper.text()).toContain('42');
  });
  it('renders with all props', () => {
    const wrapper = mount(Card, {
      props: {
        title: 'Complex Test',
        value: 1000,
        color: 'green'
      },
      slots: {
        icon: '<svg data-testid="test-icon">Test Icon</svg>'
      }
    });
    expect(wrapper.text()).toContain('Complex Test');
    expect(wrapper.text()).toContain('1000');
    expect(wrapper.find('.bg-green-100').exists()).toBe(true);
    expect(wrapper.find('.text-green-600').exists()).toBe(true);
    expect(wrapper.find('[data-testid="test-icon"]').exists()).toBe(true);
  });
});
````

## File: frontend/admin/src/components/base/Card.vue
````vue
<template>
  <div class="bg-white rounded-lg shadow p-6">
    <div class="flex items-center">
      <div 
        :class="[
          'p-3 rounded-full',
          `bg-${props.color}-100 text-${props.color}-600`
        ]"
      >
        <slot name="icon"></slot>
      </div>
      <div class="ml-4">
        <h3 class="text-lg font-medium text-gray-900">{{ props.title }}</h3>
        <p 
          class="mt-1 text-3xl font-semibold"
          :class="`text-${props.color}-600`"
        >
          {{ props.value }}
        </p>
      </div>
    </div>
  </div>
</template>
<script setup lang="ts">
import type { CardProps } from '@/types/components';
const props = withDefaults(defineProps<CardProps>(), {
  color: 'indigo'
});
</script>
````

## File: frontend/admin/src/components/BookingDetailsModal.vue
````vue
<template>
  <div v-if="isOpen" class="fixed inset-0 bg-gray-500 bg-opacity-75 transition-opacity">
    <div class="fixed inset-0 z-10 overflow-y-auto">
      <div class="flex min-h-full items-end justify-center p-4 text-center sm:items-center sm:p-0">
        <div class="relative transform overflow-hidden rounded-lg bg-white px-4 pb-4 pt-5 text-left shadow-xl transition-all sm:my-8 sm:w-full sm:max-w-lg sm:p-6">
          <div class="absolute right-0 top-0 hidden pr-4 pt-4 sm:block">
            <Button
              @click="closeModal"
              variant="secondary"
              size="sm"
              className="rounded-md bg-white text-gray-400 hover:text-gray-500"
              aria-label="Lukk"
            >
              <span class="sr-only">Lukk</span>
              <svg class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
              </svg>
            </Button>
          </div>
          <div class="sm:flex sm:items-start">
            <div class="mt-3 text-center sm:mt-0 sm:text-left w-full">
              <h3 class="text-lg font-semibold leading-6 text-gray-900" id="modal-title">
                Bestillingsdetaljer
              </h3>
              <div class="mt-4 space-y-4">
                <!-- Customer -->
                <div>
                  <label for="customer-name" class="block text-sm font-medium text-gray-700">Kunde</label>
                  <p id="customer-name" class="mt-1 text-sm text-gray-900">{{ booking?.customerName }}</p>
                </div>
                <!-- Employee -->
                <div>
                  <label for="employee-name" class="block text-sm font-medium text-gray-700">Ansatt</label>
                  <p id="employee-name" class="mt-1 text-sm text-gray-900">{{ booking?.employeeName }}</p>
                </div>
                <!-- Service -->
                <div>
                  <label for="service-name" class="block text-sm font-medium text-gray-700">Tjeneste</label>
                  <p id="service-name" class="mt-1 text-sm text-gray-900">{{ booking?.serviceName }}</p>
                </div>
                <!-- Status -->
                <div>
                  <label for="booking-status" class="block text-sm font-medium text-gray-700">Status</label>
                  <p id="booking-status" class="mt-1">
                    <span
                      :class="[
                        'px-2 inline-flex text-xs leading-5 font-semibold rounded-full',
                        getStatusColor(booking?.status)
                      ]"
                    >
                      {{ getStatusText(booking?.status) }}
                    </span>
                  </p>
                </div>
                <!-- Date and Time -->
                <div>
                  <label for="booking-datetime" class="block text-sm font-medium text-gray-700">Dato og tid</label>
                  <p id="booking-datetime" class="mt-1 text-sm text-gray-900">{{ formatDateTime(booking?.startTime) }}</p>
                </div>
                <!-- Notes -->
                <div v-if="booking?.notes">
                  <label for="booking-notes" class="block text-sm font-medium text-gray-700">Notater</label>
                  <p id="booking-notes" class="mt-1 text-sm text-gray-900">{{ booking?.notes }}</p>
                </div>
              </div>
            </div>
          </div>
          <div class="mt-5 sm:mt-4 sm:flex sm:justify-end">
            <Button
              @click="closeModal"
              variant="secondary"
              aria-label="Lukk modal"
            >
              Lukk
            </Button>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>
<script setup lang="ts">
import type { BookingView } from '../types';
import Button from './base/Button.vue';
defineProps<{
  isOpen: boolean;
  booking: BookingView | null;
}>();
const emit = defineEmits<{
  (e: 'close'): void;
}>();
const getStatusColor = (status: string | undefined): string => {
  switch (status?.toUpperCase()) {
    case "CONFIRMED":
      return "bg-green-100 text-green-800";
    case "PENDING":
      return "bg-yellow-100 text-yellow-800";
    case "CANCELLED":
      return "bg-red-100 text-red-800";
    case "COMPLETED":
      return "bg-blue-100 text-blue-800";
    default:
      return "bg-gray-100 text-gray-800";
  }
};
const getStatusText = (status: string | undefined): string => {
  switch (status?.toUpperCase()) {
    case "CONFIRMED":
      return "Bekreftet";
    case "PENDING":
      return "Venter";
    case "CANCELLED":
      return "Kansellert";
    case "COMPLETED":
      return "Fullført";
    default:
      return "Ukjent";
  }
};
const formatDateTime = (dateString: string | undefined): string => {
  if (!dateString) return '';
  try {
    const date = new Date(dateString);
    return new Intl.DateTimeFormat('nb-NO', {
      year: 'numeric',
      month: 'long',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit'
    }).format(date);
  } catch (error) {
    console.error('Error formatting date:', error);
    return 'Dato ikke tilgjengelig';
  }
};
const closeModal = () => {
  emit('close');
};
</script>
````

## File: frontend/admin/src/components/BookingEditModal.vue
````vue
<template>
  <div v-if="isOpen" class="fixed inset-0 bg-gray-500 bg-opacity-75 transition-opacity">
    <div class="fixed inset-0 z-10 overflow-y-auto">
      <div class="flex min-h-full items-end justify-center p-4 text-center sm:items-center sm:p-0">
        <div class="relative transform overflow-hidden rounded-lg bg-white px-4 pb-4 pt-5 text-left shadow-xl transition-all sm:my-8 sm:w-full sm:max-w-lg sm:p-6">
          <div class="absolute right-0 top-0 hidden pr-4 pt-4 sm:block">
            <Button
              @click="closeModal"
              variant="secondary"
              size="sm"
              className="rounded-md bg-white text-gray-400 hover:text-gray-500"
            >
              <span class="sr-only">Lukk</span>
              <svg class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke-width="1.5" stroke="currentColor">
                <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
              </svg>
            </Button>
          </div>
          <div class="sm:flex sm:items-start">
            <div class="mt-3 text-center sm:mt-0 sm:text-left w-full">
              <h3 class="text-lg font-semibold leading-6 text-gray-900">
                Rediger bestilling
              </h3>
              <div class="mt-4 space-y-4">
                <!-- Status -->
                <div>
                  <label class="block text-sm font-medium text-gray-700">Status</label>
                  <select
                    v-model="editedBooking.status"
                    class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm"
                  >
                    <option value="PENDING">Venter</option>
                    <option value="CONFIRMED">Bekreftet</option>
                    <option value="CANCELLED">Kansellert</option>
                    <option value="COMPLETED">Fullført</option>
                  </select>
                </div>
                <!-- Date and Time -->
                <div>
                  <label class="block text-sm font-medium text-gray-700">Dato og tid</label>
                  <input
                    type="datetime-local"
                    :value="formatDateForInput(editedBooking.startTime)"
                    @input="handleDateChange"
                    class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm"
                  />
                </div>
                <!-- Notes -->
                <div>
                  <label class="block text-sm font-medium text-gray-700">Notater</label>
                  <textarea
                    v-model="editedBooking.notes"
                    rows="3"
                    class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm"
                  ></textarea>
                </div>
              </div>
            </div>
          </div>
          <div class="mt-5 sm:mt-4 sm:flex sm:flex-row-reverse">
            <Button
              @click="handleSave"
              variant="primary"
              className="sm:ml-3"
            >
              Lagre endringer
            </Button>
            <Button
              @click="closeModal"
              variant="secondary"
            >
              Avbryt
            </Button>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>
<script setup lang="ts">
import { ref, watch } from 'vue';
import type { BookingView } from '../types';
import Button from './base/Button.vue';
const props = defineProps({
  isOpen: {
    type: Boolean,
    required: true
  },
  booking: {
    type: Object as () => BookingView | null,
    required: true
  }
});
const emit = defineEmits<{
  (e: 'close'): void;
  (e: 'save', booking: BookingView): void;
}>();
const editedBooking = ref<BookingView>({
  id: '',
  customerName: '',
  employeeName: '',
  serviceName: '',
  startTime: '',
  status: 'PENDING',
  notes: ''
});
watch(() => props.booking, (newBooking) => {
  if (newBooking) {
    editedBooking.value = { 
      ...newBooking,
      status: newBooking.status.toUpperCase() as BookingView['status']
    };
  }
}, { immediate: true });
const formatDateForInput = (dateString: string | undefined) => {
  if (!dateString) return '';
  try {
    const date = new Date(dateString);
    // Format: YYYY-MM-DDThh:mm
    return date.toISOString().slice(0, 16);
  } catch (error) {
    console.error('Error formatting date for input:', error);
    return '';
  }
};
const handleDateChange = (event: Event) => {
  const input = event.target as HTMLInputElement;
  editedBooking.value.startTime = input.value;
};
const closeModal = () => {
  emit('close');
};
const handleSave = () => {
  emit('save', editedBooking.value);
};
</script>
````

## File: frontend/admin/src/components/HelloWorld.vue
````vue
<script setup lang="ts">
import { ref } from "vue";
defineProps<{ msg: string }>();
const count = ref(0);
</script>
<template>
  <h1>{{ msg }}</h1>
  <div class="card">
    <button type="button" @click="count++">count is {{ count }}</button>
    <p>
      Edit
      <code>components/HelloWorld.vue</code> to test HMR
    </p>
  </div>
  <p>
    Check out
    <a href="https://vuejs.org/guide/quick-start.html#local" target="_blank"
      >create-vue</a
    >, the official Vue + Vite starter
  </p>
  <p>
    Learn more about IDE Support for Vue in the
    <a
      href="https://vuejs.org/guide/scaling-up/tooling.html#ide-support"
      target="_blank"
      >Vue Docs Scaling up Guide</a
    >.
  </p>
  <p class="read-the-docs">Click on the Vite and Vue logos to learn more</p>
</template>
<style scoped>
.read-the-docs {
  color: #888;
}
</style>
````

## File: frontend/admin/src/components/OrdersChart.vue
````vue
<template>
  <div class="bg-white rounded-lg">
    <canvas ref="chartRef"></canvas>
  </div>
</template>
<script setup lang="ts">
import { ref, onMounted, watch, computed } from 'vue';
import { Chart, type TooltipItem } from 'chart.js/auto';
import type { Order } from '../types';
const props = defineProps({
  orders: {
    type: Array as () => Order[],
    required: true
  }
});
const chartRef = ref<HTMLCanvasElement | null>(null);
let chart: Chart | null = null;
const chartTitle = computed(() => {
  if (props.orders.length === 0) return 'Omsetning per time';
  // Check if all orders are from the same employee
  const firstEmployeeId = props.orders[0].booking.employee.id;
  const allSameEmployee = props.orders.every(order => order.booking.employee.id === firstEmployeeId);
  if (allSameEmployee) {
    const employeeName = `${props.orders[0].booking.employee.user.firstName} ${props.orders[0].booking.employee.user.lastName}`;
    return `Omsetning per time - ${employeeName}`;
  }
  return 'Omsetning per time';
});
function prepareChartData() {
  // Group orders by hour and calculate total amount for each hour
  const ordersByHour = props.orders.reduce((acc: Record<string, number>, order: Order) => {
    const date = new Date(order.completedAt);
    const hour = date.getHours().toString().padStart(2, '0') + ':00';
    acc[hour] = (acc[hour] || 0) + parseFloat(order.totalAmount);
    return acc;
  }, {});
  // Create array of all hours from 00:00 to 23:00
  const allHours = Array.from({ length: 24 }, (_, i) => 
    `${i.toString().padStart(2, '0')}:00`
  );
  // Sort hours and ensure all hours are represented
  const sortedHours = allHours.sort();
  const data = sortedHours.map(hour => ordersByHour[hour] || 0);
  return {
    labels: sortedHours,
    datasets: [{
      label: 'Omsetning per time',
      data: data,
      backgroundColor: 'rgba(79, 70, 229, 0.2)',
      borderColor: 'rgb(79, 70, 229)',
      borderWidth: 1
    }]
  };
}
function createChart(): void {
  if (!chartRef.value) return;
  const ctx = chartRef.value.getContext('2d');
  if (!ctx) return;
  // Destroy existing chart if it exists
  if (chart) {
    chart.destroy();
  }
  chart = new Chart(ctx, {
    type: 'bar',
    data: prepareChartData(),
    options: {
      responsive: true,
      maintainAspectRatio: false,
      scales: {
        y: {
          beginAtZero: true,
          ticks: {
            callback: function(tickValue: number | string): string {
              const value = typeof tickValue === 'string' ? parseFloat(tickValue) : tickValue;
              return new Intl.NumberFormat('nb-NO', {
                style: 'currency',
                currency: 'NOK',
                minimumFractionDigits: 0,
                maximumFractionDigits: 0
              }).format(value);
            }
          }
        }
      },
      plugins: {
        title: {
          display: true,
          text: chartTitle.value,
          font: {
            size: 16,
            weight: 'bold'
          }
        },
        tooltip: {
          callbacks: {
            label: function(tooltipItem: TooltipItem<'bar'>): string {
              const value = typeof tooltipItem.raw === 'number' ? tooltipItem.raw : 0;
              return new Intl.NumberFormat('nb-NO', {
                style: 'currency',
                currency: 'NOK',
                minimumFractionDigits: 2,
                maximumFractionDigits: 2
              }).format(value);
            }
          }
        }
      }
    }
  });
}
watch([() => props.orders, chartTitle], () => {
  createChart();
}, { deep: true });
onMounted(() => {
  createChart();
});
</script>
````

## File: frontend/admin/src/router/index.ts
````typescript
import { createRouter, createWebHistory } from "vue-router";
import { useAuthStore } from "../stores/auth";
const routes = [
  {
    path: "/login",
    name: "Login",
    component: () => import("../views/LoginView.vue"),
    meta: { requiresAuth: false },
  },
  {
    path: "/dashboard",
    name: "Dashboard",
    component: () => import("../views/DashboardView.vue"),
    meta: { requiresAuth: true },
  },
  {
    path: "/bookings",
    name: "Bookings",
    component: () => import("../views/BookingsView.vue"),
    meta: { requiresAuth: true },
  },
  {
    path: "/orders",
    name: "Orders",
    component: () => import("../views/OrdersView.vue"),
    meta: { requiresAuth: true },
  },
  {
    path: "/employees",
    name: "Employees",
    component: () => import("../views/EmployeesView.vue"),
    meta: { requiresAuth: true, requiresAdmin: true },
  },
  {
    path: "/",
    redirect: "/dashboard",
  },
];
const router = createRouter({
  history: createWebHistory(),
  routes,
});
// Navigation guard
router.beforeEach(async (to, from, next) => {
  const authStore = useAuthStore();
  const requiresAuth = to.meta.requiresAuth !== false;
  const requiresAdmin = to.meta.requiresAdmin === true;
  if (requiresAuth) {
    const isAuthenticated = await authStore.checkAuth();
    if (!isAuthenticated && to.name !== "Login") {
      next({ name: "Login" });
      return;
    }
    // Check admin access
    if (requiresAdmin && !authStore.isAdmin) {
      next({ name: "Dashboard" });
      return;
    }
  }
  if (to.name === "Login" && authStore.isAuthenticated) {
    next({ name: "Dashboard" });
    return;
  }
  next();
});
export default router;
````

## File: frontend/admin/src/stores/__tests__/auth.spec.ts
````typescript
import { describe, it, expect, beforeEach, vi } from "vitest";
import { setActivePinia, createPinia } from "pinia";
import { useAuthStore } from "../auth";
import axios from "axios";
vi.mock("axios");
describe("Auth Store", () => {
  beforeEach(() => {
    setActivePinia(createPinia());
    localStorage.clear();
    vi.clearAllMocks();
  });
  describe("Initial State", () => {
    it("should have correct initial state", () => {
      const store = useAuthStore();
      expect(store.token).toBeNull();
      expect(store.user).toBeNull();
      expect(store.isAuthenticated).toBeFalsy();
      expect(store.error).toBeNull();
      expect(store.isLoading).toBeFalsy();
    });
    it("should initialize with token from localStorage", () => {
      localStorage.setItem("admin_token", "test-token");
      const store = useAuthStore();
      expect(store.token).toBe("test-token");
      expect(store.isAuthenticated).toBeTruthy();
    });
  });
  describe("Login", () => {
    const mockCredentials = {
      email: "admin@test.com",
      password: "password123",
    };
    const mockAdminResponse = {
      data: {
        token: "test-token",
        user: {
          id: "1",
          email: "admin@test.com",
          role: "admin",
          firstName: "Admin",
          lastName: "User"
        },
      },
    };
    it("should successfully login admin user", async () => {
      vi.mocked(axios.post).mockResolvedValueOnce(mockAdminResponse);
      const store = useAuthStore();
      const success = await store.login(mockCredentials);
      expect(success).toBeTruthy();
      expect(store.token).toBe("test-token");
      expect(store.user).toEqual(mockAdminResponse.data.user);
      expect(store.isAuthenticated).toBeTruthy();
      expect(store.error).toBeNull();
      expect(localStorage.getItem("admin_token")).toBe("test-token");
      expect(axios.defaults.headers.common["Authorization"]).toBe(
        "Bearer test-token",
      );
    });
    it("should handle login error with invalid credentials", async () => {
      vi.mocked(axios.post).mockRejectedValueOnce({
        response: {
          status: 401,
          data: { message: "Invalid credentials" }
        },
        isAxiosError: true,
      });
      const store = useAuthStore();
      const success = await store.login(mockCredentials);
      expect(success).toBeFalsy();
      expect(store.error).toBe("Feil e-postadresse eller passord");
      expect(store.isAuthenticated).toBeFalsy();
      expect(localStorage.getItem("admin_token")).toBeNull();
    });
    it("should handle server connection error", async () => {
      vi.mocked(axios.post).mockRejectedValueOnce({
        code: "ECONNREFUSED",
        isAxiosError: true,
      });
      const store = useAuthStore();
      const success = await store.login(mockCredentials);
      expect(success).toBeFalsy();
      expect(store.error).toBe("Kunne ikke koble til serveren. Sjekk internettforbindelsen din");
      expect(store.isAuthenticated).toBeFalsy();
    });
  });
  describe("Logout", () => {
    it("should clear auth state and localStorage", () => {
      const store = useAuthStore();
      // Setup initial authenticated state
      localStorage.setItem("admin_token", "test-token");
      store.$patch({
        token: "test-token",
        user: {
          id: "1",
          email: "admin@test.com",
          role: "admin",
          firstName: "Admin",
          lastName: "User"
        },
        isAuthenticated: true,
      });
      store.logout();
      expect(store.token).toBeNull();
      expect(store.user).toBeNull();
      expect(store.isAuthenticated).toBeFalsy();
      expect(store.error).toBeNull();
      expect(localStorage.getItem("admin_token")).toBeNull();
      expect(axios.defaults.headers.common["Authorization"]).toBeUndefined();
    });
  });
  describe("Check Auth", () => {
    it("should handle valid token", async () => {
      localStorage.setItem("admin_token", "test-token");
      const store = useAuthStore();
      const isValid = await store.checkAuth();
      expect(isValid).toBeTruthy();
      expect(store.token).toBe("test-token");
      expect(store.isAuthenticated).toBeTruthy();
      expect(axios.defaults.headers.common["Authorization"]).toBe(
        "Bearer test-token",
      );
    });
    it("should handle invalid token", async () => {
      // Don't set token in localStorage
      const store = useAuthStore();
      const isValid = await store.checkAuth();
      expect(isValid).toBeFalsy();
      expect(store.token).toBeNull();
      expect(store.isAuthenticated).toBeFalsy();
      expect(localStorage.getItem("admin_token")).toBeNull();
    });
    it("should handle missing token", async () => {
      const store = useAuthStore();
      const isValid = await store.checkAuth();
      expect(isValid).toBeFalsy();
      expect(store.user).toBeNull();
      expect(store.isAuthenticated).toBeFalsy();
    });
  });
  describe("Error Handling", () => {
    it("should clear error message", () => {
      const store = useAuthStore();
      // Set an error
      store.$patch({ error: "Test error" });
      expect(store.error).toBe("Test error");
      // Clear error
      store.clearError();
      expect(store.error).toBeNull();
    });
  });
});
````

## File: frontend/admin/src/stores/bookings.ts
````typescript
import { defineStore } from "pinia";
import axios, { AxiosError } from "axios";
import { useAuthStore } from "./auth";
import { useOrdersStore } from "./orders";
import router from "../router";
import type { BookingView } from "../types";
interface BookingsState {
  bookings: BookingView[];
  totalBookings: number;
  todayBookings: number;
  upcomingBookings: number;
  isLoading: boolean;
  error: string | null;
  lastFetched: number | null;
}
const CACHE_DURATION = 60000; // 60 seconds
export const useBookingStore = defineStore("bookings", {
  state: (): BookingsState => ({
    bookings: [],
    totalBookings: 0,
    todayBookings: 0,
    upcomingBookings: 0,
    isLoading: false,
    error: null,
    lastFetched: null,
  }),
  actions: {
    shouldRefetch(): boolean {
      if (!this.lastFetched) return true;
      return Date.now() - this.lastFetched > CACHE_DURATION;
    },
    async fetchDashboardStats(forceRefresh = false) {
      // Return cached data if it's still fresh
      if (!forceRefresh && !this.shouldRefetch() && this.bookings.length > 0) {
        this.isLoading = false; // Ensure loading is false when using cache
        return;
      }
      try {
        const authStore = useAuthStore();
        if (!authStore.isAuthenticated || !authStore.token) {
          router.push({ name: "Login" });
          return;
        }
        // Only set loading to true if we're actually fetching
        this.isLoading = true;
        // Ensure the Authorization header is set
        axios.defaults.headers.common["Authorization"] = `Bearer ${authStore.token}`;
        const response = await axios.get<BookingView[]>(
          `${import.meta.env.VITE_API_URL}/bookings/upcoming`,
        );
        // Store the bookings directly
        this.bookings = response.data;
        this.lastFetched = Date.now();
        this.calculateMetrics();
        console.log('Fetched bookings:', this.bookings);
      } catch (error) {
        if (error instanceof AxiosError) {
          if (error.response?.status === 401) {
            const authStore = useAuthStore();
            authStore.logout();
            router.push({ name: "Login" });
            this.error = "Økt utløpt. Vennligst logg inn igjen.";
          } else {
            this.error = error.response?.data?.message || "Kunne ikke hente bestillinger";
          }
        } else {
          this.error =
            error instanceof Error ? error.message : "Kunne ikke hente bestillinger";
        }
        console.error("Error fetching bookings:", error);
      } finally {
        this.isLoading = false;
      }
    },
    async fetchUpcomingBookings(forceRefresh = false) {
      // Return cached data if it's still fresh
      if (!forceRefresh && !this.shouldRefetch() && this.bookings.length > 0) {
        this.isLoading = false; // Ensure loading is false when using cache
        return;
      }
      try {
        const authStore = useAuthStore();
        if (!authStore.isAuthenticated || !authStore.token) {
          router.push({ name: "Login" });
          return;
        }
        // Only set loading to true if we're actually fetching
        this.isLoading = true;
        // Ensure the Authorization header is set
        axios.defaults.headers.common["Authorization"] = `Bearer ${authStore.token}`;
        const response = await axios.get<BookingView[]>(
          `${import.meta.env.VITE_API_URL}/bookings/upcoming`,
        );
        // Store the bookings directly
        this.bookings = response.data;
        this.lastFetched = Date.now();
        console.log('Fetched upcoming bookings:', this.bookings);
      } catch (error) {
        if (error instanceof AxiosError) {
          if (error.response?.status === 401) {
            const authStore = useAuthStore();
            authStore.logout();
            router.push({ name: "Login" });
            this.error = "Økt utløpt. Vennligst logg inn igjen.";
          } else {
            this.error = error.response?.data?.message || "Kunne ikke hente kommende bestillinger";
          }
        } else {
          this.error =
            error instanceof Error
              ? error.message
              : "Kunne ikke hente kommende bestillinger";
        }
        console.error("Error fetching upcoming bookings:", error);
      } finally {
        this.isLoading = false;
      }
    },
    async completeBooking(id: number | string) {
      try {
        const authStore = useAuthStore();
        const ordersStore = useOrdersStore();
        if (!authStore.isAuthenticated || !authStore.token) {
          router.push({ name: "Login" });
          return false;
        }
        // Ensure the Authorization header is set
        axios.defaults.headers.common["Authorization"] = `Bearer ${authStore.token}`;
        console.log('Completing booking:', id);
        const response = await axios.put(`${import.meta.env.VITE_API_URL}/bookings/${id}/complete`);
        console.log('Complete booking response:', response.data);
        // Force refresh both bookings and orders
        await Promise.all([
          this.fetchDashboardStats(true),
          ordersStore.fetchOrders(true)
        ]);
        return true;
      } catch (error) {
        console.error('Error details:', error);
        if (error instanceof AxiosError) {
          if (error.response?.status === 401) {
            const authStore = useAuthStore();
            authStore.logout();
            router.push({ name: "Login" });
            this.error = "Økt utløpt. Vennligst logg inn igjen.";
          } else {
            this.error = error.response?.data?.message || "Kunne ikke fullføre bestilling";
          }
        } else {
          this.error =
            error instanceof Error ? error.message : "Kunne ikke fullføre bestilling";
        }
        console.error("Error completing booking:", error);
        return false;
      }
    },
    async cancelBooking(id: number | string) {
      try {
        const authStore = useAuthStore();
        if (!authStore.isAuthenticated || !authStore.token) {
          router.push({ name: "Login" });
          return false;
        }
        // Ensure the Authorization header is set
        axios.defaults.headers.common["Authorization"] = `Bearer ${authStore.token}`;
        await axios.put(`${import.meta.env.VITE_API_URL}/bookings/${id}/cancel`);
        // Force refresh the bookings list after cancellation
        await this.fetchDashboardStats(true);
        return true;
      } catch (error) {
        if (error instanceof AxiosError) {
          if (error.response?.status === 401) {
            const authStore = useAuthStore();
            authStore.logout();
            router.push({ name: "Login" });
            this.error = "Økt utløpt. Vennligst logg inn igjen.";
          } else {
            this.error = error.response?.data?.message || "Kunne ikke kansellere bestilling";
          }
        } else {
          this.error =
            error instanceof Error ? error.message : "Kunne ikke kansellere bestilling";
        }
        console.error("Error canceling booking:", error);
        return false;
      }
    },
    async updateBooking(id: number | string, data: Partial<BookingView>) {
      try {
        const authStore = useAuthStore();
        if (!authStore.isAuthenticated || !authStore.token) {
          router.push({ name: "Login" });
          return false;
        }
        // Ensure the Authorization header is set
        axios.defaults.headers.common["Authorization"] = `Bearer ${authStore.token}`;
        await axios.put(`${import.meta.env.VITE_API_URL}/bookings/${id}`, data);
        // Force refresh the bookings list after update
        await this.fetchDashboardStats(true);
        return true;
      } catch (error) {
        if (error instanceof AxiosError) {
          if (error.response?.status === 401) {
            const authStore = useAuthStore();
            authStore.logout();
            router.push({ name: "Login" });
            this.error = "Økt utløpt. Vennligst logg inn igjen.";
          } else {
            this.error = error.response?.data?.message || "Kunne ikke oppdatere bestilling";
          }
        } else {
          this.error =
            error instanceof Error ? error.message : "Kunne ikke oppdatere bestilling";
        }
        console.error("Error updating booking:", error);
        return false;
      }
    },
    calculateMetrics() {
      const now = new Date();
      const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
      this.totalBookings = this.bookings.length;
      this.todayBookings = this.bookings.filter(
        (booking) =>
          new Date(booking.startTime).toDateString() === today.toDateString(),
      ).length;
      this.upcomingBookings = this.bookings.length; // All bookings from /bookings/upcoming are upcoming
    },
  },
});
````

## File: frontend/admin/src/stores/employees.ts
````typescript
import { defineStore } from 'pinia'
import axios, { AxiosError } from 'axios'
import { useAuthStore } from './auth'
import router from '../router'
import type { Employee } from '../types'
interface EmployeeState {
  employees: Employee[]
  loading: boolean
  error: string | null
}
interface CreateEmployeeResponse {
  employee: Employee;
  temporaryPassword: string;
}
interface ResetPasswordResponse {
  temporaryPassword: string;
}
export const useEmployeesStore = defineStore('employees', {
  state: (): EmployeeState => ({
    employees: [],
    loading: false,
    error: null
  }),
  getters: {
    getActiveEmployees: (state) => state.employees.filter(emp => emp.isActive),
    getEmployeeById: (state) => (id: string) => 
      state.employees.find(emp => emp.id === id)
  },
  actions: {
    async fetchEmployees() {
      this.loading = true
      this.error = null
      try {
        const authStore = useAuthStore();
        if (!authStore.isAuthenticated || !authStore.token) {
          router.push({ name: "Login" });
          return;
        }
        axios.defaults.headers.common["Authorization"] = `Bearer ${authStore.token}`;
        const response = await axios.get(`${import.meta.env.VITE_API_URL}/employees`)
        this.employees = response.data
      } catch (error) {
        console.error('Error details:', error);
        if (error instanceof AxiosError) {
          if (error.response?.status === 401) {
            const authStore = useAuthStore();
            authStore.logout();
            router.push({ name: "Login" });
            this.error = "Økt utløpt. Vennligst logg inn igjen.";
          } else {
            this.error = error.response?.data?.message || "Kunne ikke hente ansatte";
          }
        } else {
          this.error = error instanceof Error ? error.message : "Kunne ikke hente ansatte";
        }
      } finally {
        this.loading = false
      }
    },
    async createEmployee(employeeData: Partial<Employee>): Promise<CreateEmployeeResponse> {
      this.loading = true
      this.error = null
      try {
        const authStore = useAuthStore();
        if (!authStore.isAuthenticated || !authStore.token) {
          router.push({ name: "Login" });
          throw new Error("Ikke autentisert");
        }
        axios.defaults.headers.common["Authorization"] = `Bearer ${authStore.token}`;
        const response = await axios.post<CreateEmployeeResponse>(`${import.meta.env.VITE_API_URL}/employees`, employeeData)
        console.log('Create employee response:', {
          ...response.data,
          temporaryPassword: response.data.temporaryPassword ? '[HIDDEN]' : undefined
        });
        if (response.data.employee) {
          this.employees.push(response.data.employee);
        }
        return response.data;
      } catch (error) {
        console.error('Error details:', error);
        if (error instanceof AxiosError) {
          if (error.response?.status === 401) {
            const authStore = useAuthStore();
            authStore.logout();
            router.push({ name: "Login" });
            this.error = "Økt utløpt. Vennligst logg inn igjen.";
          } else {
            this.error = error.response?.data?.message || "Kunne ikke opprette ansatt";
          }
        } else {
          this.error = error instanceof Error ? error.message : "Kunne ikke opprette ansatt";
        }
        throw error;
      } finally {
        this.loading = false
      }
    },
    async resetPassword(id: string): Promise<ResetPasswordResponse> {
      this.loading = true
      this.error = null
      try {
        const authStore = useAuthStore();
        if (!authStore.isAuthenticated || !authStore.token) {
          router.push({ name: "Login" });
          throw new Error("Ikke autentisert");
        }
        axios.defaults.headers.common["Authorization"] = `Bearer ${authStore.token}`;
        const response = await axios.post<ResetPasswordResponse>(
          `${import.meta.env.VITE_API_URL}/employees/${id}/reset-password`
        );
        return response.data;
      } catch (error) {
        console.error('Error details:', error);
        if (error instanceof AxiosError) {
          if (error.response?.status === 401) {
            const authStore = useAuthStore();
            authStore.logout();
            router.push({ name: "Login" });
            this.error = "Økt utløpt. Vennligst logg inn igjen.";
          } else {
            this.error = error.response?.data?.message || "Kunne ikke tilbakestille passord";
          }
        } else {
          this.error = error instanceof Error ? error.message : "Kunne ikke tilbakestille passord";
        }
        throw error;
      } finally {
        this.loading = false
      }
    },
    async updateEmployee(id: string, employeeData: Partial<Employee>) {
      this.loading = true
      this.error = null
      try {
        const authStore = useAuthStore();
        if (!authStore.isAuthenticated || !authStore.token) {
          router.push({ name: "Login" });
          return;
        }
        axios.defaults.headers.common["Authorization"] = `Bearer ${authStore.token}`;
        const response = await axios.patch(`${import.meta.env.VITE_API_URL}/employees/${id}`, employeeData)
        const index = this.employees.findIndex(emp => emp.id === id)
        if (index !== -1) {
          this.employees[index] = response.data
        }
        return response.data
      } catch (error) {
        console.error('Error details:', error);
        if (error instanceof AxiosError) {
          if (error.response?.status === 401) {
            const authStore = useAuthStore();
            authStore.logout();
            router.push({ name: "Login" });
            this.error = "Økt utløpt. Vennligst logg inn igjen.";
          } else {
            this.error = error.response?.data?.message || "Kunne ikke oppdatere ansatt";
          }
        } else {
          this.error = error instanceof Error ? error.message : "Kunne ikke oppdatere ansatt";
        }
        throw error;
      } finally {
        this.loading = false
      }
    },
    async deleteEmployee(id: string) {
      this.loading = true
      this.error = null
      try {
        const authStore = useAuthStore();
        if (!authStore.isAuthenticated || !authStore.token) {
          router.push({ name: "Login" });
          return;
        }
        axios.defaults.headers.common["Authorization"] = `Bearer ${authStore.token}`;
        await axios.delete(`${import.meta.env.VITE_API_URL}/employees/${id}`)
        this.employees = this.employees.filter(emp => emp.id !== id)
      } catch (error) {
        console.error('Error details:', error);
        if (error instanceof AxiosError) {
          if (error.response?.status === 401) {
            const authStore = useAuthStore();
            authStore.logout();
            router.push({ name: "Login" });
            this.error = "Økt utløpt. Vennligst logg inn igjen.";
          } else {
            this.error = error.response?.data?.message || "Kunne ikke slette ansatt";
          }
        } else {
          this.error = error instanceof Error ? error.message : "Kunne ikke slette ansatt";
        }
        throw error;
      } finally {
        this.loading = false
      }
    }
  }
})
````

## File: frontend/admin/src/stores/orders.ts
````typescript
import { defineStore } from "pinia";
import axios, { AxiosError } from "axios";
import { useAuthStore } from "./auth";
import type { Order } from "../types";
const API_URL = import.meta.env.VITE_API_URL;
interface OrdersState {
  orders: Order[];
  loading: boolean;
  error: string | null;
}
interface EmployeeStats {
  id: string;
  count: number;
  revenue: number;
}
export const useOrdersStore = defineStore("orders", {
  state: (): OrdersState => ({
    orders: [],
    loading: false,
    error: null,
  }),
  getters: {
    getOrdersByEmployee: (state) => (employeeId: string) => {
      return state.orders.filter(
        (order) => order.booking.employee.id === employeeId
      );
    },
    getEmployeeStats: (state) => {
      const stats = new Map<string, EmployeeStats>();
      state.orders.forEach((order) => {
        const employeeId = order.booking.employee.id;
        const amount = parseFloat(order.totalAmount);
        if (!stats.has(employeeId)) {
          stats.set(employeeId, {
            id: employeeId,
            count: 0,
            revenue: 0,
          });
        }
        const employeeStats = stats.get(employeeId)!;
        employeeStats.count++;
        employeeStats.revenue += amount;
      });
      return Array.from(stats.values());
    },
  },
  actions: {
    async fetchOrders(forceRefresh = false) {
      try {
        if (this.loading && !forceRefresh) return;
        this.loading = true;
        this.error = null;
        const authStore = useAuthStore();
        let endpoint = `${API_URL}/orders`;
        // If user is an employee, use the employee-specific endpoint
        if (!authStore.isAdmin && authStore.user?.id) {
          endpoint = `${API_URL}/orders/employee/${authStore.user.id}`;
        }
        const response = await axios.get<Order[]>(endpoint);
        this.orders = response.data;
      } catch (error) {
        console.error("Error fetching orders:", error);
        if (error instanceof AxiosError && error.response?.status === 403) {
          this.error = "Ingen tilgang: Du har ikke tillatelse til å se disse ordrene";
        } else {
          this.error = "Kunne ikke hente ordrer. Vennligst prøv igjen senere.";
        }
      } finally {
        this.loading = false;
      }
    },
  },
});
````

## File: frontend/admin/src/types/components/button.ts
````typescript
export type ButtonVariant = 'primary' | 'secondary' | 'danger';
export type ButtonSize = 'sm' | 'md' | 'lg';
export type ButtonType = 'button' | 'submit' | 'reset';
export interface ButtonProps {
  variant?: ButtonVariant;
  size?: ButtonSize;
  type?: ButtonType;
  disabled?: boolean;
  loading?: boolean;
  className?: string;
}
````

## File: frontend/admin/src/types/components/index.ts
````typescript
export type ButtonVariant = 'primary' | 'secondary' | 'danger';
export type ButtonSize = 'sm' | 'md' | 'lg';
export type ButtonType = 'button' | 'submit' | 'reset';
export interface ButtonProps {
  variant?: ButtonVariant;
  size?: ButtonSize;
  type?: ButtonType;
  disabled?: boolean;
  loading?: boolean;
  className?: string;
}
export type CardColor = 'indigo' | 'green' | 'blue' | 'red' | 'yellow';
export interface CardProps {
  title: string;
  value: string | number;
  color?: CardColor;
}
````

## File: frontend/admin/src/types/index.ts
````typescript
export interface Order {
  id: string
  completedAt: string
  totalAmount: string
  notes: string
  createdAt: string
  updatedAt: string
  booking: Booking
}
export interface Booking {
  id: string
  startTime: string
  endTime: string
  status: 'CONFIRMED' | 'PENDING' | 'CANCELLED' | 'COMPLETED'
  notes: string
  totalPrice: string
  reminderSent: boolean
  cancelledAt: string | null
  cancellationReason: string | null
  createdAt: string
  updatedAt: string
  customer: Customer
  employee: Employee
  service: Service
}
// This interface represents the simplified booking data used in views
export interface BookingView {
  id: string | number;
  customerName: string;
  employeeName: string;
  serviceName: string;
  startTime: string;
  status: 'CONFIRMED' | 'PENDING' | 'CANCELLED' | 'COMPLETED';
  notes?: string;
}
export interface Customer {
  id: string
  firstName: string
  lastName: string
  email: string
  phoneNumber: string
  role: string
  createdAt: string
  updatedAt: string
}
export interface Employee {
  id: string
  specializations: string[]
  availability: {
    [key: string]: Array<{ start: string; end: string }>
  }
  isActive: boolean
  createdAt: string
  updatedAt: string
  user: {
    id: string
    firstName: string
    lastName: string
    email: string
    role: string
  }
}
export interface Service {
  id: string
  name: string
  description: string
  duration: number
  price: string
  isActive: boolean
  createdAt: string
  updatedAt: string
}
````

## File: frontend/admin/src/views/__tests__/DashboardView.spec.ts
````typescript
import { describe, it, expect, beforeEach, vi } from "vitest";
import { mount, flushPromises } from "@vue/test-utils";
import { createPinia, setActivePinia } from "pinia";
import { createRouter, createWebHistory } from 'vue-router';
import DashboardView from "../DashboardView.vue";
// Create mock router
const router = createRouter({
  history: createWebHistory(),
  routes: [
    {
      path: '/',
      component: DashboardView
    }
  ]
});
// Mock the store
const createMockStore = () => ({
  bookings: [],
  totalBookings: 0,
  todayBookings: 0,
  upcomingBookings: 0,
  isLoading: false,
  error: null,
  fetchDashboardStats: vi.fn().mockResolvedValue(undefined),
  fetchUpcomingBookings: vi.fn().mockResolvedValue(undefined),
});
let mockStore = createMockStore();
// Mock the store module with the correct path
vi.mock("@/stores/bookings", () => ({
  useBookingStore: () => mockStore
}));
describe("DashboardView", () => {
  beforeEach(() => {
    setActivePinia(createPinia());
    mockStore = createMockStore();
    vi.clearAllMocks();
  });
  const mountComponent = async () => {
    const wrapper = mount(DashboardView, {
      global: {
        plugins: [router],
        stubs: {
          RouterLink: true
        }
      }
    });
    await flushPromises();
    return wrapper;
  };
  it("should render statistics cards", async () => {
    const wrapper = await mountComponent();
    // Test statistics section exists
    const statsSection = wrapper.find('[data-test="statistics-cards"]');
    expect(statsSection.exists()).toBe(true);
    // Test individual stat cards
    expect(wrapper.find('[data-test="total-bookings"]').exists()).toBe(true);
    expect(wrapper.find('[data-test="today-bookings"]').exists()).toBe(true);
    expect(wrapper.find('[data-test="upcoming-bookings"]').exists()).toBe(true);
  });
  it("should display bookings table", async () => {
    const wrapper = await mountComponent();
    // Test bookings table exists
    const bookingsTable = wrapper.find('[data-test="bookings-table"]');
    expect(bookingsTable.exists()).toBe(true);
    // Test table headers
    const headers = wrapper.findAll("th");
    expect(headers.length).toBeGreaterThan(0);
    expect(headers.some((header) => header.text().includes("Kunde"))).toBe(
      true,
    );
    expect(headers.some((header) => header.text().includes("Tjeneste"))).toBe(
      true,
    );
    expect(headers.some((header) => header.text().includes("Dato"))).toBe(true);
  });
  it("should load dashboard data on mount", async () => {
    await mountComponent();
    await flushPromises();
    // Verify store actions were called
    expect(mockStore.fetchDashboardStats).toHaveBeenCalledTimes(1);
  });
  it("should show loading state while fetching data", async () => {
    // Set loading state before mounting
    mockStore.isLoading = true;
    const wrapper = await mountComponent();
    // Test loading state is shown
    const loadingState = wrapper.find('[data-test="loading-state"]');
    expect(loadingState.exists()).toBe(true);
    expect(loadingState.text()).toContain("Laster bestillinger");
    mockStore.isLoading = false;
  });
  it("should display refresh button", async () => {
    const wrapper = await mountComponent();
    // Test refresh button exists
    const refreshButton = wrapper.find('[data-test="refresh-button"]');
    expect(refreshButton.exists()).toBe(true);
    expect(refreshButton.text()).toBe("Oppdater");
  });
  it("should handle refresh click", async () => {
    const wrapper = await mountComponent();
    // Clear mock calls from mounting
    mockStore.fetchDashboardStats.mockClear();
    // Click refresh button
    const refreshButton = wrapper.find('[data-test="refresh-button"]');
    await refreshButton.trigger("click");
    await flushPromises();
    // Verify store action was called with forceRefresh=true
    expect(mockStore.fetchDashboardStats).toHaveBeenCalledWith(true);
    expect(mockStore.fetchDashboardStats).toHaveBeenCalledTimes(1);
  });
});
````

## File: frontend/admin/src/views/BookingsView.vue
````vue
<template>
  <div class="p-6">
    <div class="max-w-7xl mx-auto">
      <h1 class="text-2xl font-bold text-gray-900 mb-6">Bestillinger</h1>
      <!-- Stats Cards -->
      <div class="grid grid-cols-1 md:grid-cols-2 gap-6 mb-8">
        <Card
          title="Totalt antall bestillinger"
          :value="bookingStore.bookings.length"
          color="indigo"
        >
          <template #icon>
            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2" />
            </svg>
          </template>
        </Card>
        <Card
          title="Aktive bestillinger"
          :value="activeBookings.length"
          color="green"
        >
          <template #icon>
            <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6" fill="none" viewBox="0 0 24 24" stroke="currentColor">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
            </svg>
          </template>
        </Card>
      </div>
      <!-- Bookings Table -->
      <div class="mt-8 flex flex-col">
        <div class="-my-2 overflow-x-auto">
          <div class="inline-block min-w-full py-2 align-middle">
            <div
              class="overflow-hidden shadow ring-1 ring-black ring-opacity-5 md:rounded-lg"
            >
              <table class="min-w-full divide-y divide-gray-300">
                <thead class="bg-gray-50">
                  <tr>
                    <th
                      scope="col"
                      class="px-3 py-3.5 text-left text-sm font-semibold text-gray-900"
                    >
                      Dato og tid
                    </th>
                    <th
                      scope="col"
                      class="px-3 py-3.5 text-left text-sm font-semibold text-gray-900"
                    >
                      Kunde
                    </th>
                    <th
                      scope="col"
                      class="px-3 py-3.5 text-left text-sm font-semibold text-gray-900"
                    >
                      Tjeneste
                    </th>
                    <th
                      scope="col"
                      class="px-3 py-3.5 text-left text-sm font-semibold text-gray-900"
                    >
                      Ansatt
                    </th>
                    <th
                      scope="col"
                      class="px-3 py-3.5 text-left text-sm font-semibold text-gray-900"
                    >
                      Status
                    </th>
                    <th scope="col" class="relative py-3.5 pl-3 pr-4 sm:pr-6">
                      <span class="sr-only">Handlinger</span>
                    </th>
                  </tr>
                </thead>
                <tbody class="divide-y divide-gray-200 bg-white">
                  <tr v-if="bookingStore.isLoading">
                    <td
                      colspan="6"
                      class="px-3 py-4 text-sm text-gray-500 text-center"
                    >
                      Laster bestillinger...
                    </td>
                  </tr>
                  <tr v-else-if="bookingStore.error">
                    <td
                      colspan="6"
                      class="px-3 py-4 text-sm text-red-500 text-center"
                    >
                      {{ bookingStore.error }}
                    </td>
                  </tr>
                  <tr v-else-if="!bookingStore.bookings.length">
                    <td
                      colspan="6"
                      class="px-3 py-4 text-sm text-gray-500 text-center"
                    >
                      Ingen bestillinger funnet
                    </td>
                  </tr>
                  <tr
                    v-for="booking in activeBookings"
                    :key="booking.id"
                    class="hover:bg-gray-50"
                  >
                    <td
                      class="whitespace-nowrap px-3 py-4 text-sm text-gray-500"
                    >
                      {{ formatDateTime(booking.startTime) }}
                    </td>
                    <td
                      class="whitespace-nowrap px-3 py-4 text-sm text-gray-500"
                    >
                      {{ booking.customerName }}
                    </td>
                    <td
                      class="whitespace-nowrap px-3 py-4 text-sm text-gray-500"
                    >
                      {{ booking.serviceName }}
                    </td>
                    <td
                      class="whitespace-nowrap px-3 py-4 text-sm text-gray-500"
                    >
                      {{ booking.employeeName }}
                    </td>
                    <td class="whitespace-nowrap px-3 py-4 text-sm">
                      <span :class="getStatusClass(booking.status)">
                        {{ getStatusText(booking.status) }}
                      </span>
                    </td>
                    <td
                      class="relative whitespace-nowrap py-4 pl-3 pr-4 text-right text-sm font-medium sm:pr-6"
                    >
                      <div class="flex justify-end space-x-2">
                        <Button
                          v-if="booking.status.toUpperCase() === 'PENDING'"
                          @click="handleConfirm(booking.id)"
                          variant="primary"
                          size="sm"
                        >
                          Bekreft
                        </Button>
                        <Button
                          v-if="booking.status.toUpperCase() === 'CONFIRMED'"
                          @click="handleComplete(booking.id)"
                          variant="primary"
                          size="sm"
                        >
                          Fullfør
                        </Button>
                        <Button
                          @click="openEditModal(booking)"
                          variant="secondary"
                          size="sm"
                        >
                          Rediger
                        </Button>
                        <Button
                          @click="handleCancel(booking.id)"
                          variant="danger"
                          size="sm"
                        >
                          Kanseller
                        </Button>
                      </div>
                    </td>
                  </tr>
                </tbody>
              </table>
            </div>
          </div>
        </div>
      </div>
    </div>
    <!-- Edit Modal -->
    <BookingEditModal
      :is-open="isEditModalOpen"
      :booking="selectedBooking"
      @close="closeEditModal"
      @save="handleSave"
    />
  </div>
</template>
<script setup lang="ts">
import { onMounted, ref, computed } from "vue";
import { useBookingStore } from "../stores/bookings";
import { useOrdersStore } from "../stores/orders";
import BookingEditModal from "../components/BookingEditModal.vue";
import Button from "../components/base/Button.vue";
import Card from "../components/base/Card.vue";
import type { BookingView } from "../types";
const bookingStore = useBookingStore();
const ordersStore = useOrdersStore();
const isEditModalOpen = ref(false);
const selectedBooking = ref<BookingView | null>(null);
// Filter to show active bookings (pending or confirmed)
const activeBookings = computed(() => {
  return bookingStore.bookings.filter(
    (booking) => 
      booking.status.toUpperCase() === "PENDING" || 
      booking.status.toUpperCase() === "CONFIRMED"
  );
});
const formatDateTime = (dateTime: string) => {
  try {
    const date = new Date(dateTime);
    return new Intl.DateTimeFormat("nb-NO", {
      year: "numeric",
      month: "long",
      day: "numeric",
      hour: "2-digit",
      minute: "2-digit",
    }).format(date);
  } catch (error) {
    console.error("Error formatting date:", error);
    return "Dato ikke tilgjengelig";
  }
};
const getStatusClass = (status: string) => {
  const upperStatus = status.toUpperCase();
  const classes = {
    PENDING: "bg-yellow-100 text-yellow-800",
    CONFIRMED: "bg-green-100 text-green-800",
    CANCELLED: "bg-red-100 text-red-800",
    COMPLETED: "bg-blue-100 text-blue-800",
  };
  return `inline-flex rounded-full px-2 text-xs font-semibold leading-5 ${
    classes[upperStatus as keyof typeof classes] || "bg-gray-100 text-gray-800"
  }`;
};
const getStatusText = (status: string) => {
  const upperStatus = status.toUpperCase();
  const statusMap = {
    PENDING: "Venter",
    CONFIRMED: "Bekreftet",
    CANCELLED: "Kansellert",
    COMPLETED: "Fullført",
  };
  return statusMap[upperStatus as keyof typeof statusMap] || "Ukjent";
};
const openEditModal = (booking: BookingView) => {
  selectedBooking.value = booking;
  isEditModalOpen.value = true;
};
const closeEditModal = () => {
  selectedBooking.value = null;
  isEditModalOpen.value = false;
};
const handleSave = async (updatedBooking: Partial<BookingView>) => {
  if (!selectedBooking.value?.id) return;
  const success = await bookingStore.updateBooking(
    selectedBooking.value.id,
    updatedBooking
  );
  if (success) {
    closeEditModal();
  }
};
const handleConfirm = async (id: string | number) => {
  const success = await bookingStore.updateBooking(id, { status: "CONFIRMED" });
  if (success) {
    console.log("Booking confirmed");
  }
};
const handleComplete = async (id: string | number) => {
  if (
    !confirm(
      "Er du sikker på at du vil markere denne bestillingen som fullført?"
    )
  ) {
    return;
  }
  console.log("Starting completion for booking:", id);
  const success = await bookingStore.completeBooking(id);
  if (success) {
    console.log("Booking completed successfully");
    // Force refresh both bookings and orders
    console.log("Refreshing bookings and orders...");
    await Promise.all([
      bookingStore.fetchUpcomingBookings(true),
      ordersStore.fetchOrders(true),
    ]);
    console.log("Refresh complete");
  } else {
    console.error("Failed to complete booking");
  }
};
const handleCancel = async (id: string | number) => {
  if (!confirm("Er du sikker på at du vil kansellere denne bestillingen?")) {
    return;
  }
  const success = await bookingStore.cancelBooking(id);
  if (success) {
    console.log("Bestilling kansellert");
  }
};
onMounted(() => {
  bookingStore.fetchUpcomingBookings();
});
</script>
````

## File: frontend/admin/src/views/DashboardView.vue
````vue
<template>
  <div class="p-6" data-test="dashboard-view">
    <div class="max-w-7xl mx-auto">
      <!-- Navigation -->
      <div class="mb-6 flex space-x-4">
        <Button
          variant="primary"
          @click="navigateToBookings"
        >
          Se alle bestillinger
        </Button>
        <Button
          variant="primary"
          @click="navigateToOrders"
        >
          Se fullførte bestillinger
        </Button>
      </div>
      <!-- Statistics Cards -->
      <div
        class="grid grid-cols-1 md:grid-cols-3 gap-6 mb-6"
        data-test="statistics-cards"
      >
        <div class="bg-white rounded-lg shadow p-6" data-test="total-bookings">
          <h3 class="text-lg font-semibold text-gray-900 mb-2">Totale bestillinger</h3>
          <p class="text-3xl font-bold text-indigo-600">
            {{ bookingStore.totalBookings }}
          </p>
        </div>
        <div class="bg-white rounded-lg shadow p-6" data-test="today-bookings">
          <h3 class="text-lg font-semibold text-gray-900 mb-2">
            Dagens bestillinger
          </h3>
          <p class="text-3xl font-bold text-indigo-600">
            {{ bookingStore.todayBookings }}
          </p>
        </div>
        <div class="bg-white rounded-lg shadow p-6" data-test="upcoming-bookings">
          <h3 class="text-lg font-semibold text-gray-900 mb-2">
            Kommende bestillinger
          </h3>
          <p class="text-3xl font-bold text-indigo-600">
            {{ bookingStore.upcomingBookings }}
          </p>
        </div>
      </div>
      <!-- Bookings Table -->
      <div class="bg-white rounded-lg shadow" data-test="bookings-table">
        <div class="p-6 border-b border-gray-200">
          <div class="flex justify-between items-center">
            <h2 class="text-xl font-semibold text-gray-900">Nylige bestillinger</h2>
            <Button
              @click="handleRefresh"
              data-test="refresh-button"
              variant="primary"
              :loading="bookingStore.isLoading"
            >
              Oppdater
            </Button>
          </div>
        </div>
        <div class="overflow-x-auto">
          <div
            v-if="bookingStore.isLoading"
            class="p-6 text-center text-gray-500"
            data-test="loading-state"
          >
            Laster bestillinger...
          </div>
          <div
            v-else-if="bookingStore.error"
            class="p-6 text-center text-red-500"
            data-test="error-state"
          >
            {{ bookingStore.error }}
          </div>
          <div
            v-else-if="!bookingStore.bookings.length"
            class="p-12 text-center"
            data-test="empty-state"
          >
            <h3 class="text-lg font-medium text-gray-900 mb-1">Ingen bestillinger</h3>
            <p class="text-sm text-gray-500">Det er ingen aktive bestillinger for øyeblikket.</p>
          </div>
          <table v-else class="min-w-full divide-y divide-gray-200">
            <thead class="bg-gray-50">
              <tr>
                <th
                  class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"
                >
                  ID
                </th>
                <th
                  class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"
                >
                  Kunde
                </th>
                <th
                  class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"
                >
                  Ansatt
                </th>
                <th
                  class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"
                >
                  Tjeneste
                </th>
                <th
                  class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"
                >
                  Dato og tid
                </th>
                <th
                  class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"
                >
                  Status
                </th>
                <th
                  class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"
                >
                  Handlinger
                </th>
              </tr>
            </thead>
            <tbody class="bg-white divide-y divide-gray-200">
              <tr
                v-for="booking in bookingStore.bookings"
                :key="booking.id"
                class="hover:bg-gray-50"
              >
                <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-500">
                  {{ booking.id }}
                </td>
                <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-900">
                  {{ booking.customerName }}
                </td>
                <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-900">
                  {{ booking.employeeName }}
                </td>
                <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-900">
                  {{ booking.serviceName }}
                </td>
                <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-900">
                  {{ formatDateTime(booking.startTime) }}
                </td>
                <td class="px-6 py-4 whitespace-nowrap">
                  <span
                    :class="[
                      'px-2 inline-flex text-xs leading-5 font-semibold rounded-full',
                      getStatusColor(booking.status)
                    ]"
                  >
                    {{ getStatusText(booking.status) }}
                  </span>
                </td>
                <td class="px-6 py-4 whitespace-nowrap text-sm font-medium">
                  <Button
                    variant="secondary"
                    size="sm"
                    @click="handleView(booking)"
                    data-test="view-button"
                    className="text-indigo-600 hover:text-indigo-900"
                  >
                    Vis
                  </Button>
                </td>
              </tr>
            </tbody>
          </table>
        </div>
      </div>
    </div>
    <!-- Booking Details Modal -->
    <BookingDetailsModal
      :is-open="isModalOpen"
      :booking="selectedBooking"
      @close="closeModal"
    />
  </div>
</template>
<script setup lang="ts">
import { onMounted, ref } from "vue";
import { useRouter } from "vue-router";
import { useBookingStore } from "../stores/bookings";
import BookingDetailsModal from "../components/BookingDetailsModal.vue";
import Button from "../components/base/Button.vue";
const router = useRouter();
const bookingStore = useBookingStore();
const isModalOpen = ref(false);
const selectedBooking = ref(null);
const navigateToBookings = () => {
  router.push('/bookings');
};
const navigateToOrders = () => {
  router.push('/orders');
};
const getStatusColor = (status: string | undefined): string => {
  switch (status?.toUpperCase()) {
    case "CONFIRMED":
      return "bg-green-100 text-green-800";
    case "PENDING":
      return "bg-yellow-100 text-yellow-800";
    case "CANCELLED":
      return "bg-red-100 text-red-800";
    default:
      return "bg-gray-100 text-gray-800";
  }
};
const getStatusText = (status: string | undefined): string => {
  switch (status?.toUpperCase()) {
    case "CONFIRMED":
      return "Bekreftet";
    case "PENDING":
      return "Venter";
    case "CANCELLED":
      return "Kansellert";
    default:
      return "Ukjent";
  }
};
function formatDateTime(dateString: string): string {
  try {
    const date = new Date(dateString);
    return new Intl.DateTimeFormat('nb-NO', {
      year: 'numeric',
      month: 'long',
      day: 'numeric',
      hour: '2-digit',
      minute: '2-digit'
    }).format(date);
  } catch (error) {
    console.error('Error formatting date:', error);
    return 'Dato ikke tilgjengelig';
  }
}
const handleRefresh = () => {
  bookingStore.fetchDashboardStats(true);
};
const handleView = (booking: any) => {
  selectedBooking.value = booking;
  isModalOpen.value = true;
};
const closeModal = () => {
  isModalOpen.value = false;
  selectedBooking.value = null;
};
onMounted(() => {
  bookingStore.fetchDashboardStats();
});
</script>
````

## File: frontend/admin/src/views/EmployeesView.vue
````vue
<template>
  <div class="p-6 max-w-7xl mx-auto">
    <div class="flex justify-between items-center mb-6">
      <h1 class="text-2xl font-bold">Ansatte</h1>
      <Button
        @click="showAddModal = true"
        variant="primary"
      >
        Legg til ansatt
      </Button>
    </div>
    <!-- Toast Notification -->
    <div 
      v-if="showToast" 
      class="fixed top-4 right-4 bg-green-100 border border-green-400 text-green-700 px-4 py-3 rounded z-50 flex items-center shadow-lg"
    >
      <div class="mr-2">✓</div>
      <p>{{ toastMessage }}</p>
    </div>
    <!-- Loading and Error States -->
    <div v-if="employeesStore.loading" class="text-center py-4">
      Laster ansatte...
    </div>
    <div v-else-if="employeesStore.error" class="text-red-500 py-4">
      {{ employeesStore.error }}
    </div>
    <!-- Employees Table -->
    <div v-else class="bg-white rounded-lg shadow overflow-hidden">
      <table class="min-w-full divide-y divide-gray-200">
        <thead class="bg-gray-50">
          <tr>
            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Navn</th>
            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">E-post</th>
            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Spesialiseringer</th>
            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Status</th>
            <th class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">Handlinger</th>
          </tr>
        </thead>
        <tbody class="bg-white divide-y divide-gray-200">
          <tr v-for="employee in employeesStore.employees" :key="employee.id">
            <td class="px-6 py-4 whitespace-nowrap">
              {{ employee.user.firstName }} {{ employee.user.lastName }}
            </td>
            <td class="px-6 py-4 whitespace-nowrap">
              {{ employee.user.email }}
            </td>
            <td class="px-6 py-4">
              <span 
                v-for="spec in employee.specializations" 
                :key="spec"
                class="inline-block bg-gray-100 rounded-full px-3 py-1 text-sm font-semibold text-gray-700 mr-2 mb-2"
              >
                {{ spec }}
              </span>
            </td>
            <td class="px-6 py-4 whitespace-nowrap">
              <span
                :class="[
                  'px-2 inline-flex text-xs leading-5 font-semibold rounded-full',
                  employee.isActive ? 'bg-green-100 text-green-800' : 'bg-red-100 text-red-800'
                ]"
              >
                {{ employee.isActive ? 'Aktiv' : 'Inaktiv' }}
              </span>
            </td>
            <td class="px-6 py-4 whitespace-nowrap text-sm font-medium space-x-2">
              <Button
                @click="editEmployee(employee)"
                variant="secondary"
                size="sm"
              >
                Rediger
              </Button>
              <Button
                @click="resetEmployeePassword(employee)"
                variant="secondary"
                size="sm"
              >
                Tilbakestill passord
              </Button>
              <Button
                @click="confirmDelete(employee)"
                variant="danger"
                size="sm"
              >
                Slett
              </Button>
            </td>
          </tr>
        </tbody>
      </table>
    </div>
    <!-- Add/Edit Employee Modal -->
    <div v-if="showAddModal || showEditModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center">
      <div class="bg-white p-6 rounded-lg w-full max-w-md">
        <h2 class="text-xl font-bold mb-4">
          {{ showEditModal ? 'Rediger ansatt' : 'Legg til ny ansatt' }}
        </h2>
        <form @submit.prevent="handleSubmit">
          <div class="space-y-4">
            <div>
              <label class="block text-sm font-medium text-gray-700">Fornavn</label>
              <input
                v-model="employeeForm.firstName"
                type="text"
                required
                :disabled="isSubmitting"
                class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500"
              />
            </div>
            <div>
              <label class="block text-sm font-medium text-gray-700">Etternavn</label>
              <input
                v-model="employeeForm.lastName"
                type="text"
                required
                :disabled="isSubmitting"
                class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500"
              />
            </div>
            <div>
              <label class="block text-sm font-medium text-gray-700">E-post</label>
              <input
                v-model="employeeForm.email"
                type="email"
                required
                :disabled="isSubmitting"
                class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500"
              />
            </div>
            <div>
              <label class="block text-sm font-medium text-gray-700">Spesialiseringer</label>
              <input
                v-model="specializationsInput"
                type="text"
                :disabled="isSubmitting"
                placeholder="Skriv inn spesialiseringer adskilt med komma"
                class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500"
              />
            </div>
            <div>
              <label class="block text-sm font-medium text-gray-700">Status</label>
              <select
                v-model="employeeForm.isActive"
                :disabled="isSubmitting"
                class="mt-1 block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500"
              >
                <option :value="true">Aktiv</option>
                <option :value="false">Inaktiv</option>
              </select>
            </div>
          </div>
          <div class="mt-6 flex justify-end space-x-3">
            <Button
              type="button"
              @click="closeModal"
              :disabled="isSubmitting"
              variant="secondary"
            >
              Avbryt
            </Button>
            <Button
              type="submit"
              :disabled="isSubmitting"
              :loading="isSubmitting"
              variant="primary"
            >
              {{ showEditModal ? 'Oppdater' : 'Legg til' }}
            </Button>
          </div>
        </form>
      </div>
    </div>
    <!-- Delete Confirmation Modal -->
    <div v-if="showDeleteModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center">
      <div class="bg-white p-6 rounded-lg w-full max-w-md">
        <h2 class="text-xl font-bold mb-4">Bekreft sletting</h2>
        <p>Er du sikker på at du vil slette denne ansatte?</p>
        <div class="mt-6 flex justify-end space-x-3">
          <Button
            @click="showDeleteModal = false"
            variant="secondary"
          >
            Avbryt
          </Button>
          <Button
            @click="deleteSelectedEmployee"
            variant="danger"
          >
            Slett
          </Button>
        </div>
      </div>
    </div>
    <!-- Password Modal -->
    <div v-if="showPasswordModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center z-50">
      <div class="bg-white p-6 rounded-lg w-full max-w-md">
        <div class="flex items-center mb-4">
          <div class="bg-green-100 rounded-full p-2 mr-3">
            <svg class="h-6 w-6 text-green-600" fill="none" stroke="currentColor" viewBox="0 0 24 24">
              <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 13l4 4L19 7"></path>
            </svg>
          </div>
          <h2 class="text-xl font-bold">{{ isPasswordReset ? 'Nytt passord generert' : 'Ansatt opprettet' }}</h2>
        </div>
        <div class="bg-yellow-50 border border-yellow-200 rounded p-4 mb-4">
          <p class="text-yellow-800 mb-2">
            {{ isPasswordReset 
              ? 'Dette er det nye midlertidige passordet for den ansatte.'
              : 'Dette er det midlertidige passordet for den nye ansatte.' 
            }}
            Vennligst del dette med den ansatte på en sikker måte.
            Passordet vil kun vises denne ene gangen.
          </p>
          <div class="relative">
            <div class="bg-white p-3 rounded border border-yellow-300 font-mono text-lg text-center select-all">
              {{ temporaryPassword }}
            </div>
            <Button
              @click="copyPassword"
              variant="secondary"
              size="sm"
              className="absolute right-2 top-1/2 transform -translate-y-1/2"
              title="Kopier passord"
            >
              <svg xmlns="http://www.w3.org/2000/svg" class="h-5 w-5" viewBox="0 0 20 20" fill="currentColor">
                <path d="M8 3a1 1 0 011-1h2a1 1 0 110 2H9a1 1 0 01-1-1z" />
                <path d="M6 3a2 2 0 00-2 2v11a2 2 0 002 2h8a2 2 0 002-2V5a2 2 0 00-2-2 3 3 0 01-3 3H9a3 3 0 01-3-3z" />
              </svg>
            </Button>
          </div>
          <p v-if="showCopiedMessage" class="text-green-600 text-sm mt-2 text-center">
            Passord kopiert!
          </p>
        </div>
        <div class="mt-6 flex justify-end">
          <Button
            @click="closePasswordModal"
            variant="primary"
          >
            OK
          </Button>
        </div>
      </div>
    </div>
  </div>
</template>
<script setup lang="ts">
import { ref, onMounted } from 'vue'
import { useEmployeesStore } from '../stores/employees'
import type { Employee } from '../types'
import Button from '../components/base/Button.vue'
const employeesStore = useEmployeesStore()
const showAddModal = ref(false)
const showEditModal = ref(false)
const showDeleteModal = ref(false)
const showPasswordModal = ref(false)
const showToast = ref(false)
const toastMessage = ref('')
const selectedEmployee = ref<Employee | null>(null)
const specializationsInput = ref('')
const temporaryPassword = ref('')
const isSubmitting = ref(false)
const isPasswordReset = ref(false)
const showCopiedMessage = ref(false)
const employeeForm = ref({
  firstName: '',
  lastName: '',
  email: '',
  isActive: true,
  specializations: [] as string[]
})
onMounted(async () => {
  await employeesStore.fetchEmployees()
})
const showToastMessage = (message: string) => {
  toastMessage.value = message
  showToast.value = true
  setTimeout(() => {
    showToast.value = false
  }, 3000)
}
const editEmployee = (employee: Employee) => {
  selectedEmployee.value = employee
  employeeForm.value = {
    firstName: employee.user.firstName,
    lastName: employee.user.lastName,
    email: employee.user.email,
    isActive: employee.isActive,
    specializations: [...employee.specializations]
  }
  specializationsInput.value = employee.specializations.join(', ')
  showEditModal.value = true
}
const resetEmployeePassword = async (employee: Employee) => {
  try {
    const result = await employeesStore.resetPassword(employee.id)
    temporaryPassword.value = result.temporaryPassword
    isPasswordReset.value = true
    showPasswordModal.value = true
  } catch (error) {
    if (error instanceof Error) {
      showToastMessage(error.message)
    } else {
      showToastMessage('Kunne ikke tilbakestille passord')
    }
  }
}
const copyPassword = async () => {
  try {
    await navigator.clipboard.writeText(temporaryPassword.value)
    showCopiedMessage.value = true
    setTimeout(() => {
      showCopiedMessage.value = false
    }, 2000)
  } catch (err) {
    showToastMessage('Kunne ikke kopiere passord')
  }
}
const confirmDelete = (employee: Employee) => {
  selectedEmployee.value = employee
  showDeleteModal.value = true
}
const deleteSelectedEmployee = async () => {
  if (selectedEmployee.value) {
    await employeesStore.deleteEmployee(selectedEmployee.value.id)
    showDeleteModal.value = false
    selectedEmployee.value = null
    showToastMessage('Ansatt slettet')
  }
}
const closeModal = () => {
  if (!isSubmitting.value) {
    showAddModal.value = false
    showEditModal.value = false
    selectedEmployee.value = null
    employeeForm.value = {
      firstName: '',
      lastName: '',
      email: '',
      isActive: true,
      specializations: []
    }
    specializationsInput.value = ''
  }
}
const closePasswordModal = () => {
  showPasswordModal.value = false
  temporaryPassword.value = ''
  isPasswordReset.value = false
  showToastMessage(isPasswordReset.value ? 'Passord tilbakestilt' : 'Ansatt opprettet')
}
const handleSubmit = async () => {
  if (isSubmitting.value) return;
  isSubmitting.value = true
  try {
    const employeeData = {
      ...employeeForm.value,
      specializations: specializationsInput.value.split(',').map(s => s.trim()).filter(Boolean)
    }
    if (showEditModal.value && selectedEmployee.value) {
      await employeesStore.updateEmployee(selectedEmployee.value.id, employeeData)
      showEditModal.value = false
      showToastMessage('Ansatt oppdatert')
    } else {
      const result = await employeesStore.createEmployee(employeeData)
      if (result.temporaryPassword) {
        temporaryPassword.value = result.temporaryPassword
        isPasswordReset.value = false
        showPasswordModal.value = true
      }
    }
  } catch (error) {
    console.error('Kunne ikke lagre ansatt:', error)
    if (error instanceof Error) {
      showToastMessage(error.message)
    } else {
      showToastMessage('Kunne ikke lagre ansatt')
    }
  } finally {
    isSubmitting.value = false
    if (!showEditModal.value) {
      showAddModal.value = false
    }
  }
}
</script>
````

## File: frontend/admin/src/views/LoginView.vue
````vue
<template>
  <div
    class="min-h-screen flex items-center justify-center bg-gradient-to-br from-blue-50 to-indigo-50 py-12 px-4 sm:px-6 lg:px-8"
  >
    <div class="max-w-md w-full space-y-8 bg-white p-10 rounded-xl shadow-lg">
      <div>
        <h1 class="mt-6 text-center text-3xl font-extrabold text-gray-900">
          Admin Kontrollpanel
        </h1>
        <p class="mt-2 text-center text-sm text-gray-600" id="login-description">
          Logg inn for å administrere salongen din
        </p>
      </div>
      <form 
        class="mt-8 space-y-6" 
        @submit.prevent="handleLogin"
        aria-labelledby="login-description"
        novalidate
      >
        <div class="rounded-md -space-y-px">
          <div class="mb-5">
            <label
              for="email"
              class="block text-sm font-medium text-gray-700 mb-1"
              >E-postadresse</label
            >
            <input
              id="email"
              v-model="email"
              name="email"
              type="email"
              required
              aria-required="true"
              aria-invalid="false"
              aria-describedby="email-error"
              class="appearance-none relative block w-full px-3 py-2 border border-gray-300 placeholder-gray-500 text-gray-900 rounded-md focus:outline-none focus:ring-indigo-500 focus:border-indigo-500 focus:z-10 sm:text-sm"
              placeholder="admin@example.com"
            />
            <div id="email-error" class="mt-1 text-sm text-red-600" role="alert" v-if="emailError">
              {{ emailError }}
            </div>
          </div>
          <div>
            <label
              for="password"
              class="block text-sm font-medium text-gray-700 mb-1"
              >Passord</label
            >
            <input
              id="password"
              v-model="password"
              name="password"
              type="password"
              required
              aria-required="true"
              aria-invalid="false"
              aria-describedby="password-error"
              class="appearance-none relative block w-full px-3 py-2 border border-gray-300 placeholder-gray-500 text-gray-900 rounded-md focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 focus:z-10 sm:text-sm"
              placeholder="••••••••"
            />
            <div id="password-error" class="mt-1 text-sm text-red-600" role="alert" v-if="passwordError">
              {{ passwordError }}
            </div>
          </div>
        </div>
        <div 
          v-if="error" 
          class="rounded-md bg-red-50 p-4"
          role="alert"
          aria-live="polite"
        >
          <div class="flex">
            <div class="ml-3">
              <h3 class="text-sm font-medium text-red-800">
                {{ error }}
              </h3>
            </div>
          </div>
        </div>
        <div>
          <button
            type="submit"
            :disabled="isLoading"
            class="group relative w-full flex justify-center py-2 px-4 border border-transparent text-sm font-medium rounded-md text-white bg-indigo-600 hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 disabled:opacity-50 disabled:cursor-not-allowed transition-colors duration-200"
            :aria-busy="isLoading"
          >
            <span 
              class="absolute left-0 inset-y-0 flex items-center pl-3"
              aria-hidden="true"
            >
              <svg
                class="h-5 w-5 text-indigo-500 group-hover:text-indigo-400"
                xmlns="http://www.w3.org/2000/svg"
                viewBox="0 0 20 20"
                fill="currentColor"
              >
                <path
                  fill-rule="evenodd"
                  d="M5 9V7a5 5 0 0110 0v2a2 2 0 012 2v5a2 2 0 01-2 2H5a2 2 0 01-2-2v-5a2 2 0 012-2zm8-2v2H7V7a3 3 0 016 0z"
                  clip-rule="evenodd"
                />
              </svg>
            </span>
            {{ isLoading ? "Logger inn..." : "Logg inn" }}
          </button>
        </div>
      </form>
    </div>
  </div>
</template>
<script setup lang="ts">
import { ref } from "vue";
import { useRouter } from "vue-router";
import { useAuthStore } from "../stores/auth";
import { storeToRefs } from "pinia";
const router = useRouter();
const authStore = useAuthStore();
const { error, isLoading } = storeToRefs(authStore);
const email = ref("");
const password = ref("");
const emailError = ref("");
const passwordError = ref("");
const validateForm = () => {
  let isValid = true;
  emailError.value = "";
  passwordError.value = "";
  if (!email.value) {
    emailError.value = "E-postadresse er påkrevd";
    isValid = false;
  } else if (!/^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email.value)) {
    emailError.value = "Vennligst skriv inn en gyldig e-postadresse";
    isValid = false;
  }
  if (!password.value) {
    passwordError.value = "Passord er påkrevd";
    isValid = false;
  }
  return isValid;
};
const handleLogin = async () => {
  if (!validateForm()) return;
  const success = await authStore.login({
    email: email.value,
    password: password.value,
  });
  if (success) {
    router.push("/dashboard");
  }
};
</script>
````

## File: frontend/admin/src/views/OrdersView.vue
````vue
<template>
  <div class="p-4">
    <div class="max-w-7xl mx-auto">
      <div class="flex justify-between items-center mb-4">
        <h1 class="text-2xl font-bold">Fullførte bestillinger</h1>
        <Button
          @click="refreshData"
          variant="primary"
          :loading="loading"
        >
          Oppdater
        </Button>
      </div>
      <!-- Error Display -->
      <div v-if="error" class="mb-4 bg-red-50 border border-red-400 text-red-700 px-4 py-3 rounded relative" role="alert">
        <span class="block sm:inline">{{ error }}</span>
      </div>
      <!-- Filters -->
      <div class="mb-6 bg-white p-4 rounded-lg shadow space-y-4">
        <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
          <div>
            <label class="block text-sm font-medium text-gray-700 mb-2"
              >Velg dato</label
            >
            <div class="flex gap-2">
              <input
                type="date"
                v-model="selectedDate"
                class="block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm"
              />
              <Button
                @click="clearDate"
                variant="secondary"
                class="whitespace-nowrap"
              >
                Fjern dato
              </Button>
            </div>
          </div>
          <div>
            <label class="block text-sm font-medium text-gray-700 mb-2"
              >Velg ansatt</label
            >
            <select
              v-model="selectedEmployeeId"
              class="block w-full rounded-md border-gray-300 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 sm:text-sm"
            >
              <option value="">Alle ansatte</option>
              <option v-for="employee in activeEmployees" :key="employee.id" :value="employee.id">
                {{ employee.user.firstName }} {{ employee.user.lastName }}
              </option>
            </select>
          </div>
        </div>
        <div class="flex justify-end">
          <Button
            @click="showAllOrders"
            variant="secondary"
            class="ml-2"
          >
            Vis alle ordre
          </Button>
        </div>
      </div>
      <!-- Chart -->
      <div class="mb-8 bg-white p-4 rounded-lg shadow">
        <OrdersChart :orders="filteredOrders" />
      </div>
      <!-- Loading and Error States -->
      <div v-if="loading" class="text-center py-4">
        Laster data...
      </div>
      <div v-else-if="error" class="text-red-500 py-4">
        {{ error }}
      </div>
      <div v-else-if="filteredOrders.length === 0" class="text-center py-4">
        Ingen fullførte bestillinger funnet for valgte filtre.
      </div>
      <!-- Orders Table -->
      <div v-else class="bg-white shadow rounded-lg overflow-hidden">
        <table class="min-w-full divide-y divide-gray-200">
          <thead class="bg-gray-50">
            <tr>
              <th
                scope="col"
                class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"
              >
                Kunde
              </th>
              <th
                scope="col"
                class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"
              >
                Ansatt
              </th>
              <th
                scope="col"
                class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"
              >
                Tjeneste
              </th>
              <th
                scope="col"
                class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"
              >
                Varighet
              </th>
              <th
                scope="col"
                class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"
              >
                Pris
              </th>
              <th
                scope="col"
                class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"
              >
                Fullført
              </th>
              <th
                scope="col"
                class="px-6 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider"
              >
                Notater
              </th>
            </tr>
          </thead>
          <tbody class="bg-white divide-y divide-gray-200">
            <tr v-for="order in filteredOrders" :key="order.id">
              <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-900">
                {{ order.booking.customer.firstName }}
                {{ order.booking.customer.lastName }}
              </td>
              <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-900">
                {{ order.booking.employee.user.firstName }}
                {{ order.booking.employee.user.lastName }}
              </td>
              <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-900">
                {{ order.booking.service.name }}
              </td>
              <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-900">
                {{ order.booking.service.duration }} minutter
              </td>
              <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-900">
                {{ formatPrice(order.totalAmount) }}
              </td>
              <td class="px-6 py-4 whitespace-nowrap text-sm text-gray-900">
                {{ formatTime(order.completedAt) }}
              </td>
              <td class="px-6 py-4 text-sm text-gray-900">
                {{ order.notes || "-" }}
              </td>
            </tr>
            <!-- Total Row -->
            <tr class="bg-gray-50">
              <td
                colspan="4"
                class="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900"
              >
                Total
              </td>
              <td
                class="px-6 py-4 whitespace-nowrap text-sm font-medium text-gray-900"
              >
                {{ formatPrice(totalAmount) }}
              </td>
              <td colspan="2"></td>
            </tr>
          </tbody>
        </table>
      </div>
    </div>
  </div>
</template>
<script setup lang="ts">
import { ref, computed, onMounted, onUnmounted, watch } from "vue";
import { useOrdersStore } from "../stores/orders";
import { useEmployeesStore } from "../stores/employees";
import { storeToRefs } from "pinia";
import OrdersChart from "../components/OrdersChart.vue";
import Button from "../components/base/Button.vue";
const ordersStore = useOrdersStore();
const employeesStore = useEmployeesStore();
const { orders, loading, error } = storeToRefs(ordersStore);
const { employees } = storeToRefs(employeesStore);
// Set up periodic refresh
let refreshInterval: number | null = null;
// Date handling - initialize with today's date in local timezone
const today = new Date();
const selectedDate = ref(today.toISOString().split("T")[0]);
const selectedEmployeeId = ref("");
const activeEmployees = computed(() => {
  return employees.value.filter(emp => emp.isActive);
});
const filteredOrders = computed(() => {
  let filtered = orders.value;
  // Filter by date
  if (selectedDate.value) {
    const selectedDateObj = new Date(selectedDate.value);
    const startOfDay = new Date(
      selectedDateObj.getFullYear(),
      selectedDateObj.getMonth(),
      selectedDateObj.getDate()
    );
    const endOfDay = new Date(
      selectedDateObj.getFullYear(),
      selectedDateObj.getMonth(),
      selectedDateObj.getDate(),
      23,
      59,
      59,
      999
    );
    filtered = filtered.filter((order) => {
      const orderDate = new Date(order.completedAt);
      return orderDate >= startOfDay && orderDate <= endOfDay;
    });
  }
  // Filter by employee
  if (selectedEmployeeId.value) {
    filtered = filtered.filter((order) => 
      order.booking.employee.id === selectedEmployeeId.value
    );
  }
  return filtered;
});
const totalAmount = computed(() => {
  return filteredOrders.value.reduce((sum, order) => {
    return sum + parseFloat(order.totalAmount);
  }, 0);
});
function formatTime(dateString: string): string {
  if (!dateString) return "";
  try {
    const date = new Date(dateString);
    return new Intl.DateTimeFormat("nb-NO", {
      hour: "2-digit",
      minute: "2-digit",
    }).format(date);
  } catch (error) {
    console.error("Error formatting time:", error);
    return "Tid ikke tilgjengelig";
  }
}
function formatPrice(price: string | number): string {
  try {
    const amount = typeof price === "string" ? parseFloat(price) : price;
    return new Intl.NumberFormat("nb-NO", {
      style: "currency",
      currency: "NOK",
      minimumFractionDigits: 2,
      maximumFractionDigits: 2,
    }).format(amount);
  } catch (error) {
    console.error("Error formatting price:", error);
    return "NOK -";
  }
}
function refreshData() {
  ordersStore.fetchOrders(true);
  employeesStore.fetchEmployees();
}
function showAllOrders() {
  selectedDate.value = "";
  selectedEmployeeId.value = "";
}
function clearDate() {
  selectedDate.value = "";
}
// Watch for filter changes to log filtering info
watch([selectedDate, selectedEmployeeId, orders], () => {
  console.log("Filtering debug:");
  console.log("Selected date:", selectedDate.value);
  console.log("Selected employee:", selectedEmployeeId.value);
  console.log("Total orders:", orders.value.length);
  console.log("Filtered orders:", filteredOrders.value.length);
});
onMounted(async () => {
  await Promise.all([
    ordersStore.fetchOrders(),
    employeesStore.fetchEmployees()
  ]);
  // Set up periodic refresh every 5 minutes
  refreshInterval = window.setInterval(() => {
    ordersStore.fetchOrders();
    employeesStore.fetchEmployees();
  }, 300000); // 5 minutes in milliseconds
});
onUnmounted(() => {
  if (refreshInterval !== null) {
    clearInterval(refreshInterval);
  }
});
</script>
````

## File: frontend/admin/src/App.vue
````vue
<template>
  <div class="min-h-screen bg-gray-100">
    <nav v-if="isAuthenticated" class="bg-white shadow">
      <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
        <div class="flex justify-between h-16">
          <div class="flex">
            <div class="flex-shrink-0 flex items-center">
              <h1 class="text-xl font-bold text-gray-900">Admin Kontrollpanel</h1>
            </div>
            <div class="hidden sm:ml-6 sm:flex sm:space-x-8">
              <router-link
                to="/dashboard"
                class="border-transparent text-gray-500 hover:border-gray-300 hover:text-gray-700 inline-flex items-center px-1 pt-1 border-b-2 text-sm font-medium"
                :class="{
                  'border-indigo-500 text-gray-900':
                    $route.path === '/dashboard',
                }"
              >
                Kontrollpanel
              </router-link>
              <router-link
                to="/bookings"
                class="border-transparent text-gray-500 hover:border-gray-300 hover:text-gray-700 inline-flex items-center px-1 pt-1 border-b-2 text-sm font-medium"
                :class="{
                  'border-indigo-500 text-gray-900':
                    $route.path.startsWith('/bookings'),
                }"
              >
                Bestillinger
              </router-link>
              <router-link
                to="/orders"
                class="border-transparent text-gray-500 hover:border-gray-300 hover:text-gray-700 inline-flex items-center px-1 pt-1 border-b-2 text-sm font-medium"
                :class="{
                  'border-indigo-500 text-gray-900':
                    $route.path.startsWith('/orders'),
                }"
              >
                Ordre
              </router-link>
              <router-link
                v-if="isAdmin"
                to="/employees"
                class="border-transparent text-gray-500 hover:border-gray-300 hover:text-gray-700 inline-flex items-center px-1 pt-1 border-b-2 text-sm font-medium"
                :class="{
                  'border-indigo-500 text-gray-900':
                    $route.path.startsWith('/employees'),
                }"
              >
                Ansatte
              </router-link>
            </div>
          </div>
          <div class="flex items-center">
            <Button
              @click="handleLogout"
              variant="primary"
              className="ml-3"
            >
              Logg ut
            </Button>
          </div>
        </div>
      </div>
    </nav>
    <main>
      <router-view v-slot="{ Component }">
        <transition name="fade" mode="out-in">
          <component :is="Component" />
        </transition>
      </router-view>
    </main>
  </div>
</template>
<script setup lang="ts">
import { useRouter } from "vue-router";
import { useAuthStore } from "./stores/auth";
import { storeToRefs } from "pinia";
import Button from "./components/base/Button.vue";
const router = useRouter();
const authStore = useAuthStore();
const { isAuthenticated, isAdmin } = storeToRefs(authStore);
const handleLogout = () => {
  authStore.logout();
  router.push("/login");
};
</script>
<style>
.fade-enter-active,
.fade-leave-active {
  transition: opacity 0.2s ease;
}
.fade-enter-from,
.fade-leave-to {
  opacity: 0;
}
</style>
````

## File: frontend/admin/src/env.d.ts
````typescript
/// <reference types="vite/client" />
declare module "*.vue" {
  import type { DefineComponent } from "vue";
  const component: DefineComponent<{}, {}, any>;
  export default component;
}
interface ImportMetaEnv {
  readonly VITE_API_URL: string;
}
interface ImportMeta {
  readonly env: ImportMetaEnv;
}
````

## File: frontend/admin/src/main.ts
````typescript
import { createApp } from "vue";
import { createPinia } from "pinia";
import axios from "axios";
import router from "./router";
import { useAuthStore } from "./stores/auth";
import App from "./App.vue";
import "./style.css";
const app = createApp(App);
const pinia = createPinia();
// Configure plugins
app.use(pinia);
app.use(router);
// Add axios response interceptor for session expiration
axios.interceptors.response.use(
  (response) => response,
  (error) => {
    if (error.response?.data?.message === "Økt utløpt. Vennligst logg inn igjen." ||
        error.response?.status === 401) {
      const authStore = useAuthStore();
      authStore.logout();
      router.push("/login");
    }
    return Promise.reject(error);
  }
);
// Mount app
app.mount("#app");
````

## File: frontend/admin/src/style.css
````css
@tailwind base;
@tailwind components;
@tailwind utilities;
:root {
  font-family: Inter, system-ui, Avenir, Helvetica, Arial, sans-serif;
  line-height: 1.5;
  font-weight: 400;
  font-synthesis: none;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}
body {
  margin: 0;
  min-width: 320px;
  min-height: 100vh;
}
#app {
  width: 100%;
  height: 100vh;
}
/* Transition animations */
.fade-enter-active,
.fade-leave-active {
  transition: opacity 0.2s ease;
}
.fade-enter-from,
.fade-leave-to {
  opacity: 0;
}
````

## File: frontend/admin/src/vite-env.d.ts
````typescript
/// <reference types="vite/client" />
````

## File: frontend/admin/.gitignore
````
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
dist
dist-ssr
*.local

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
.DS_Store
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?
````

## File: frontend/admin/index.html
````html
<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <link rel="icon" type="image/svg+xml" href="/vite.svg" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Frisørsalong - Administrator</title>
  </head>
  <body>
    <div id="app"></div>
    <script type="module" src="/src/main.ts"></script>
  </body>
</html>
````

## File: frontend/admin/postcss.config.js
````javascript
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}
````

## File: frontend/admin/README.md
````markdown
# Hair Salon Booking System Frontend (Admin Dashboard)

A modern admin dashboard for managing hair salon bookings, built with Vue 3. This system provides comprehensive functionality for managing appointments, employees, services, and user authentication.

## Features

- 🔐 JWT-based Authentication & Authorization
- 👥 User Management
- 📅 Booking System
- 💇‍♀️ Service Management
- 👨‍💼 Employee Management
- 📚 API Documentation

## Tech Stack

- Vue 3
- TypeScript
- Pinia
- Vue Router
- Tailwind CSS
- Axios

## Prerequisites

- Node.js (v18 or higher)
- pnpm

## Installation

1. Install dependencies:
```bash
pnpm install
```

2. Configure environment variables:
   - Copy `.env.example` to `.env`
   - Update the values according to your setup

## Running the Application

```bash
# Development
pnpm dev

# Production
pnpm build
pnpm preview
```

## Testing

```bash
# Unit tests
pnpm test

# Component tests
pnpm test:unit
```

## Available Scripts

- `pnpm dev` - Start the development server
- `pnpm build` - Build the application
- `pnpm preview` - Preview the production build
- `pnpm test` - Run unit tests
- `pnpm test:unit` - Run component tests
- `pnpm lint` - Lint code with ESLint
- `pnpm format` - Format code with Prettier

## Project Structure

```
src/
├── assets/             # Static assets
├── components/         # Vue components
├── router/             # Vue Router configuration
├── stores/             # Pinia stores
├── views/              # Vue views
├── App.vue             # Root component
├── main.ts             # Application entry point
└── style.css           # Global styles
```

## Environment Variables

Required environment variables in `.env`:

```
# API
VITE_API_URL=http://localhost:3000
```

## API Documentation

The API documentation is available through Swagger UI when running the backend:

```
http://localhost:3000/api
```

## License

MIT
````

## File: frontend/admin/renovate.json
````json
{
  "extends": [
    "config:recommended"
  ],
  "ignorePresets": [
    ":prHourlyLimit2",
    ":prConcurrentLimit20"
  ],
  "packageRules": [
    {
      "rangeStrategy": "bump",
      "matchDepTypes": [
        "dependencies",
        "devDependencies",
        "optionalDependencies",
        "peerDependencies"
      ]
    },
    {
      "matchUpdateTypes": [
        "minor",
        "pin",
        "digest"
      ],
      "automerge": true,
      "matchDepTypes": [
        "dependencies",
        "devDependencies",
        "optionalDependencies",
        "peerDependencies"
      ]
    },
    {
      "matchUpdateTypes": [
        "patch",
        "lockFileMaintenance"
      ],
      "automerge": true,
      "automergeType": "branch",
      "matchDepTypes": [
        "dependencies",
        "devDependencies",
        "optionalDependencies",
        "peerDependencies"
      ]
    }
  ]
}
````

## File: frontend/admin/tailwind.config.js
````javascript
/** @type {import('tailwindcss').Config} */
export default {
  content: [
    "./index.html",
    "./src/**/*.{vue,js,ts,jsx,tsx}",
  ],
  theme: {
    extend: {
      colors: {
        primary: {
          50: '#f0f9ff',
          100: '#e0f2fe',
          200: '#bae6fd',
          300: '#7dd3fc',
          400: '#38bdf8',
          500: '#0ea5e9',
          600: '#0284c7',
          700: '#0369a1',
          800: '#075985',
          900: '#0c4a6e',
        },
      },
    },
  },
  plugins: [],
}
````

## File: frontend/admin/tsconfig.app.json
````json
{
  "compilerOptions": {
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",
    "target": "ES2020",
    "useDefineForClassFields": true,
    "module": "ESNext",
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "Bundler",
    "allowImportingTsExtensions": true,
    "isolatedModules": true,
    "moduleDetection": "force",
    "noEmit": true,
    "jsx": "preserve",

    /* Linting */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,
    "noUncheckedSideEffectImports": true
  },
  "include": ["src/**/*.ts", "src/**/*.tsx", "src/**/*.vue"]
}
````

## File: frontend/admin/tsconfig.json
````json
{
  "compilerOptions": {
    "target": "ES2020",
    "useDefineForClassFields": true,
    "module": "ESNext",
    "lib": ["ES2020", "DOM", "DOM.Iterable"],
    "skipLibCheck": true,

    /* Bundler mode */
    "moduleResolution": "bundler",
    "allowImportingTsExtensions": true,
    "resolveJsonModule": true,
    "isolatedModules": true,
    "noEmit": true,
    "jsx": "preserve",

    /* Vue specific */
    "allowJs": true,
    "esModuleInterop": true,

    /* Type Checking */
    "strict": true,
    "noUnusedLocals": true,
    "noUnusedParameters": true,
    "noFallthroughCasesInSwitch": true,

    /* Path aliases */
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    },
    "types": ["vite/client", "vue"]
  },
  "include": [
    "src/**/*.ts", 
    "src/**/*.d.ts", 
    "src/**/*.tsx", 
    "src/**/*.vue",
    "vite.config.ts"
  ],
  "references": [{ "path": "./tsconfig.node.json" }]
}
````

## File: frontend/admin/tsconfig.node.json
````json
{
  "compilerOptions": {
    "composite": true,
    "skipLibCheck": true,
    "module": "ESNext",
    "moduleResolution": "bundler",
    "allowSyntheticDefaultImports": true,
    "strict": true
  },
  "include": ["vite.config.ts"]
}
````

## File: frontend/admin/vite.config.ts
````typescript
import { defineConfig } from 'vite';
import vue from '@vitejs/plugin-vue';
import { fileURLToPath, URL } from 'node:url';
export default defineConfig({
  plugins: [vue()],
  test: {
    environment: 'jsdom',
    globals: true
  },
  resolve: {
    alias: {
      '@': fileURLToPath(new URL('./src', import.meta.url))
    }
  },
  server: {
    port: 3001,
    proxy: {
      '/api': {
        target: 'http://localhost:3000',
        changeOrigin: true
      }
    }
  }
});
````

## File: frontend/customer/.vscode/extensions.json
````json
{
  "recommendations": [
    "Vue.volar",
    "vitest.explorer",
    "dbaeumer.vscode-eslint",
    "EditorConfig.EditorConfig",
    "esbenp.prettier-vscode"
  ]
}
````

## File: frontend/customer/cypress/e2e/example.cy.ts
````typescript
// https://on.cypress.io/api
describe('My First Test', () => {
  it('visits the app root url', () => {
    cy.visit('/')
    cy.contains('h1', 'You did it!')
  })
})
````

## File: frontend/customer/cypress/fixtures/example.json
````json
{
  "name": "Using fixtures to represent data",
  "email": "hello@cypress.io",
  "body": "Fixtures are a great way to mock data for responses to routes"
}
````

## File: frontend/customer/cypress/support/commands.ts
````typescript
/// <reference types="cypress" />
// ***********************************************
// This example commands.ts shows you how to
// create various custom commands and overwrite
// existing commands.
//
// For more comprehensive examples of custom
// commands please read more here:
// https://on.cypress.io/custom-commands
// ***********************************************
//
//
// -- This is a parent command --
// Cypress.Commands.add('login', (email, password) => { ... })
//
//
// -- This is a child command --
// Cypress.Commands.add('drag', { prevSubject: 'element'}, (subject, options) => { ... })
//
//
// -- This is a dual command --
// Cypress.Commands.add('dismiss', { prevSubject: 'optional'}, (subject, options) => { ... })
//
//
// -- This will overwrite an existing command --
// Cypress.Commands.overwrite('visit', (originalFn, url, options) => { ... })
//
// declare global {
//   namespace Cypress {
//     interface Chainable {
//       login(email: string, password: string): Chainable<void>
//       drag(subject: string, options?: Partial<TypeOptions>): Chainable<Element>
//       dismiss(subject: string, options?: Partial<TypeOptions>): Chainable<Element>
//       visit(originalFn: CommandOriginalFn, url: string, options: Partial<VisitOptions>): Chainable<Element>
//     }
//   }
// }
export {}
````

## File: frontend/customer/cypress/support/e2e.ts
````typescript
// ***********************************************************
// This example support/index.js is processed and
// loaded automatically before your test files.
//
// This is a great place to put global configuration and
// behavior that modifies Cypress.
//
// You can change the location of this file or turn off
// automatically serving support files with the
// 'supportFile' configuration option.
//
// You can read more here:
// https://on.cypress.io/configuration
// ***********************************************************
// Import commands.js using ES2015 syntax:
import './commands'
// Alternatively you can use CommonJS syntax:
// require('./commands')
````

## File: frontend/customer/cypress/tsconfig.json
````json
{
  "extends": "@vue/tsconfig/tsconfig.dom.json",
  "include": ["./e2e/**/*", "./support/**/*"],
  "exclude": ["./support/component.*"],
  "compilerOptions": {
    "isolatedModules": false,
    "types": ["cypress"]
  }
}
````

## File: frontend/customer/docs/ARCHITECTURE.md
````markdown
# Hair Salon Booking System Planning Document

## Table of Contents

- [Introduction](#introduction)
- [Project Objectives](#project-objectives)
- [Functional Requirements](#functional-requirements)
- [Non-Functional Requirements](#non-functional-requirements)
- [Technology Stack](#technology-stack)
- [System Architecture](#system-architecture)
- [Database Design](#database-design)
- [API Design](#api-design)
- [Frontend Design](#frontend-design)
- [Security Considerations](#security-considerations)
- [Scalability Considerations](#scalability-considerations)
- [Deployment Plan](#deployment-plan)
- [Timeline and Milestones](#timeline-and-milestones)
- [Conclusion](#conclusion)

---

## Introduction

This document outlines the planning phase for developing a full-stack booking system for a hair salon. The system aims to streamline the booking process for customers, manage appointments efficiently, and provide administrative capabilities for salon management and staff.

---

## Project Objectives

- Develop a scalable, production-ready booking platform tailored for hair salons.
- Implement a user-friendly frontend interface for customers to book appointments.
- Create an administrative dashboard for the salon's CEO and staff to manage bookings, schedules, and generate reports.
- Ensure the system is secure, fast, and maintainable for future enhancements.
- Expose a robust API for potential integration with other solutions.

---

## Functional Requirements

### Customer-Facing Features

- **User Registration and Authentication**: Customers can create accounts and securely log in.
- **Appointment Booking**: Browse available time slots and book appointments without double-booking conflicts.
- **Service Selection**: View and select from a list of services offered.
- **Booking Management**: View, modify, or cancel existing bookings.
- **Notifications**: Receive email/SMS confirmations and reminders.

### Employee Features

- **Employee Login**: Staff members have individual accounts to access their schedules.
- **Schedule Management**: View and manage personal appointment schedules.
- **Availability Settings**: Set availability and block out times when not available.

### Admin Features

- **Admin Dashboard**: Comprehensive overview of daily bookings, staff schedules, and salon performance.
- **User Management**: Add, modify, or remove employee accounts.
- **Reporting**: Generate reports on bookings, revenue, and employee performance; export data to Excel.
- **Service Management**: Add or update services offered, including pricing and duration.

---

## Non-Functional Requirements

- **Scalability**: Able to handle increased load, e.g., for large salons like Cutters.
- **Performance**: Fast load times and responsive interactions.
- **Security**: Protect user data with robust authentication and authorization mechanisms.
- **Maintainability**: Clean, well-documented codebase for future development.
- **Reliability**: Ensure high availability and fault tolerance.
- **Usability**: Intuitive user interface and user experience.
- **Compliance**: Adhere to relevant data protection regulations (e.g., GDPR).

---

## Technology Stack

### Backend

- **Language**: Node.js (JavaScript/TypeScript)
- **Framework**: [NestJS](https://nestjs.com/) for a scalable and maintainable structure.
  - Future-proof and supports enterprise-grade applications.
  - Built with TypeScript, encouraging type safety.
- **Database**:
  - **Primary**: PostgreSQL for relational data storage.
  - **Cache**: Redis for caching frequently accessed data and managing session data.
- **Authentication**: JSON Web Tokens (JWT) with refresh tokens for secure API access.
- **API Documentation**: Swagger/OpenAPI for documenting APIs.

### Frontend

- **Framework**: Vue 3
  - Known for its gentle learning curve and flexibility.
  - Composition API allows for better organization in larger applications.
- **State Management**: Pinia (the successor to Vuex) for managing application state.
- **Routing**: Vue Router for navigating between views.

### DevOps and Deployment

- **Containerization**: Docker for consistent environments across development, testing, and production.
- **Orchestration**: Kubernetes or Docker Compose for managing containers.
- **Continuous Integration/Continuous Deployment (CI/CD)**: Jenkins, GitHub Actions, or GitLab CI for automatic building, testing, and deployment.
- **Hosting**: Cloud provider like AWS, Azure, or Google Cloud Platform.

---

## System Architecture

### Overview

The system will follow a modular architecture separating the frontend, backend, and database layers.

1. **Frontend Client**:

   - Runs in the browser.
   - Communicates with the backend via RESTful API calls.
   - Provides interfaces for customers, employees, and admins based on roles.

2. **Backend API**:

   - Exposes RESTful endpoints for all functionalities.
   - Handles business logic, authentication, and authorization.
   - Interacts with the database and cache layers.

3. **Database Layer**:
   - PostgreSQL stores persistent relational data.
   - Redis used for session management, caching, and handling real-time features (e.g., notifications).

### Interaction Flow

1. A customer accesses the booking interface via the frontend.
2. The frontend communicates with the backend API to fetch available time slots.
3. Upon booking, the backend validates the request, ensures no double-booking via Redis locks, and stores the appointment in PostgreSQL.
4. Notifications are sent, and the employee's schedule is updated accordingly.

---

## Database Design

### Entities and Relationships

1. **Users**

   - **Attributes**: `id`, `name`, `email`, `password`, `role` (customer, employee, admin), `contact_info`, `created_at`, `updated_at`
   - Stores all user information with role-based access.

2. **Employees**

   - **Attributes**: `id`, `user_id`, `specializations`, `availability`, `created_at`, `updated_at`
   - Linked to the `Users` table via `user_id`.

3. **Services**

   - **Attributes**: `id`, `name`, `description`, `duration`, `price`, `created_at`, `updated_at`
   - List of services offered by the salon.

4. **Bookings**

   - **Attributes**: `id`, `customer_id`, `employee_id`, `service_id`, `start_time`, `end_time`, `status`, `created_at`, `updated_at`
   - Represents appointments; references `Users`, `Employees`, and `Services`.

5. **Payments** (Optional for future implementation)

   - **Attributes**: `id`, `booking_id`, `amount`, `payment_method`, `status`, `transaction_date`

6. **Reports**
   - Generated on-demand; data pulled from existing tables.

### Database Constraints

- **Uniqueness**: Ensure email addresses are unique in the `Users` table.
- **Foreign Keys**: Maintain referential integrity between tables.
- **Indexes**: Optimize queries on frequently accessed fields (e.g., `start_time` in `Bookings`).

---

## API Design

### Authentication

- **Endpoints**:
  - `POST /auth/register`: Register a new user.
  - `POST /auth/login`: Authenticate user and provide JWT.
  - `POST /auth/refresh`: Refresh access tokens.
- **Middleware**: Protect routes using JWT verification.

### Customer APIs

- `GET /services`: List all available services.
- `GET /employees`: View employees and their specializations.
- `GET /availability`: Check available time slots for a service and employee.
- `POST /bookings`: Create a new booking.
- `GET /bookings/{id}`: Retrieve booking details.
- `PUT /bookings/{id}`: Modify an existing booking.
- `DELETE /bookings/{id}`: Cancel a booking.

### Employee APIs

- `GET /employees/{id}/schedule`: View own schedule.
- `PUT /employees/{id}/availability`: Update availability.

### Admin APIs

- `GET /admin/dashboard`: Get overview statistics.
- `POST /admin/employees`: Add a new employee.
- `PUT /admin/employees/{id}`: Update employee details.
- `DELETE /admin/employees/{id}`: Remove an employee.
- `POST /admin/services`: Add a new service.
- `PUT /admin/services/{id}`: Update service details.
- `DELETE /admin/services/{id}`: Remove a service.
- `GET /admin/reports`: Generate and retrieve reports.

### Error Handling

- Use standardized HTTP status codes.
- Return error messages with details to assist in debugging (avoid exposing sensitive information).

---

## Frontend Design

### User Interface Components

#### Customers

- **Home Page**: Introduction and quick access to booking.
- **Service Catalog**: Display services with details.
- **Booking Flow**:
  1. Select Service.
  2. Choose Employee (optional or auto-assigned).
  3. Pick Date and Time.
  4. Confirm Booking.
- **User Account**:
  - View upcoming and past appointments.
  - Edit personal information.

#### Employees

- **Dashboard**: Overview of today's appointments.
- **Schedule View**: Calendar with upcoming bookings.
- **Availability Settings**: Interface to block out unavailable times.

#### Admins

- **Admin Dashboard**: Key metrics and alerts.
- **Employee Management**: CRUD operations for employee accounts.
- **Service Management**: Add or modify services.
- **Reporting Tools**: Generate and export reports.

### UX/UI Considerations

- **Responsive Design**: Ensure usability on desktops, tablets, and mobile devices.
- **Accessibility**: Adhere to WCAG guidelines for inclusive design.
- **Consistency**: Use a design system or component library (e.g., Vuetify) for uniformity.

---

## Security Considerations

- **Authentication**: Implement robust authentication with password hashing (e.g., bcrypt) and secure JWT handling.
- **Authorization**: Role-based access control to restrict resources.
- **Input Validation**: Sanitize and validate all user inputs to prevent SQL injection and XSS attacks.
- **Data Protection**: Encrypt sensitive data at rest and in transit (use HTTPS with TLS).
- **Rate Limiting**: Protect against brute-force attacks by limiting login attempts.
- **Audit Logging**: Maintain logs of critical actions for auditing purposes.

---

## Scalability Considerations

- **Stateless Backend**: Design the backend to be stateless to facilitate horizontal scaling.
- **Load Balancing**: Use a load balancer to distribute traffic across multiple server instances.
- **Caching Strategy**: Implement caching for frequent read operations using Redis.
- **Database Optimization**: Use indexing and query optimization; consider read replicas for PostgreSQL.
- **Asynchronous Processing**: Use message queues (e.g., RabbitMQ) for background tasks like sending notifications.

---

## Deployment Plan

### Environments

1. **Development**
   - Local machines with hot-reloading for rapid development.
2. **Testing/Staging**
   - Mirror production environment for testing features before release.
3. **Production**
   - Live environment with robust monitoring and backup strategies.

### CI/CD Pipeline

- **Code Repository**: Use Git for version control (GitHub, GitLab).
- **Automated Testing**: Run unit and integration tests on every push.
- **Build and Deployment**: Automate using CI/CD tools to reduce manual errors.

### Monitoring and Logging

- **Application Monitoring**: Use tools like Prometheus and Grafana.
- **Error Tracking**: Implement Sentry or similar for error logging.
- **Health Checks**: Set up endpoint and infrastructure health checks.

---

## Timeline and Milestones

| Phase                     | Duration | Key Deliverables                                   |
| ------------------------- | -------- | -------------------------------------------------- |
| **Requirements Analysis** | 1 week   | Finalize specifications and user stories           |
| **Design**                | 2 weeks  | System architecture, database schema, UI mockups   |
| **Backend Development**   | 4 weeks  | API endpoints, authentication, business logic      |
| **Frontend Development**  | 4 weeks  | UI components, state management, API integration   |
| **Testing**               | 2 weeks  | Unit tests, integration tests, user acceptance     |
| **Deployment Setup**      | 1 week   | CI/CD pipeline, server setup, domain configuration |
| **Beta Release**          | 1 week   | Deploy to staging, gather feedback                 |
| **Final Adjustments**     | 1 week   | Bug fixes, performance tuning                      |
| **Launch**                | -        | Deploy to production                               |

_Total Estimated Time: Approximately 3 months_

---

## Conclusion

This planning document outlines a comprehensive approach to developing a full-stack hair salon booking system that is scalable, secure, and user-friendly. By leveraging modern technologies and adhering to best practices in software development, the final product aims to meet the immediate needs of hair salons while being adaptable for future growth and integration.

---

**Next Steps**:

- Review and approve the planning document.
- Set up initial development environments.
- Begin the requirements analysis phase with stakeholder meetings.
````

## File: frontend/customer/docs/CONVENTIONS.md
````markdown
# Code Conventions and Best Practices

## General Principles

- Follow TDD (Test-Driven Development)
- Apply DRY (Don't Repeat Yourself)
- Follow KISS (Keep It Simple, Stupid)
- Apply YAGNI (You Aren't Gonna Need It)
- Follow SOLID Principles:
  - Single Responsibility
  - Open/Closed
  - Liskov Substitution
  - Interface Segregation
  - Dependency Inversion

## TypeScript/JavaScript Conventions

### Naming Conventions

- Use `PascalCase` for:
  - Classes
  - Interfaces
  - Type aliases
  - Enums
- Use `camelCase` for:
  - Variables
  - Functions
  - Methods
  - Properties
  - Parameters
- Use `UPPER_SNAKE_CASE` for constants
- Use descriptive names that reflect the purpose

### File Naming

- Use `kebab-case` for file names
- Suffix files based on their type:
  - `.controller.ts` for controllers
  - `.service.ts` for services
  - `.entity.ts` for database entities
  - `.dto.ts` for Data Transfer Objects
  - `.spec.ts` for test files

### Code Organization

- One class per file
- Group related functionality in modules
- Keep files focused and small
- Use barrel exports (index.ts) for clean imports

## Testing Conventions

### Test Structure

- Follow the AAA pattern:
  - Arrange: Set up test data
  - Act: Execute the code being tested
  - Assert: Verify the results
- Use descriptive test names that explain the scenario
- Group related tests using describe blocks
- Mock external dependencies

### Test Coverage

- Aim for 80%+ code coverage
- Write unit tests for:
  - Services
  - Controllers
  - Guards
  - Pipes
  - Custom decorators
- Include integration tests for:
  - API endpoints
  - Database operations

## API Conventions

### RESTful Endpoints

- Use plural nouns for resources
- Follow HTTP method semantics:
  - GET: Read
  - POST: Create
  - PUT: Full update
  - PATCH: Partial update
  - DELETE: Remove
- Use proper HTTP status codes

### Request/Response

- Use DTOs for request validation
- Follow consistent response format:
  ```typescript
  {
    success: boolean;
    data?: any;
    error?: {
      code: string;
      message: string;
    }
  }
  ```

## Database Conventions

### Entity Design

- Use singular names for entity classes
- Include created_at and updated_at timestamps
- Use proper column types and constraints
- Define explicit relationships

### Migrations

- One migration per change
- Descriptive migration names
- Include both up and down migrations
- Test migrations before deployment

## Documentation

- Use JSDoc for code documentation
- Keep README files up to date
- Document API endpoints using Swagger
- Include setup instructions

## Version Control

- Write clear commit messages
- Use feature branches
- Follow conventional commits format:
  - feat: New feature
  - fix: Bug fix
  - docs: Documentation
  - style: Formatting
  - refactor: Code restructuring
  - test: Adding tests
  - chore: Maintenance

## Error Handling

- Use custom exception filters
- Implement proper logging
- Return appropriate error responses
- Handle async/await properly with try/catch

## Security

- Validate all inputs
- Sanitize data before storage
- Use proper authentication/authorization
- Follow security best practices
- Keep dependencies updated

## Performance

- Use appropriate caching strategies
- Optimize database queries
- Implement pagination for lists
- Monitor and optimize resource usage
````

## File: frontend/customer/docs/README.md
````markdown
# Hair Salon Booking System Documentation

## Overview

This is a full-stack booking system for hair salons built using NestJS (backend) and Vue 3 (frontend). The system allows customers to book appointments, employees to manage their schedules, and administrators to oversee all operations.

## Project Structure

```
├── backend/               # NestJS backend application
├── frontend/             # Vue 3 frontend application
├── docs/                 # Project documentation
└── architecture/         # System architecture and planning
```

## Technology Stack

### Backend

- NestJS (TypeScript)
- PostgreSQL (Database)
- Redis (Caching)
- Jest (Testing)
- Swagger (API Documentation)

### Frontend

- Vue 3
- Pinia (State Management)
- Vue Router
- TypeScript

## Getting Started

### Prerequisites

- Node.js (v16 or higher)
- npm or yarn
- PostgreSQL
- Redis
- Docker (optional)

### Backend Setup

1. Navigate to the backend directory:
   ```bash
   cd backend
   ```

2. Install dependencies:
   ```bash
   npm install
   ```

3. Set up environment variables:
   - Copy `.env.example` to `.env`
   - Update the variables with your configuration

4. Run database migrations:
   ```bash
   npm run migration:run
   ```

5. Start the development server:
   ```bash
   npm run start:dev
   ```

The API will be available at `http://localhost:3000`
Swagger documentation will be at `http://localhost:3000/api`

### Running Tests

```bash
# Unit tests
npm run test

# e2e tests
npm run test:e2e

# Test coverage
npm run test:cov
```

## Development Guidelines

### Code Style

- Follow the conventions defined in [CONVENTIONS.md](./CONVENTIONS.md)
- Use ESLint and Prettier for code formatting
- Write tests for all new features
- Follow TDD principles

### Git Workflow

1. Create a feature branch from `develop`:
   ```bash
   git checkout -b feature/your-feature-name
   ```

2. Make your changes following the conventions

3. Write tests for your changes

4. Commit your changes using conventional commits

5. Create a pull request to `develop`

### Database Changes

1. Create a new migration:
   ```bash
   npm run migration:create -- -n YourMigrationName
   ```

2. Update the migration file with your changes

3. Test the migration:
   ```bash
   npm run migration:run
   ```

4. Test the rollback:
   ```bash
   npm run migration:revert
   ```

## API Documentation

- API documentation is available through Swagger at `/api` when running the backend
- Keep the Swagger documentation up to date when making API changes
- Follow the API conventions defined in [CONVENTIONS.md](./CONVENTIONS.md)

## Testing Strategy

### Unit Tests

- Write unit tests for:
  - Services
  - Controllers
  - Guards
  - Pipes
  - Custom decorators

### Integration Tests

- Write integration tests for:
  - API endpoints
  - Database operations
  - Cache operations

### E2E Tests

- Write end-to-end tests for critical user flows
- Test the integration between frontend and backend

## Deployment

### Development

- Use `npm run start:dev` for local development
- Development server runs at `http://localhost:3000`

### Production

1. Build the application:
   ```bash
   npm run build
   ```

2. Start the production server:
   ```bash
   npm run start:prod
   ```

### Docker

1. Build the Docker image:
   ```bash
   docker build -t hair-salon-booking .
   ```

2. Run the container:
   ```bash
   docker run -p 3000:3000 hair-salon-booking
   ```

## Monitoring and Logging

- Use built-in NestJS logging
- Monitor application performance
- Track error rates and API usage
- Set up alerts for critical issues

## Security

- Follow security best practices
- Keep dependencies updated
- Use proper authentication and authorization
- Validate all inputs
- Implement rate limiting
- Use HTTPS in production

## Support

1. Check the existing documentation
2. Review the codebase and tests
3. Contact the development team

## License

This project is licensed under the terms specified in the LICENSE file at the root of the repository.
````

## File: frontend/customer/src/assets/base.css
````css
/* color palette from <https://github.com/vuejs/theme> */
:root {
  --vt-c-white: #ffffff;
  --vt-c-white-soft: #f8f8f8;
  --vt-c-white-mute: #f2f2f2;
  --vt-c-black: #181818;
  --vt-c-black-soft: #222222;
  --vt-c-black-mute: #282828;
  --vt-c-indigo: #2c3e50;
  --vt-c-divider-light-1: rgba(60, 60, 60, 0.29);
  --vt-c-divider-light-2: rgba(60, 60, 60, 0.12);
  --vt-c-divider-dark-1: rgba(84, 84, 84, 0.65);
  --vt-c-divider-dark-2: rgba(84, 84, 84, 0.48);
  --vt-c-text-light-1: var(--vt-c-indigo);
  --vt-c-text-light-2: rgba(60, 60, 60, 0.66);
  --vt-c-text-dark-1: var(--vt-c-white);
  --vt-c-text-dark-2: rgba(235, 235, 235, 0.64);
}
/* semantic color variables for this project */
:root {
  --color-background: var(--vt-c-white);
  --color-background-soft: var(--vt-c-white-soft);
  --color-background-mute: var(--vt-c-white-mute);
  --color-border: var(--vt-c-divider-light-2);
  --color-border-hover: var(--vt-c-divider-light-1);
  --color-heading: var(--vt-c-text-light-1);
  --color-text: var(--vt-c-text-light-1);
  --section-gap: 160px;
}
@media (prefers-color-scheme: dark) {
  :root {
    --color-background: var(--vt-c-black);
    --color-background-soft: var(--vt-c-black-soft);
    --color-background-mute: var(--vt-c-black-mute);
    --color-border: var(--vt-c-divider-dark-2);
    --color-border-hover: var(--vt-c-divider-dark-1);
    --color-heading: var(--vt-c-text-dark-1);
    --color-text: var(--vt-c-text-dark-2);
  }
}
*,
*::before,
*::after {
  box-sizing: border-box;
  margin: 0;
  font-weight: normal;
}
body {
  min-height: 100vh;
  color: var(--color-text);
  background: var(--color-background);
  transition:
    color 0.5s,
    background-color 0.5s;
  line-height: 1.6;
  font-family:
    Inter,
    -apple-system,
    BlinkMacSystemFont,
    'Segoe UI',
    Roboto,
    Oxygen,
    Ubuntu,
    Cantarell,
    'Fira Sans',
    'Droid Sans',
    'Helvetica Neue',
    sans-serif;
  font-size: 15px;
  text-rendering: optimizeLegibility;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}
````

## File: frontend/customer/src/assets/logo.svg
````
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 261.76 226.69"><path d="M161.096.001l-30.225 52.351L100.647.001H-.005l130.877 226.688L261.749.001z" fill="#41b883"/><path d="M161.096.001l-30.225 52.351L100.647.001H52.346l78.526 136.01L209.398.001z" fill="#34495e"/></svg>
````

## File: frontend/customer/src/assets/main.css
````css
@tailwind base;
@tailwind components;
@tailwind utilities;
@layer base {
  html {
    font-family: 'Inter', system-ui, sans-serif;
  }
  body {
    @apply bg-gray-50;
  }
}
@layer components {
  .card {
    @apply bg-white rounded-2xl shadow-lg p-6 transition-all duration-200;
  }
  .heading-1 {
    @apply text-4xl font-bold text-gray-900 leading-relaxed;
  }
  .heading-2 {
    @apply text-3xl font-semibold text-gray-800 leading-relaxed;
  }
  .heading-3 {
    @apply text-2xl font-medium text-gray-800 leading-relaxed;
  }
  .text-gradient {
    @apply bg-clip-text text-transparent bg-gradient-to-r from-primary-600 to-primary-400;
  }
  .btn-primary {
    @apply px-6 py-3 bg-gradient-to-r from-primary-600 to-primary-500 
           text-white font-medium rounded-xl shadow-lg 
           hover:from-primary-700 hover:to-primary-600 
           transition-all duration-200 
           disabled:from-gray-400 disabled:to-gray-400;
  }
  .btn-secondary {
    @apply px-6 py-3 bg-white text-primary-600 font-medium 
           rounded-xl border border-primary-200 
           hover:bg-primary-50 transition-all duration-200;
  }
  .input {
    @apply w-full px-4 py-3 bg-white border border-gray-300 
           rounded-xl focus:ring-2 focus:ring-primary-500 
           focus:border-primary-500 transition-all duration-200;
  }
}
````

## File: frontend/customer/src/components/__tests__/BookingForm.spec.ts
````typescript
import { describe, it, expect, vi, beforeEach } from 'vitest'
import { mount } from '@vue/test-utils'
import { createPinia, setActivePinia } from 'pinia'
import { ref } from 'vue'
import BookingForm from '../BookingForm.vue'
import { useServicesStore } from '../../stores/services'
import { useBookingStore } from '../../stores/booking'
// Mock vue-router
const mockRouter = {
  push: vi.fn(),
}
vi.mock('vue-router', () => ({
  useRouter: () => mockRouter,
}))
// Mock the stores
vi.mock('../../stores/services', () => ({
  useServicesStore: vi.fn(),
}))
vi.mock('../../stores/booking', () => ({
  useBookingStore: vi.fn(),
}))
vi.mock('../../stores/display', () => ({
  useDisplayStore: vi.fn(() => ({
    waitingSlots: [],
    waitingCount: 0,
    activeEmployees: [{ id: '1', name: 'Employee 1' }],
  })),
}))
describe('BookingForm', () => {
  const mockService = {
    id: '1',
    name: 'Haircut',
    duration: 30,
    price: '350',
  }
  beforeEach(() => {
    setActivePinia(createPinia())
    // Reset all mocks
    vi.clearAllMocks()
    mockRouter.push.mockClear()
    // Setup default store mocks
    vi.mocked(useServicesStore).mockReturnValue({
      selectedService: mockService,
    } as any)
    vi.mocked(useBookingStore).mockReturnValue({
      isLoading: false,
      error: ref(null),
      setPendingBooking: vi.fn(),
    } as any)
  })
  it('shows message when no service is selected', () => {
    vi.mocked(useServicesStore).mockReturnValue({
      selectedService: null,
    } as any)
    const wrapper = mount(BookingForm)
    expect(wrapper.text()).toContain('Vennligst velg en tjeneste først')
    expect(wrapper.find('button').text()).toBe('Se tjenester')
  })
  it('displays selected service details', () => {
    const wrapper = mount(BookingForm)
    expect(wrapper.text()).toContain(mockService.name)
    expect(wrapper.text()).toContain(`Varighet: ${mockService.duration} minutter`)
    // The price is formatted using Intl.NumberFormat with nb-NO locale
    const formattedPrice = new Intl.NumberFormat('nb-NO', {
      style: 'currency',
      currency: 'NOK',
    }).format(parseFloat(mockService.price))
    expect(wrapper.text()).toContain(formattedPrice)
  })
  it('handles form submission correctly', async () => {
    const mockSetPendingBooking = vi.fn()
    vi.mocked(useBookingStore).mockReturnValue({
      isLoading: false,
      error: ref(null),
      setPendingBooking: mockSetPendingBooking,
    } as any)
    const wrapper = mount(BookingForm)
    // Fill in form data
    await wrapper.find('input[type="text"]').setValue('Test Customer')
    await wrapper.find('input[type="tel"]').setValue('+4712345678')
    // Submit form
    await wrapper.find('form').trigger('submit')
    expect(mockSetPendingBooking).toHaveBeenCalledWith({
      serviceId: mockService.id,
      firstName: 'Test Customer',
      phoneNumber: '+4712345678',
      startTime: expect.any(String),
    })
    expect(mockRouter.push).toHaveBeenCalledWith('/payment')
  })
  it('shows loading state during submission', async () => {
    vi.mocked(useBookingStore).mockReturnValue({
      isLoading: true,
      error: ref(null),
      setPendingBooking: vi.fn(),
    } as any)
    const wrapper = mount(BookingForm)
    expect(wrapper.find('button[type="submit"]').text()).toBe('Behandler...')
  })
  it('disables submit button when no name is entered', () => {
    const wrapper = mount(BookingForm)
    const submitButton = wrapper.find('button[type="submit"]')
    expect(submitButton.attributes('disabled')).toBeDefined()
  })
  it('validates phone number format', async () => {
    const mockSetPendingBooking = vi.fn()
    vi.mocked(useBookingStore).mockReturnValue({
      isLoading: false,
      error: ref(null),
      setPendingBooking: mockSetPendingBooking,
    } as any)
    const wrapper = mount(BookingForm)
    // Fill in name first
    await wrapper.find('input[type="text"]').setValue('Test Customer')
    // Test invalid phone number
    const input = wrapper.find('input[type="tel"]')
    await input.setValue('invalid')
    await wrapper.find('form').trigger('submit')
    expect(mockSetPendingBooking).toHaveBeenCalledWith({
      serviceId: mockService.id,
      firstName: 'Test Customer',
      phoneNumber: 'invalid',
      startTime: expect.any(String),
    })
    expect(mockRouter.push).toHaveBeenCalledWith('/payment')
    // Test valid phone number
    await input.setValue('+4712345678')
    await wrapper.find('form').trigger('submit')
    expect(mockSetPendingBooking).toHaveBeenCalledWith({
      serviceId: mockService.id,
      firstName: 'Test Customer',
      phoneNumber: '+4712345678',
      startTime: expect.any(String),
    })
    expect(mockRouter.push).toHaveBeenCalledWith('/payment')
  })
})
````

## File: frontend/customer/src/components/__tests__/PaymentForm.spec.ts
````typescript
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest'
import { mount } from '@vue/test-utils'
import { createPinia, setActivePinia } from 'pinia'
import PaymentForm from '../PaymentForm.vue'
import { useBookingStore } from '../../stores/booking'
import { useServicesStore } from '../../stores/services'
// Mock vue-router
const mockRouter = {
  push: vi.fn(),
}
vi.mock('vue-router', () => ({
  useRouter: () => mockRouter,
}))
// Mock the stores
vi.mock('../../stores/booking', () => ({
  useBookingStore: vi.fn(),
}))
vi.mock('../../stores/services', () => ({
  useServicesStore: vi.fn(),
}))
describe('PaymentForm', () => {
  const mockPendingBooking = {
    serviceId: '1',
    firstName: 'Test Customer',
    phoneNumber: '+4712345678',
  }
  const mockService = {
    id: '1',
    name: 'Haircut',
    duration: 30,
    price: '350',
  }
  beforeEach(() => {
    setActivePinia(createPinia())
    vi.clearAllMocks()
    mockRouter.push.mockClear()
    // Setup default store mocks
    vi.mocked(useBookingStore).mockReturnValue({
      pendingBooking: mockPendingBooking,
      isLoading: false,
      error: null,
      createWalkInBooking: vi.fn().mockResolvedValue({}),
    } as any)
    vi.mocked(useServicesStore).mockReturnValue({
      selectedService: mockService,
    } as any)
    // Reset timers
    vi.useFakeTimers()
  })
  afterEach(() => {
    vi.useRealTimers()
  })
  const mountComponent = () => {
    return mount(PaymentForm, {
      global: {
        provide: {
          router: mockRouter,
        },
        mocks: {
          $router: mockRouter,
        },
      },
    })
  }
  it('shows message when no booking is found', () => {
    vi.mocked(useBookingStore).mockReturnValue({
      pendingBooking: null,
      isLoading: false,
      error: null,
      createWalkInBooking: vi.fn(),
    } as any)
    const wrapper = mountComponent()
    expect(wrapper.text()).toContain('Ingen aktiv bestilling funnet')
    expect(wrapper.find('button').text()).toBe('Tilbake til tjenester')
  })
  it('displays payment amount correctly', () => {
    const wrapper = mountComponent()
    // Price should be formatted using Intl.NumberFormat with nb-NO locale
    const formattedPrice = new Intl.NumberFormat('nb-NO', {
      style: 'currency',
      currency: 'NOK',
    }).format(parseFloat(mockService.price))
    expect(wrapper.text()).toContain(formattedPrice)
  })
  it('shows loading state during payment processing', async () => {
    const wrapper = mountComponent()
    // Start payment
    await wrapper.find('button.btn-primary').trigger('click')
    await wrapper.vm.$nextTick()
    expect(wrapper.find('button.btn-primary').attributes('disabled')).toBeDefined()
    expect(wrapper.find('.animate-spin').exists()).toBe(true)
    expect(wrapper.text()).toContain('Behandler...')
  })
  it('shows success message after payment', async () => {
    const wrapper = mountComponent()
    // Start payment
    await wrapper.find('button.btn-primary').trigger('click')
    // Wait for payment delay
    await vi.advanceTimersByTime(1500)
    await wrapper.vm.$nextTick()
    // Wait for store operation
    await wrapper.vm.$nextTick()
    await wrapper.vm.$nextTick()
    expect(wrapper.text()).toContain('Betaling vellykket!')
    expect(wrapper.text()).toContain(mockPendingBooking.firstName)
  })
  it('displays error message when payment fails', async () => {
    const mockError = 'Payment failed'
    vi.mocked(useBookingStore).mockReturnValue({
      pendingBooking: mockPendingBooking,
      isLoading: false,
      error: mockError,
      createWalkInBooking: vi.fn().mockRejectedValue(new Error(mockError)),
    } as any)
    const wrapper = mountComponent()
    // Attempt payment
    await wrapper.find('button.btn-primary').trigger('click')
    await vi.advanceTimersByTime(1500)
    await wrapper.vm.$nextTick()
    expect(wrapper.find('.text-red-600').text()).toBe(mockError)
  })
  it('navigates back to home after successful payment', async () => {
    const wrapper = mountComponent()
    // Complete payment
    await wrapper.find('button.btn-primary').trigger('click')
    await vi.advanceTimersByTime(1500)
    await wrapper.vm.$nextTick()
    await wrapper.vm.$nextTick()
    // Click return button
    await wrapper.find('button.btn-secondary').trigger('click')
    expect(mockRouter.push).toHaveBeenCalledWith('/')
  })
  it('handles missing service price gracefully', () => {
    vi.mocked(useServicesStore).mockReturnValue({
      selectedService: null,
    } as any)
    const wrapper = mountComponent()
    const formattedPrice = new Intl.NumberFormat('nb-NO', {
      style: 'currency',
      currency: 'NOK',
    }).format(0)
    expect(wrapper.text()).toContain(formattedPrice)
  })
  it('shows payment button in correct states', async () => {
    const wrapper = mountComponent()
    // Initial state
    expect(wrapper.find('button.btn-primary').text()).toBe('Trykk for å betale')
    // During payment
    await wrapper.find('button.btn-primary').trigger('click')
    await wrapper.vm.$nextTick()
    expect(wrapper.find('button.btn-primary').text()).toContain('Behandler...')
    // After payment
    await vi.advanceTimersByTime(1500)
    await wrapper.vm.$nextTick()
    await wrapper.vm.$nextTick()
    // Success state should show secondary button
    expect(wrapper.find('button.btn-primary').exists()).toBe(false)
    expect(wrapper.find('button.btn-secondary').text()).toBe('Tilbake til forsiden')
  })
  it('shows payment instructions', () => {
    const wrapper = mountComponent()
    expect(wrapper.text()).toContain('Trykk på knappen for å simulere kortbetaling')
  })
})
````

## File: frontend/customer/src/components/__tests__/ServiceList.spec.ts
````typescript
import { describe, it, expect, vi, beforeEach } from 'vitest'
import { mount } from '@vue/test-utils'
import { createTestingPinia } from '@pinia/testing'
import { useServicesStore } from '@/stores/services'
import ServiceList from '../ServiceList.vue'
import { createRouter, createWebHistory } from 'vue-router'
// Create router instance for testing
const router = createRouter({
  history: createWebHistory(),
  routes: [
    {
      path: '/booking',
      name: 'booking',
      component: { template: '<div>Booking</div>' },
    },
  ],
})
// Mock service data
const mockServices = [
  {
    id: '1',
    name: 'Haircut',
    description: 'Basic haircut',
    duration: 30,
    price: '300',
    isActive: true,
    createdAt: '2023-01-01',
    updatedAt: '2023-01-01',
  },
]
describe('ServiceList', () => {
  beforeEach(() => {
    vi.clearAllMocks()
  })
  describe('Loading State', () => {
    it('should show loading skeleton', () => {
      const wrapper = mount(ServiceList, {
        global: {
          plugins: [
            createTestingPinia({
              createSpy: vi.fn,
              initialState: {
                services: {
                  isLoading: true,
                  services: [],
                  error: null,
                },
              },
            }),
            router,
          ],
        },
      })
      expect(wrapper.find('.animate-pulse').exists()).toBe(true)
      expect(wrapper.findAll('.animate-pulse')).toHaveLength(4)
    })
  })
  describe('Error State', () => {
    it('should show error message', () => {
      const errorMessage = 'Failed to fetch services'
      const wrapper = mount(ServiceList, {
        global: {
          plugins: [
            createTestingPinia({
              createSpy: vi.fn,
              initialState: {
                services: {
                  isLoading: false,
                  services: [],
                  error: errorMessage,
                },
              },
            }),
            router,
          ],
        },
      })
      expect(wrapper.text()).toContain(errorMessage)
      expect(wrapper.find('.bg-red-50').exists()).toBe(true)
    })
  })
  describe('Empty State', () => {
    it('should show empty message when no services', () => {
      const wrapper = mount(ServiceList, {
        global: {
          plugins: [
            createTestingPinia({
              createSpy: vi.fn,
              initialState: {
                services: {
                  isLoading: false,
                  services: [],
                  error: null,
                },
              },
            }),
            router,
          ],
        },
      })
      expect(wrapper.text()).toContain('Ingen tjenester tilgjengelig for øyeblikket')
    })
  })
  describe('Services Display', () => {
    it('should display services correctly', () => {
      const wrapper = mount(ServiceList, {
        global: {
          plugins: [
            createTestingPinia({
              createSpy: vi.fn,
              initialState: {
                services: {
                  isLoading: false,
                  services: mockServices,
                  error: null,
                },
              },
            }),
            router,
          ],
        },
      })
      expect(wrapper.text()).toContain(mockServices[0].name)
      expect(wrapper.text()).toContain(mockServices[0].description)
      expect(wrapper.text()).toContain(`${mockServices[0].duration} min`)
      // Check for price in Norwegian format (kr 300,00)
      const formattedPrice = new Intl.NumberFormat('nb-NO', {
        style: 'currency',
        currency: 'NOK',
      }).format(parseFloat(mockServices[0].price))
      expect(wrapper.text()).toContain(formattedPrice)
    })
    it('should select service on click', async () => {
      const wrapper = mount(ServiceList, {
        global: {
          plugins: [
            createTestingPinia({
              createSpy: vi.fn,
              initialState: {
                services: {
                  isLoading: false,
                  services: mockServices,
                  error: null,
                },
              },
            }),
            router,
          ],
        },
      })
      const store = useServicesStore()
      await wrapper.find('.group').trigger('click')
      expect(store.selectService).toHaveBeenCalledWith(mockServices[0])
    })
  })
  describe('Selected Service Actions', () => {
    it('should show bottom sheet when service is selected', () => {
      const wrapper = mount(ServiceList, {
        global: {
          plugins: [
            createTestingPinia({
              createSpy: vi.fn,
              initialState: {
                services: {
                  isLoading: false,
                  services: mockServices,
                  error: null,
                  selectedService: mockServices[0],
                },
              },
            }),
            router,
          ],
        },
      })
      expect(wrapper.find('.fixed.bottom-0').exists()).toBe(true)
      expect(wrapper.text()).toContain('Bestill nå')
      expect(wrapper.text()).toContain('Avbryt')
    })
    it('should clear selection when cancel is clicked', async () => {
      const wrapper = mount(ServiceList, {
        global: {
          plugins: [
            createTestingPinia({
              createSpy: vi.fn,
              initialState: {
                services: {
                  isLoading: false,
                  services: mockServices,
                  error: null,
                  selectedService: mockServices[0],
                },
              },
            }),
            router,
          ],
        },
      })
      const store = useServicesStore()
      await wrapper.find('.btn-secondary').trigger('click')
      expect(store.clearSelection).toHaveBeenCalled()
    })
    it('should navigate to booking when book button is clicked', async () => {
      const wrapper = mount(ServiceList, {
        global: {
          plugins: [
            createTestingPinia({
              createSpy: vi.fn,
              initialState: {
                services: {
                  isLoading: false,
                  services: mockServices,
                  error: null,
                  selectedService: mockServices[0],
                },
              },
            }),
            router,
          ],
        },
      })
      const push = vi.spyOn(router, 'push')
      await wrapper.find('.btn-primary').trigger('click')
      expect(push).toHaveBeenCalledWith('/booking')
    })
  })
})
````

## File: frontend/customer/src/components/__tests__/WaitingTimeDisplay.spec.ts
````typescript
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest'
import { mount } from '@vue/test-utils'
import { createPinia, setActivePinia } from 'pinia'
import WaitingTimeDisplay from '../WaitingTimeDisplay.vue'
import { useDisplayStore } from '../../stores/display'
// Mock the display store
vi.mock('../../stores/display', () => ({
  useDisplayStore: vi.fn(),
}))
describe('WaitingTimeDisplay', () => {
  // Create a mock timer for setInterval
  const mockTimer = {
    hasRef: () => true,
    refresh: () => mockTimer,
    [Symbol.toPrimitive]: () => 123,
  } as unknown as ReturnType<typeof setInterval>
  beforeEach(() => {
    setActivePinia(createPinia())
    vi.useFakeTimers()
    // Set a fixed system time
    vi.setSystemTime(new Date('2024-01-01T12:00:00.000Z'))
    // Setup default mock implementation
    vi.mocked(useDisplayStore).mockReturnValue({
      waitingSlots: [
        { id: '1', customerName: 'Test', estimatedTime: 90 },
        { id: '2', customerName: 'Test2', estimatedTime: 90 },
        { id: '3', customerName: 'Test3', estimatedTime: 90 },
      ],
      waitingCount: 3,
      lastUpdate: new Date('2024-01-01T12:00:00.000Z'),
      isLoading: false,
      error: null,
      startPolling: vi.fn(() => mockTimer),
      cleanup: vi.fn(),
    } as any)
  })
  afterEach(() => {
    vi.useRealTimers()
    vi.clearAllMocks()
  })
  it('renders loading state correctly', () => {
    vi.mocked(useDisplayStore).mockReturnValue({
      waitingSlots: [],
      waitingCount: 0,
      lastUpdate: new Date(),
      isLoading: true,
      error: null,
      startPolling: vi.fn(() => mockTimer),
      cleanup: vi.fn(),
    } as any)
    const wrapper = mount(WaitingTimeDisplay)
    expect(wrapper.find('.animate-pulse').exists()).toBe(true)
  })
  it('renders waiting time and queue information correctly', () => {
    const wrapper = mount(WaitingTimeDisplay)
    // Average waiting time should be 90 minutes
    expect(wrapper.text()).toContain('90min')
    expect(wrapper.text()).toContain('3 venter')
    // Since we're using UTC time directly
    expect(wrapper.text()).toContain('13:00:00')
  })
  it('displays error message when there is an error', () => {
    const errorMessage = 'Failed to fetch queue status'
    vi.mocked(useDisplayStore).mockReturnValue({
      waitingSlots: [],
      waitingCount: 0,
      lastUpdate: new Date(),
      isLoading: false,
      error: errorMessage,
      startPolling: vi.fn(() => mockTimer),
      cleanup: vi.fn(),
    } as any)
    const wrapper = mount(WaitingTimeDisplay)
    expect(wrapper.text()).toContain(errorMessage)
    expect(wrapper.find('.text-red-600').exists()).toBe(true)
  })
  it('starts polling on mount and cleans up on unmount', async () => {
    const mockStartPolling = vi.fn(() => mockTimer)
    const mockCleanup = vi.fn()
    vi.mocked(useDisplayStore).mockReturnValue({
      waitingSlots: [{ id: '1', customerName: 'Test', estimatedTime: 90 }],
      waitingCount: 1,
      lastUpdate: new Date('2024-01-01T12:00:00.000Z'),
      isLoading: false,
      error: null,
      startPolling: mockStartPolling,
      cleanup: mockCleanup,
    } as any)
    const wrapper = mount(WaitingTimeDisplay)
    // Check that polling was started
    expect(mockStartPolling).toHaveBeenCalled()
    // Unmount and verify cleanup
    wrapper.unmount()
    expect(mockCleanup).toHaveBeenCalled()
  })
  it('formats time correctly for different locales', () => {
    const now = new Date('2024-01-01T12:34:56.000Z')
    vi.mocked(useDisplayStore).mockReturnValue({
      waitingSlots: [{ id: '1', customerName: 'Test', estimatedTime: 90 }],
      waitingCount: 1,
      lastUpdate: now,
      isLoading: false,
      error: null,
      startPolling: vi.fn(() => mockTimer),
      cleanup: vi.fn(),
    } as any)
    const wrapper = mount(WaitingTimeDisplay)
    // Since we're using UTC time directly
    expect(wrapper.text()).toContain('13:34:56')
  })
})
````

## File: frontend/customer/src/components/BookingForm.vue
````vue
<template>
  <div class="max-w-lg mx-auto">
    <h2 class="heading-1 text-gradient text-center py-6">Reserver time</h2>
    <div v-if="!selectedService" class="card text-center py-12">
      <p class="text-gray-600 mb-6">Vennligst velg en tjeneste først</p>
      <button @click="$router.push('/')" class="btn-secondary">Se tjenester</button>
    </div>
    <form v-else @submit.prevent="handleSubmit" class="space-y-8">
      <!-- Service Summary -->
      <div class="card bg-gradient-to-br from-white to-gray-50">
        <h3 class="text-lg font-medium text-gray-800 mb-4">Valgt tjeneste</h3>
        <div class="flex justify-between items-start">
          <div>
            <p class="text-xl font-bold text-gray-900">{{ selectedService.name }}</p>
            <p class="text-gray-600 mt-1">Varighet: {{ selectedService.duration }} minutter</p>
          </div>
          <p class="text-xl font-bold text-gradient">
            {{
              new Intl.NumberFormat('nb-NO', { style: 'currency', currency: 'NOK' }).format(
                parseFloat(selectedService.price),
              )
            }}
          </p>
        </div>
      </div>
      <!-- Queue Status -->
      <div class="card">
        <h3 class="text-lg font-medium text-gray-800 mb-4">Ventetid</h3>
        <div class="space-y-4">
          <div class="flex items-center justify-between">
            <div>
              <p class="text-xl font-bold text-gray-900">{{ calculateWaitTime }} minutter</p>
              <p class="text-gray-600 mt-1">{{ displayStore.waitingCount ?? 0 }} personer venter</p>
            </div>
            <div class="text-sm text-gray-500">
              {{ displayStore.activeEmployees.length }} frisører på jobb
            </div>
          </div>
        </div>
      </div>
      <!-- Customer Info -->
      <div class="card space-y-6">
        <div>
          <h3 class="text-lg font-medium text-gray-800 mb-4">Ditt navn</h3>
          <input
            type="text"
            v-model="firstName"
            required
            placeholder="Fornavn"
            class="input text-lg"
          />
        </div>
        <div>
          <h3 class="text-lg font-medium text-gray-800 mb-4">Ditt telefonnummer (valgfritt)</h3>
          <input
            type="tel"
            v-model="phoneNumber"
            placeholder="+47 XXX XX XXX"
            class="input text-lg"
            :class="{ 'ring-2 ring-red-500 border-red-500': error }"
          />
          <p v-if="error" class="mt-2 text-sm text-red-600">{{ error }}</p>
        </div>
      </div>
      <!-- Submit Button -->
      <button type="submit" :disabled="isLoading || !firstName" class="btn-primary w-full text-lg">
        <span v-if="isLoading">Behandler...</span>
        <span v-else>Fortsett til betaling</span>
      </button>
    </form>
  </div>
</template>
<script setup lang="ts">
import { ref, computed } from 'vue'
import { useRouter } from 'vue-router'
import { useServicesStore } from '../stores/services'
import { useBookingStore } from '../stores/booking'
import { useDisplayStore } from '../stores/display'
const router = useRouter()
const servicesStore = useServicesStore()
const bookingStore = useBookingStore()
const displayStore = useDisplayStore()
const { selectedService } = servicesStore
const { isLoading, error } = bookingStore
// Form data
const firstName = ref('')
const phoneNumber = ref('')
// Calculate wait time based on queue and selected service
const calculateWaitTime = computed(() => {
  if (!selectedService || !displayStore.waitingSlots.length) return 0
  // Base wait time from current queue
  const queueWaitTime = displayStore.waitingSlots.reduce((total, slot) => {
    return total + (slot.estimatedTime || 0)
  }, 0)
  // Add selected service duration
  return queueWaitTime + selectedService.duration
})
const handleSubmit = async () => {
  if (!selectedService || !firstName.value) return
  // Set pending booking and navigate to payment
  bookingStore.setPendingBooking({
    serviceId: selectedService.id,
    firstName: firstName.value,
    phoneNumber: phoneNumber.value || undefined,
    startTime: new Date().toISOString(),
  })
  // Navigate to payment page
  router.push('/payment')
}
</script>
````

## File: frontend/customer/src/components/PaymentForm.vue
````vue
<template>
  <div class="max-w-lg mx-auto">
    <h2 class="heading-1 text-gradient text-center py-6">Betaling</h2>
    <div v-if="!pendingBooking" class="card text-center py-12">
      <p class="text-gray-600 mb-6">Ingen aktiv bestilling funnet</p>
      <button @click="$router.push('/')" class="btn-secondary">Tilbake til tjenester</button>
    </div>
    <div v-else>
      <!-- Payment Terminal Screen -->
      <div v-if="!isPaid" class="card bg-gradient-to-br from-white to-gray-50 space-y-8">
        <div class="text-center">
          <div
            class="inline-flex items-center justify-center w-16 h-16 rounded-full bg-primary-100 mb-4"
          >
            <svg
              xmlns="http://www.w3.org/2000/svg"
              class="h-8 w-8 text-primary-600"
              fill="none"
              viewBox="0 0 24 24"
              stroke="currentColor"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                stroke-width="2"
                d="M3 10h18M7 15h1m4 0h1m-7 4h12a3 3 0 003-3V8a3 3 0 00-3-3H6a3 3 0 00-3 3v8a3 3 0 003 3z"
              />
            </svg>
          </div>
          <div class="text-5xl font-bold text-gradient mb-4">
            {{
              new Intl.NumberFormat('nb-NO', { style: 'currency', currency: 'NOK' }).format(
                parseFloat(selectedService?.price || '0'),
              )
            }}
          </div>
          <p class="text-gray-600">Klar for betaling</p>
        </div>
        <div class="pt-4">
          <button
            @click="handlePayment"
            :disabled="isLoading || isProcessing"
            class="w-full btn-primary text-lg py-6"
          >
            <span v-if="isLoading || isProcessing" class="flex items-center justify-center">
              <svg
                class="animate-spin h-5 w-5 mr-3"
                xmlns="http://www.w3.org/2000/svg"
                fill="none"
                viewBox="0 0 24 24"
              >
                <circle
                  class="opacity-25"
                  cx="12"
                  cy="12"
                  r="10"
                  stroke="currentColor"
                  stroke-width="4"
                ></circle>
                <path
                  class="opacity-75"
                  fill="currentColor"
                  d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
                ></path>
              </svg>
              Behandler...
            </span>
            <span v-else>Trykk for å betale</span>
          </button>
        </div>
        <p class="text-center text-sm text-gray-500">
          Trykk på knappen for å simulere kortbetaling
        </p>
      </div>
      <!-- Success Screen -->
      <div v-else class="card bg-gradient-to-br from-white to-gray-50 space-y-8 text-center">
        <div class="text-green-500">
          <svg
            xmlns="http://www.w3.org/2000/svg"
            class="h-20 w-20 mx-auto"
            fill="none"
            viewBox="0 0 24 24"
            stroke="currentColor"
          >
            <path
              stroke-linecap="round"
              stroke-linejoin="round"
              stroke-width="2"
              d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"
            />
          </svg>
        </div>
        <div>
          <h3 class="text-2xl font-bold text-gray-900 mb-2">Betaling vellykket!</h3>
          <p class="text-gray-600">Din bestilling er bekreftet</p>
          <p class="text-xl font-medium text-primary-600 mt-2">
            {{ pendingBooking.firstName }}
          </p>
        </div>
        <div class="pt-4">
          <button @click="$router.push('/')" class="btn-secondary">Tilbake til forsiden</button>
        </div>
      </div>
      <div
        v-if="error"
        class="mt-4 p-4 bg-red-50 border border-red-100 rounded-xl text-red-600 text-center"
      >
        {{ error }}
      </div>
    </div>
  </div>
</template>
<script setup lang="ts">
import { ref } from 'vue'
import { useRouter } from 'vue-router'
import { useBookingStore } from '../stores/booking'
import { useServicesStore } from '../stores/services'
const router = useRouter()
const bookingStore = useBookingStore()
const servicesStore = useServicesStore()
const { pendingBooking, isLoading, error } = bookingStore
const { selectedService } = servicesStore
const isPaid = ref(false)
const isProcessing = ref(false)
// Simulate payment processing and create booking
const handlePayment = async () => {
  if (!pendingBooking || isProcessing.value) return
  try {
    isProcessing.value = true
    // Simulate payment processing delay
    await new Promise((resolve) => setTimeout(resolve, 1500))
    // Create booking with payment confirmation
    await bookingStore.createWalkInBooking({
      ...pendingBooking,
      isPaid: true,
    })
    isPaid.value = true
  } catch (err) {
    console.error('Payment failed:', err)
  } finally {
    isProcessing.value = false
  }
}
</script>
````

## File: frontend/customer/src/components/ServiceList.vue
````vue
<template>
  <div class="max-w-4xl mx-auto">
    <h2 class="heading-1 text-gradient text-center py-6">Velg tjeneste</h2>
    <div v-if="store.isLoading" class="grid gap-6 md:grid-cols-2">
      <div v-for="n in 4" :key="n" class="animate-pulse">
        <div class="card h-48 flex flex-col justify-between">
          <div class="space-y-4">
            <div class="h-8 bg-gray-200 rounded-lg w-2/3"></div>
            <div class="h-4 bg-gray-200 rounded-lg w-full"></div>
            <div class="h-4 bg-gray-200 rounded-lg w-3/4"></div>
          </div>
          <div class="h-10 bg-gray-200 rounded-lg w-1/3"></div>
        </div>
      </div>
    </div>
    <div
      v-else-if="store.error"
      class="card bg-red-50 border-2 border-red-100 text-red-600 text-center"
    >
      {{ store.error }}
    </div>
    <div v-else-if="store.services.length === 0" class="text-center py-8">
      <p class="text-gray-600">Ingen tjenester tilgjengelig for øyeblikket</p>
    </div>
    <div v-else class="grid gap-6 md:grid-cols-2">
      <div
        v-for="service in store.services"
        :key="service.id"
        class="group"
        @click="store.selectService(service)"
      >
        <div
          class="card hover:scale-102 hover:shadow-xl transition-all duration-300 cursor-pointer h-full"
          :class="{
            'ring-2 ring-primary-500 bg-primary-50': store.selectedService?.id === service.id,
          }"
        >
          <div class="flex flex-col h-full">
            <div class="flex-grow">
              <h3 class="text-2xl font-bold text-gray-900 group-hover:text-primary-600 mb-3">
                {{ service.name }}
              </h3>
              <p class="text-gray-600 mb-4">{{ service.description }}</p>
            </div>
            <div class="flex items-center justify-between pt-4 border-t border-gray-100">
              <div class="flex items-center text-gray-500">
                <svg
                  xmlns="http://www.w3.org/2000/svg"
                  class="h-5 w-5 mr-2"
                  viewBox="0 0 20 20"
                  fill="currentColor"
                >
                  <path
                    fill-rule="evenodd"
                    d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-12a1 1 0 10-2 0v4a1 1 0 00.293.707l2.828 2.829a1 1 0 101.415-1.415L11 9.586V6z"
                    clip-rule="evenodd"
                  />
                </svg>
                {{ service.duration }} min
              </div>
              <span class="text-xl font-bold text-gradient">
                {{
                  new Intl.NumberFormat('nb-NO', { style: 'currency', currency: 'NOK' }).format(
                    parseFloat(service.price),
                  )
                }}
              </span>
            </div>
          </div>
        </div>
      </div>
    </div>
    <!-- Selected Service Bottom Sheet -->
    <div
      v-if="store.selectedService"
      class="fixed bottom-0 left-0 right-0 bg-white shadow-[0_-8px_16px_-4px_rgb(0,0,0,0.1)] border-t transform transition-transform duration-300"
    >
      <div class="max-w-4xl mx-auto p-6">
        <div class="flex items-center justify-between">
          <div>
            <h4 class="text-xl font-bold text-gray-900">{{ store.selectedService.name }}</h4>
            <div class="flex items-center space-x-3 mt-1">
              <span class="text-xl font-bold text-gradient">
                {{
                  new Intl.NumberFormat('nb-NO', { style: 'currency', currency: 'NOK' }).format(
                    parseFloat(store.selectedService.price),
                  )
                }}
              </span>
              <span class="text-gray-500">·</span>
              <span class="text-gray-600">{{ store.selectedService.duration }} min</span>
            </div>
          </div>
          <div class="flex gap-3">
            <button @click="store.clearSelection" class="btn-secondary">Avbryt</button>
            <button @click="$router.push('/booking')" class="btn-primary">Bestill nå</button>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>
<script setup lang="ts">
import { onMounted } from 'vue'
import { useRouter } from 'vue-router'
import { useServicesStore } from '@/stores/services'
const router = useRouter()
const store = useServicesStore()
onMounted(() => {
  store.fetchServices()
})
</script>
````

## File: frontend/customer/src/components/WaitingTimeDisplay.vue
````vue
<template>
  <div class="card bg-gradient-to-br from-white to-gray-50">
    <div class="text-center">
      <h2 class="text-2xl font-bold text-gradient mb-6">Estimert ventetid</h2>
      <div v-if="store.isLoading" class="animate-pulse space-y-4">
        <div class="h-12 bg-gray-200 rounded-lg w-32 mx-auto"></div>
        <div class="h-6 bg-gray-200 rounded-lg w-24 mx-auto"></div>
      </div>
      <template v-else>
        <div class="mb-4">
          <div class="text-5xl font-bold text-gradient mb-2">
            {{ calculateEstimatedWaitTime }}min
          </div>
          <div class="flex items-center justify-center space-x-2 text-gray-600">
            <svg
              xmlns="http://www.w3.org/2000/svg"
              class="h-5 w-5"
              viewBox="0 0 20 20"
              fill="currentColor"
            >
              <path
                d="M13 6a3 3 0 11-6 0 3 3 0 016 0zM18 8a2 2 0 11-4 0 2 2 0 014 0zM14 15a4 4 0 00-8 0v3h8v-3zM6 8a2 2 0 11-4 0 2 2 0 014 0zM16 18v-3a5.972 5.972 0 00-.75-2.906A3.005 3.005 0 0119 15v3h-3zM4.75 12.094A5.973 5.973 0 004 15v3H1v-3a3 3 0 013.75-2.906z"
              />
            </svg>
            <span class="text-lg">{{ store.waitingCount ?? 0 }} venter</span>
          </div>
        </div>
        <div class="text-sm text-gray-500 flex items-center justify-center space-x-1">
          <svg
            xmlns="http://www.w3.org/2000/svg"
            class="h-4 w-4"
            viewBox="0 0 20 20"
            fill="currentColor"
          >
            <path
              fill-rule="evenodd"
              d="M10 18a8 8 0 100-16 8 8 0 000 16zm1-12a1 1 0 10-2 0v4a1 1 0 00.293.707l2.828 2.829a1 1 0 101.415-1.415L11 9.586V6z"
              clip-rule="evenodd"
            />
          </svg>
          <span>Oppdatert {{ formatTime(store.lastUpdate) }}</span>
        </div>
      </template>
      <div
        v-if="store.error"
        class="mt-4 text-red-600 text-sm bg-red-50 border border-red-100 rounded-lg p-2"
      >
        {{ store.error }}
      </div>
    </div>
  </div>
</template>
<script setup lang="ts">
import { computed, onMounted, onUnmounted } from 'vue'
import { useDisplayStore } from '../stores/display'
interface WaitingSlot {
  estimatedTime?: number;
}
const store = useDisplayStore()
const calculateEstimatedWaitTime = computed(() => {
  if (!store.waitingSlots.length) return 0
  // Calculate average waiting time from all slots with estimatedTime
  const slotsWithTime = store.waitingSlots.filter((slot: WaitingSlot) => slot.estimatedTime !== undefined)
  if (!slotsWithTime.length) return 0
  const totalTime = slotsWithTime.reduce((sum: number, slot: WaitingSlot) => sum + (slot.estimatedTime || 0), 0)
  return Math.round(totalTime / slotsWithTime.length)
})
const formatTime = (date: Date) => {
  return new Intl.DateTimeFormat('nb-NO', {
    hour: '2-digit',
    minute: '2-digit',
    second: '2-digit',
    timeZone: 'Europe/Oslo',
    hourCycle: 'h23'
  }).format(date)
}
// Start polling when component mounts
onMounted(() => {
  store.startPolling()
})
// Clean up when component unmounts
onUnmounted(() => {
  store.cleanup()
})
</script>
````

## File: frontend/customer/src/router/index.ts
````typescript
import { createRouter, createWebHistory } from 'vue-router'
import ServiceList from '@/components/ServiceList.vue'
import BookingForm from '@/components/BookingForm.vue'
import PaymentForm from '@/components/PaymentForm.vue'
import TVDisplayView from '@/views/TVDisplayView.vue'
const router = createRouter({
  history: createWebHistory(import.meta.env.BASE_URL),
  routes: [
    {
      path: '/',
      name: 'home',
      component: ServiceList,
    },
    {
      path: '/booking',
      name: 'booking',
      component: BookingForm,
    },
    {
      path: '/payment',
      name: 'payment',
      component: PaymentForm,
    },
    {
      path: '/tv-display',
      name: 'tv-display',
      component: TVDisplayView,
    },
  ],
})
export default router
````

## File: frontend/customer/src/stores/__tests__/booking.spec.ts
````typescript
import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest'
import { setActivePinia, createPinia } from 'pinia'
import { useBookingStore } from '../booking'
import type { CreateWalkInBookingParams } from '../types'
// Test data
interface MockResponse {
  id: string
  serviceId: string
  firstName: string
  phoneNumber: string
  status: 'confirmed'
}
const createMockBooking = (
  overrides: Partial<CreateWalkInBookingParams> = {},
): CreateWalkInBookingParams => ({
  serviceId: '1',
  firstName: 'Test',
  phoneNumber: '12345678',
  isPaid: true,
  ...overrides,
})
const createMockResponse = (overrides: Partial<MockResponse> = {}): MockResponse => ({
  id: '1',
  serviceId: '1',
  firstName: 'Test',
  phoneNumber: '12345678',
  status: 'confirmed',
  ...overrides,
})
// Helper functions
const mockFetchSuccess = (response: any) => {
  global.fetch = vi.fn().mockImplementation(() =>
    Promise.resolve({
      ok: true,
      json: () => Promise.resolve(response),
    }),
  )
}
const mockFetchError = (message: string) => {
  global.fetch = vi.fn().mockImplementation(() =>
    Promise.resolve({
      ok: false,
      json: () => Promise.resolve({ message }),
    }),
  )
}
const mockNetworkError = (message: string) => {
  global.fetch = vi.fn().mockImplementation(() => Promise.reject(new Error(message)))
}
const verifyFetchCall = (mockBooking: CreateWalkInBookingParams) => {
  expect(global.fetch).toHaveBeenCalledWith('http://localhost:3000/bookings/walk-in', {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      'X-Shop-Code': 'SHOP123',
      accept: '*/*',
    },
    body: JSON.stringify(mockBooking),
  })
}
// Tests
describe('Booking Store', () => {
  let store: ReturnType<typeof useBookingStore>
  beforeEach(() => {
    setActivePinia(createPinia())
    vi.clearAllMocks()
    store = useBookingStore()
  })
  afterEach(() => {
    vi.unstubAllGlobals()
  })
  it('has empty initial state', () => {
    expect(store.currentBooking).toBeNull()
    expect(store.pendingBooking).toBeNull()
    expect(store.isLoading).toBeFalsy()
    expect(store.error).toBeNull()
  })
  it('creates walk-in booking successfully', async () => {
    const mockBooking = createMockBooking()
    const mockResponse = createMockResponse()
    mockFetchSuccess(mockResponse)
    await store.createWalkInBooking(mockBooking)
    verifyFetchCall(mockBooking)
    expect(store.currentBooking).toEqual(mockResponse)
    expect(store.isLoading).toBeFalsy()
    expect(store.error).toBeNull()
  })
  it('handles fetch error in walk-in booking', async () => {
    const mockBooking = createMockBooking()
    const errorMessage = 'Failed to create booking'
    mockFetchError(errorMessage)
    await expect(store.createWalkInBooking(mockBooking)).rejects.toThrow(errorMessage)
    verifyFetchCall(mockBooking)
    expect(store.currentBooking).toBeNull()
    expect(store.isLoading).toBeFalsy()
    expect(store.error).toBe(errorMessage)
  })
  it('handles network error in walk-in booking', async () => {
    const mockBooking = createMockBooking()
    const errorMessage = 'Network error'
    mockNetworkError(errorMessage)
    await expect(store.createWalkInBooking(mockBooking)).rejects.toThrow(errorMessage)
    verifyFetchCall(mockBooking)
    expect(store.currentBooking).toBeNull()
    expect(store.isLoading).toBeFalsy()
    expect(store.error).toBe(errorMessage)
  })
  it('sets pending booking', () => {
    const pendingBooking = createMockBooking()
    store.setPendingBooking(pendingBooking)
    expect(store.pendingBooking).toEqual(pendingBooking)
  })
  it('clears booking state', async () => {
    // Setup: Create a booking first
    const mockBooking = createMockBooking()
    const mockResponse = createMockResponse()
    mockFetchSuccess(mockResponse)
    await store.createWalkInBooking(mockBooking)
    expect(store.currentBooking).toEqual(mockResponse)
    // Test: Clear the booking
    store.clearBooking()
    expect(store.currentBooking).toBeNull()
    expect(store.pendingBooking).toBeNull()
    expect(store.error).toBeNull()
  })
})
````

## File: frontend/customer/src/stores/__tests__/counter.spec.ts
````typescript
import { describe, it, expect, beforeEach } from 'vitest'
import { setActivePinia, createPinia } from 'pinia'
import { useCounterStore } from '../counter'
describe('Counter Store', () => {
  beforeEach(() => {
    setActivePinia(createPinia())
  })
  it('initializes with count of 0', () => {
    const store = useCounterStore()
    expect(store.count).toBe(0)
  })
  it('doubles the count correctly', () => {
    const store = useCounterStore()
    store.count = 2
    expect(store.doubleCount).toBe(4)
  })
  it('increments the count', () => {
    const store = useCounterStore()
    store.increment()
    expect(store.count).toBe(1)
  })
})
````

## File: frontend/customer/src/stores/__tests__/display.spec.ts
````typescript
import { describe, it, expect, beforeEach, vi } from 'vitest'
import { setActivePinia, createPinia } from 'pinia'
import { useDisplayStore } from '../display'
import axios from 'axios'
vi.mock('axios')
describe('Display Store', () => {
  beforeEach(() => {
    setActivePinia(createPinia())
    vi.clearAllMocks()
  })
  it('manages employees', () => {
    const store = useDisplayStore()
    // Check initial state
    expect(store.employees).toHaveLength(2)
    expect(store.activeEmployees).toHaveLength(2)
    // Test employee deactivation
    store.employees[0].isActive = false
    expect(store.activeEmployees).toHaveLength(1)
  })
  it('manages waiting slots', async () => {
    // Setup mock API response
    vi.mocked(axios.get).mockResolvedValue({
      data: {
        count: 1,
        customers: [{ firstName: 'Test', estimatedWaitingTime: 15 }],
      },
    })
    const store = useDisplayStore()
    // Check initial state
    expect(store.waitingSlots).toHaveLength(0)
    expect(store.waitingCount).toBeNull() // Initially null while loading
    expect(store.hasAvailableSlot).toBeNull() // Initially null while loading
    // Fetch data
    await store.fetchWaitingSlots()
    // Check updated state
    expect(store.waitingSlots).toHaveLength(1)
    expect(store.waitingCount).toBe(1)
    expect(store.waitingSlots[0]).toMatchObject({
      customerName: 'Test',
      estimatedTime: 15,
    })
  })
  it('handles API errors', async () => {
    vi.mocked(axios.get).mockRejectedValue(new Error('API Error'))
    const store = useDisplayStore()
    await store.fetchWaitingSlots()
    expect(store.error).toBe('Kunne ikke hente venteliste')
    expect(store.waitingSlots).toHaveLength(0)
    expect(store.waitingCount).toBeNull()
    expect(store.hasAvailableSlot).toBeNull()
  })
  it('calculates slot availability', async () => {
    vi.mocked(axios.get).mockResolvedValue({
      data: {
        count: 3, // More customers than employees
        customers: [
          { firstName: 'Test1', estimatedWaitingTime: 10 },
          { firstName: 'Test2', estimatedWaitingTime: 20 },
          { firstName: 'Test3', estimatedWaitingTime: 30 },
        ],
      },
    })
    const store = useDisplayStore()
    // Initially null while loading
    expect(store.hasAvailableSlot).toBeNull()
    // After fetching (more customers than employees)
    await store.fetchWaitingSlots()
    expect(store.hasAvailableSlot).toBe(false)
    // Mock fewer customers
    vi.mocked(axios.get).mockResolvedValueOnce({
      data: {
        count: 1,
        customers: [{ firstName: 'Test1', estimatedWaitingTime: 10 }],
      },
    })
    // After fetching (fewer customers than employees)
    await store.fetchWaitingSlots(true)
    expect(store.hasAvailableSlot).toBe(true)
  })
})
````

## File: frontend/customer/src/stores/__tests__/services.spec.ts
````typescript
import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest'
import { setActivePinia, createPinia } from 'pinia'
import { useServicesStore } from '../services'
import type { Service } from '../types'
// Test data
const createMockService = (overrides: Partial<Service> = {}): Service => ({
  id: '1',
  name: 'Haircut',
  description: 'Basic haircut',
  duration: 30,
  price: '300',
  isActive: true,
  createdAt: '2023-01-01',
  updatedAt: '2023-01-01',
  ...overrides,
});
// Helper functions
const mockFetchSuccess = (response: Service[] = []) => {
  global.fetch = vi.fn().mockImplementation(() =>
    Promise.resolve({
      ok: true,
      json: () => Promise.resolve(response),
    }),
  );
};
const mockFetchError = (message: string) => {
  global.fetch = vi.fn().mockImplementation(() =>
    Promise.resolve({
      ok: false,
      json: () => Promise.resolve({ message }),
    }),
  );
};
const mockNetworkError = (message: string) => {
  global.fetch = vi.fn().mockImplementation(() => 
    Promise.reject(new Error(message))
  );
};
const waitForInitialFetch = () => new Promise((resolve) => setImmediate(resolve));
describe('Services Store', () => {
  let store: ReturnType<typeof useServicesStore>;
  const mockService = createMockService();
  beforeEach(() => {
    setActivePinia(createPinia());
    vi.clearAllMocks();
    mockFetchSuccess([]); // Default to empty services list
    store = useServicesStore();
  });
  afterEach(() => {
    vi.unstubAllGlobals();
  });
  it('has correct empty initial state', async () => {
    // Initial state should show loading
    expect(store.isLoading).toBeTruthy();
    expect(store.services).toEqual([]);
    expect(store.error).toBeNull();
    expect(store.selectedService).toBeNull();
    // Wait for the initial fetch to complete
    await waitForInitialFetch();
    // After fetch completes
    expect(store.isLoading).toBeFalsy();
    expect(store.services).toEqual([]);
    expect(store.error).toBeNull();
    expect(store.selectedService).toBeNull();
  });
  it('fetches services successfully', async () => {
    mockFetchSuccess([mockService]);
    await store.fetchServices();
    expect(global.fetch).toHaveBeenCalledWith('http://localhost:3000/services');
    expect(store.services).toEqual([mockService]);
    expect(store.isLoading).toBeFalsy();
    expect(store.error).toBeNull();
  });
  it('handles fetch error', async () => {
    mockFetchError('Failed to fetch services');
    await store.fetchServices();
    expect(store.services).toEqual([]);
    expect(store.isLoading).toBeFalsy();
    expect(store.error).toBe('Failed to fetch services');
  });
  it('handles network error', async () => {
    mockNetworkError('Network error');
    await store.fetchServices();
    expect(store.services).toEqual([]);
    expect(store.isLoading).toBeFalsy();
    expect(store.error).toBe('Network error');
  });
  it('selects a service', async () => {
    await waitForInitialFetch();
    store.selectService(mockService);
    expect(store.selectedService).toEqual(mockService);
  });
  it('clears selected service', async () => {
    await waitForInitialFetch();
    // First select a service
    store.selectService(mockService);
    expect(store.selectedService).toEqual(mockService);
    // Then clear it
    store.clearSelection();
    expect(store.selectedService).toBeNull();
  });
});
````

## File: frontend/customer/src/stores/__tests__/waiting.spec.ts
````typescript
import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest'
import { setActivePinia, createPinia } from 'pinia'
import { useWaitingStore } from '../waiting'
import { flushPromises } from '@vue/test-utils'
describe('Waiting Store', () => {
  beforeEach(() => {
    setActivePinia(createPinia())
    vi.useFakeTimers()
    // Mock fetch for all tests
    global.fetch = vi.fn().mockResolvedValue({
      ok: true,
      json: () => Promise.resolve(0),
    })
  })
  afterEach(() => {
    vi.useRealTimers()
    vi.restoreAllMocks()
  })
  describe('Initial State', () => {
    it('initializes with default values', () => {
      const store = useWaitingStore()
      expect(store.queueStatus).toMatchObject({
        peopleWaiting: 0,
        estimatedWaitTime: 0,
      })
      expect(store.isLoading).toBe(false)
      expect(store.error).toBeNull()
    })
  })
  describe('Computed Properties', () => {
    it('formats wait time correctly with only minutes', () => {
      const store = useWaitingStore()
      store.queueStatus.estimatedWaitTime = 45
      expect(store.formattedWaitTime).toBe('45min')
    })
    it('formats wait time correctly with hours and minutes', () => {
      const store = useWaitingStore()
      store.queueStatus.estimatedWaitTime = 90 // 1h 30min
      expect(store.formattedWaitTime).toBe('1h 30min')
    })
  })
  describe('API Methods', () => {
    it('fetches queue status successfully', async () => {
      const mockResponse = 3 // 3 people waiting
      global.fetch = vi.fn().mockResolvedValue({
        ok: true,
        json: () => Promise.resolve(mockResponse),
      })
      const store = useWaitingStore()
      await store.fetchQueueStatus()
      expect(store.isLoading).toBe(false)
      expect(store.error).toBeNull()
      expect(store.queueStatus).toMatchObject({
        peopleWaiting: 3,
        estimatedWaitTime: 90, // 3 people * 30 minutes
      })
      expect(store.queueStatus.lastUpdated).toBeDefined()
    })
    it('handles fetch error correctly with Error instance', async () => {
      const errorMessage = 'Failed to fetch queue status'
      global.fetch = vi.fn().mockRejectedValue(new Error(errorMessage))
      const store = useWaitingStore()
      await store.fetchQueueStatus()
      expect(store.isLoading).toBe(false)
      expect(store.error).toBe(errorMessage)
      expect(store.queueStatus).toMatchObject({
        peopleWaiting: 0,
        estimatedWaitTime: 0,
      })
    })
    it('handles fetch error correctly with non-Error instance', async () => {
      const errorMessage = 'Network error'
      global.fetch = vi.fn().mockRejectedValue(errorMessage)
      const store = useWaitingStore()
      await store.fetchQueueStatus()
      expect(store.isLoading).toBe(false)
      expect(store.error).toBe('Failed to fetch queue status')
      expect(store.queueStatus).toMatchObject({
        peopleWaiting: 0,
        estimatedWaitTime: 0,
      })
    })
    it('handles non-ok response correctly', async () => {
      global.fetch = vi.fn().mockResolvedValue({
        ok: false,
      })
      const store = useWaitingStore()
      await store.fetchQueueStatus()
      expect(store.isLoading).toBe(false)
      expect(store.error).toBe('Failed to fetch queue status')
    })
  })
  describe('Polling', () => {
    it('starts polling and fetches initial data', async () => {
      const fetchMock = vi.fn().mockResolvedValue({
        ok: true,
        json: () => Promise.resolve(0),
      })
      global.fetch = fetchMock
      const store = useWaitingStore()
      store.startPolling(1000)
      await flushPromises()
      expect(fetchMock).toHaveBeenCalledTimes(1)
    })
    it('continues polling at specified interval', async () => {
      const fetchMock = vi.fn().mockResolvedValue({
        ok: true,
        json: () => Promise.resolve(0),
      })
      global.fetch = fetchMock
      const store = useWaitingStore()
      store.startPolling(1000) // 1 second interval
      await flushPromises()
      expect(fetchMock).toHaveBeenCalledTimes(1)
      // Advance timer by 2 seconds
      await vi.advanceTimersByTimeAsync(2000)
      await flushPromises()
      expect(fetchMock).toHaveBeenCalledTimes(3)
    })
    it('returns interval ID that can be cleared', async () => {
      const fetchMock = vi.fn().mockResolvedValue({
        ok: true,
        json: () => Promise.resolve(0),
      })
      global.fetch = fetchMock
      const store = useWaitingStore()
      const intervalId = store.startPolling(1000)
      await flushPromises()
      expect(fetchMock).toHaveBeenCalledTimes(1)
      clearInterval(intervalId)
      await vi.advanceTimersByTimeAsync(2000)
      await flushPromises()
      expect(fetchMock).toHaveBeenCalledTimes(1) // No additional calls after clearing
    })
  })
})
````

## File: frontend/customer/src/stores/booking.ts
````typescript
import { defineStore } from 'pinia'
import { ref } from 'vue'
// TODO: This should be stored securely and provided by environment variables
const SHOP_CODE = 'SHOP123'
const API_URL = import.meta.env.VITE_API_URL || 'http://localhost:3000'
export interface Booking {
  serviceId: string
  firstName: string
  phoneNumber?: string
  status: 'pending' | 'confirmed' | 'cancelled'
}
export interface CreateWalkInBookingParams {
  serviceId: string
  firstName: string
  phoneNumber?: string
  isPaid: boolean
}
export const useBookingStore = defineStore('booking', () => {
  const currentBooking = ref<Booking | null>(null)
  const pendingBooking = ref<Omit<CreateWalkInBookingParams, 'isPaid'> | null>(null)
  const isLoading = ref(false)
  const error = ref<string | null>(null)
  const setPendingBooking = (booking: Omit<CreateWalkInBookingParams, 'isPaid'>) => {
    pendingBooking.value = booking
  }
  const createWalkInBooking = async (booking: CreateWalkInBookingParams) => {
    isLoading.value = true
    error.value = null
    try {
      const response = await fetch(`${API_URL}/bookings/walk-in`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-Shop-Code': SHOP_CODE,
          accept: '*/*',
        },
        body: JSON.stringify({
          serviceId: booking.serviceId,
          firstName: booking.firstName,
          phoneNumber: booking.phoneNumber,
          isPaid: booking.isPaid,
        }),
      })
      if (!response.ok) {
        const errorData = await response.json().catch(() => null)
        throw new Error(errorData?.message || 'Failed to create booking')
      }
      const data = await response.json()
      currentBooking.value = data
      pendingBooking.value = null
    } catch (err) {
      error.value = err instanceof Error ? err.message : 'Failed to create booking'
      throw error.value
    } finally {
      isLoading.value = false
    }
  }
  const clearBooking = () => {
    currentBooking.value = null
    pendingBooking.value = null
    error.value = null
  }
  return {
    currentBooking,
    pendingBooking,
    isLoading,
    error,
    setPendingBooking,
    createWalkInBooking,
    clearBooking,
  }
})
````

## File: frontend/customer/src/stores/counter.ts
````typescript
import { ref, computed } from 'vue'
import { defineStore } from 'pinia'
export const useCounterStore = defineStore('counter', () => {
  const count = ref(0)
  const doubleCount = computed(() => count.value * 2)
  function increment() {
    count.value++
  }
  return { count, doubleCount, increment }
})
````

## File: frontend/customer/src/stores/display.ts
````typescript
import { defineStore } from 'pinia'
import { ref, computed } from 'vue'
import axios from 'axios'
export interface Employee {
  id: string
  name: string
  color: string
  isActive: boolean
}
export interface WaitingSlot {
  id: string
  customerName?: string
  estimatedTime?: number
  assignedTo?: string
}
interface QueueResponse {
  count: number
  customers: Array<{
    firstName: string
    estimatedWaitingTime: number
  }>
}
export const useDisplayStore = defineStore('display', () => {
  // Keep employees hardcoded as per requirements
  const employees = ref<Employee[]>([
    {
      id: '1',
      name: 'Gladys',
      color: 'bg-sky-400',
      isActive: true,
    },
    {
      id: '2',
      name: 'Veronika',
      color: 'bg-fuchsia-400',
      isActive: true,
    },
  ])
  const waitingSlots = ref<WaitingSlot[]>([])
  const lastUpdate = ref(new Date())
  const isLoading = ref(false)
  const error = ref<string | null>(null)
  const lastFetched = ref<number | null>(null)
  const waitingCount = ref<number | null>(null)
  const CACHE_DURATION = 30000 // 30 seconds
  const shouldRefetch = computed(() => {
    if (!lastFetched.value) return true
    return Date.now() - lastFetched.value > CACHE_DURATION
  })
  const activeEmployees = computed(() => {
    return employees.value.filter((emp) => emp.isActive)
  })
  // Check if any slots are available based on waiting count
  const hasAvailableSlot = computed(() => {
    // If we're loading or don't have a count yet, return null
    if (isLoading.value || waitingCount.value === null) return null
    return waitingCount.value < activeEmployees.value.length
  })
  const updateLastUpdate = () => {
    lastUpdate.value = new Date()
  }
  const generateWaitingSlots = (
    count: number,
    customers: Array<{ firstName: string; estimatedWaitingTime: number }>,
  ) => {
    return customers.map((customer, index) => ({
      id: `slot-${index + 1}`,
      customerName: customer.firstName,
      estimatedTime: customer.estimatedWaitingTime,
      assignedTo: employees.value[index % employees.value.length].id,
    }))
  }
  const fetchWaitingSlots = async (forceRefresh = false) => {
    console.log('Fetching waiting slots...')
    // Return cached data if it's still fresh
    if (!forceRefresh && !shouldRefetch.value && waitingSlots.value.length > 0) {
      console.log('Using cached data')
      return
    }
    try {
      isLoading.value = true
      error.value = null
      console.log('Fetching from API...')
      const response = await axios.get<QueueResponse>(
        'http://localhost:3000/bookings/upcoming/count',
      )
      console.log('API response:', response.data)
      // Update the waiting count
      waitingCount.value = response.data.count
      // Generate slots based on actual customers
      waitingSlots.value = generateWaitingSlots(response.data.count, response.data.customers)
      lastFetched.value = Date.now()
      updateLastUpdate()
      console.log('Updated waiting slots:', waitingSlots.value)
    } catch (err) {
      console.error('Error fetching waiting slots:', err)
      error.value = 'Kunne ikke hente venteliste'
      // Ensure waitingSlots is always an array even on error
      waitingSlots.value = []
      waitingCount.value = null
    } finally {
      isLoading.value = false
    }
  }
  // Start polling for updates
  let pollInterval: number | null = null
  const startPolling = () => {
    console.log('Starting polling...')
    if (pollInterval) {
      console.log('Polling already active')
      return
    }
    // Initial fetch
    fetchWaitingSlots()
    // Then poll every 30 seconds
    pollInterval = window.setInterval(() => {
      console.log('Polling interval triggered')
      fetchWaitingSlots()
    }, CACHE_DURATION)
  }
  const stopPolling = () => {
    console.log('Stopping polling...')
    if (pollInterval) {
      clearInterval(pollInterval)
      pollInterval = null
    }
  }
  // Cleanup function to be called when component unmounts
  const cleanup = () => {
    stopPolling()
  }
  return {
    employees,
    waitingSlots,
    lastUpdate,
    activeEmployees,
    hasAvailableSlot,
    isLoading,
    error,
    waitingCount,
    shouldRefetch,
    fetchWaitingSlots,
    updateLastUpdate,
    startPolling,
    stopPolling,
    cleanup,
  }
})
````

## File: frontend/customer/src/stores/services.ts
````typescript
import { defineStore } from 'pinia'
import { ref } from 'vue'
export interface Service {
  id: string
  name: string
  description: string
  duration: number
  price: string
  isActive: boolean
  createdAt: string
  updatedAt: string
}
export const useServicesStore = defineStore('services', () => {
  // Initialize state
  const services = ref<Service[]>([])
  const isLoading = ref(true)  // Initialize as true
  const error = ref<string | null>(null)
  const selectedService = ref<Service | null>(null)
  const fetchServices = async () => {
    try {
      const response = await fetch('http://localhost:3000/services')
      if (!response.ok) {
        throw new Error('Failed to fetch services')
      }
      services.value = await response.json()
    } catch (err) {
      error.value = err instanceof Error ? err.message : 'Failed to fetch services'
      services.value = []
    } finally {
      isLoading.value = false
    }
  }
  const selectService = (service: Service) => {
    selectedService.value = service
  }
  const clearSelection = () => {
    selectedService.value = null
  }
  // Schedule the initial fetch using setImmediate to match the test's timing
  setImmediate(() => {
    fetchServices()
  })
  return {
    services,
    isLoading,
    error,
    selectedService,
    fetchServices,
    selectService,
    clearSelection,
  }
})
````

## File: frontend/customer/src/stores/types.ts
````typescript
export interface CreateWalkInBookingParams {
  serviceId: string;
  firstName: string;
  phoneNumber: string;
  isPaid: boolean;
}
export interface BookingResponse {
  id: string;
  serviceId: string;
  firstName: string;
  phoneNumber: string;
  status: 'confirmed' | 'pending' | 'cancelled';
  createdAt?: string;
  updatedAt?: string;
}
export interface PendingBooking extends Omit<CreateWalkInBookingParams, 'isPaid'> {
  isPaid?: boolean;
}
export interface BookingState {
  currentBooking: BookingResponse | null;
  pendingBooking: PendingBooking | null;
  isLoading: boolean;
  error: string | null;
}
export interface Service {
  id: string;
  name: string;
  description: string;
  duration: number;
  price: string;
  isActive: boolean;
  createdAt: string;
  updatedAt: string;
}
export interface ServicesState {
  services: Service[];
  selectedService: Service | null;
  isLoading: boolean;
  error: string | null;
}
````

## File: frontend/customer/src/stores/waiting.ts
````typescript
import { defineStore } from 'pinia'
import { ref, computed } from 'vue'
interface QueueStatus {
  peopleWaiting: number
  estimatedWaitTime: number // in minutes
  lastUpdated: string
}
export const useWaitingStore = defineStore('waiting', () => {
  const queueStatus = ref<QueueStatus>({
    peopleWaiting: 0,
    estimatedWaitTime: 0,
    lastUpdated: new Date().toISOString(),
  })
  const isLoading = ref(false)
  const error = ref<string | null>(null)
  const formattedWaitTime = computed(() => {
    const hours = Math.floor(queueStatus.value.estimatedWaitTime / 60)
    const minutes = queueStatus.value.estimatedWaitTime % 60
    if (hours > 0) {
      return `${hours}h ${minutes}min`
    }
    return `${minutes}min`
  })
  const fetchQueueStatus = async () => {
    isLoading.value = true
    error.value = null
    try {
      const response = await fetch('http://localhost:3000/bookings/upcoming/count', {
        headers: {
          accept: '*/*',
        },
      })
      if (!response.ok) {
        throw new Error('Failed to fetch queue status')
      }
      const count = await response.json()
      queueStatus.value = {
        peopleWaiting: count,
        estimatedWaitTime: count * 30, // Rough estimate: 30 minutes per booking
        lastUpdated: new Date().toISOString(),
      }
    } catch (err) {
      error.value = err instanceof Error ? err.message : 'Failed to fetch queue status'
    } finally {
      isLoading.value = false
    }
  }
  // Start polling for queue status
  const startPolling = (intervalMs: number = 60000): ReturnType<typeof setInterval> => {
    fetchQueueStatus()
    return setInterval(fetchQueueStatus, intervalMs)
  }
  return {
    queueStatus,
    isLoading,
    error,
    formattedWaitTime,
    fetchQueueStatus,
    startPolling,
  }
})
````

## File: frontend/customer/src/views/__tests__/TVDisplayView.spec.ts
````typescript
import { describe, it, expect, vi, beforeEach, afterEach } from 'vitest'
import { mount } from '@vue/test-utils'
import { createPinia, setActivePinia } from 'pinia'
import TVDisplayView from '../TVDisplayView.vue'
import { useDisplayStore } from '../../stores/display'
import axios from 'axios'
vi.mock('axios')
vi.mock('../../stores/display', () => ({
  useDisplayStore: vi.fn(),
}))
describe('TVDisplayView', () => {
  const mockEmployees = [
    { id: '1', name: 'Gladys', color: 'bg-sky-400', isActive: true },
    { id: '2', name: 'Veronika', color: 'bg-fuchsia-400', isActive: true },
  ]
  const mockWaitingSlots = [
    {
      id: 'slot-1',
      customerName: 'Vada',
      estimatedTime: 0,
      assignedTo: '1',
    },
    {
      id: 'slot-2',
      customerName: 'Lavinia',
      estimatedTime: 45,
      assignedTo: '2',
    },
  ]
  const createMockStore = (overrides = {}) => ({
    hasAvailableSlot: false,
    activeEmployees: mockEmployees,
    waitingSlots: mockWaitingSlots,
    lastUpdate: new Date('2024-01-01T12:00:00'),
    updateLastUpdate: vi.fn(),
    employees: mockEmployees,
    startPolling: vi.fn(),
    stopPolling: vi.fn(),
    cleanup: vi.fn(),
    isLoading: false,
    error: null,
    waitingCount: 2,
    fetchWaitingSlots: vi.fn(),
    ...overrides,
  })
  beforeEach(() => {
    setActivePinia(createPinia())
    vi.useFakeTimers()
    vi.setSystemTime(new Date('2024-01-01T12:00:00'))
    // Mock store with default values
    vi.mocked(useDisplayStore).mockReturnValue(createMockStore())
  })
  afterEach(() => {
    vi.useRealTimers()
    vi.clearAllMocks()
  })
  it('displays correct status when slots are available', () => {
    vi.mocked(useDisplayStore).mockReturnValue(createMockStore({
      hasAvailableSlot: true,
    }))
    const wrapper = mount(TVDisplayView)
    expect(wrapper.find('h1').text()).toBe('Ledig')
    expect(wrapper.find('h1').classes()).toContain('text-[#c2ff00]')
  })
  it('displays correct status when no slots are available', () => {
    vi.mocked(useDisplayStore).mockReturnValue(createMockStore({
      hasAvailableSlot: false,
    }))
    const wrapper = mount(TVDisplayView)
    expect(wrapper.find('h1').text()).toBe('Opptatt')
    expect(wrapper.find('h1').classes()).toContain('text-red-500')
  })
  it('renders waiting list correctly', () => {
    const wrapper = mount(TVDisplayView)
    const waitingSlots = wrapper.findAll('.space-y-16 > div')
    expect(waitingSlots).toHaveLength(mockWaitingSlots.length)
    // Check first slot (Vada)
    const firstSlot = waitingSlots[0]
    expect(firstSlot.text()).toContain('Vada')
    expect(firstSlot.text()).toContain('0 min')
    expect(firstSlot.find('.w-8.h-8').classes()).toContain('bg-sky-400')
    // Check second slot (Lavinia)
    const secondSlot = waitingSlots[1]
    expect(secondSlot.text()).toContain('Lavinia')
    expect(secondSlot.text()).toContain('45 min')
    expect(secondSlot.find('.w-8.h-8').classes()).toContain('bg-fuchsia-400')
  })
  it('displays active employees correctly', () => {
    const wrapper = mount(TVDisplayView)
    const employeeElements = wrapper.findAll('[data-testid="employee"]')
    expect(employeeElements).toHaveLength(mockEmployees.length)
    expect(wrapper.text()).toContain('2 frisører på jobb')
    mockEmployees.forEach((employee, index) => {
      const element = employeeElements[index]
      expect(element.text()).toContain(employee.name)
      expect(element.find(`.${employee.color}`).exists()).toBe(true)
    })
  })
  it('formats last update time correctly', () => {
    const wrapper = mount(TVDisplayView)
    expect(wrapper.text()).toContain('12:00:00')
  })
  it('starts polling on mount and cleans up on unmount', () => {
    const mockStartPolling = vi.fn()
    const mockCleanup = vi.fn()
    vi.mocked(useDisplayStore).mockReturnValue(createMockStore({
      startPolling: mockStartPolling,
      cleanup: mockCleanup,
    }))
    const wrapper = mount(TVDisplayView)
    expect(mockStartPolling).toHaveBeenCalled()
    wrapper.unmount()
    expect(mockCleanup).toHaveBeenCalled()
  })
})
````

## File: frontend/customer/src/views/TVDisplayView.vue
````vue
<template>
  <div class="fixed inset-0 bg-[#0a0a0f] text-white overflow-hidden">
    <div class="h-full flex flex-col items-center">
      <!-- Status Text -->
      <div class="text-center mt-12 mb-4">
        <div
          v-if="store.isLoading && store.hasAvailableSlot === null"
          class="text-8xl font-bold text-gray-400"
        >
          <svg
            class="animate-spin h-24 w-24 mx-auto mb-8"
            xmlns="http://www.w3.org/2000/svg"
            fill="none"
            viewBox="0 0 24 24"
          >
            <circle
              class="opacity-25"
              cx="12"
              cy="12"
              r="10"
              stroke="currentColor"
              stroke-width="4"
            ></circle>
            <path
              class="opacity-75"
              fill="currentColor"
              d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
            ></path>
          </svg>
          Laster...
        </div>
        <h1
          v-else
          class="text-8xl font-bold"
          :class="store.hasAvailableSlot ? 'text-[#c2ff00]' : 'text-red-500'"
        >
          {{ store.hasAvailableSlot ? 'Ledig' : 'Opptatt' }}
        </h1>
        <h2 class="text-3xl text-white mt-10">Venteliste</h2>
      </div>
      <!-- Waiting List -->
      <div class="w-full max-w-6xl px-16 mt-12 py-8">
        <div v-if="store.isLoading && !store.waitingSlots.length" class="text-center text-gray-400">
          <svg
            class="animate-spin h-12 w-12 mx-auto mb-4"
            xmlns="http://www.w3.org/2000/svg"
            fill="none"
            viewBox="0 0 24 24"
          >
            <circle
              class="opacity-25"
              cx="12"
              cy="12"
              r="10"
              stroke="currentColor"
              stroke-width="4"
            ></circle>
            <path
              class="opacity-75"
              fill="currentColor"
              d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"
            ></path>
          </svg>
          Laster...
        </div>
        <div v-else-if="store.error" class="text-center text-red-500">
          {{ store.error }}
        </div>
        <div v-else class="space-y-16">
          <div v-for="slot in store.waitingSlots" :key="slot.id" class="flex items-center">
            <div
              class="w-8 h-8 rounded-full mr-8 flex-shrink-0 border-2"
              :class="[
                slot.assignedTo
                  ? `${store.employees.find((e) => e.id === slot.assignedTo)?.color} border-white/20`
                  : 'bg-[#c2ff00] border-[#c2ff00]',
              ]"
            ></div>
            <div
              class="h-[1px] w-full relative"
              :class="slot.assignedTo ? 'bg-white/20' : 'bg-[#c2ff00]'"
            >
              <div v-if="slot.customerName" class="absolute -top-4 left-0 bg-[#0a0a0f] pr-6">
                <span class="text-xl font-medium">{{ slot.customerName }}</span>
                <span v-if="slot.estimatedTime !== undefined" class="text-gray-400 ml-4 text-lg">
                  {{ slot.estimatedTime }} min
                </span>
              </div>
            </div>
          </div>
        </div>
      </div>
      <!-- Active Employees -->
      <div class="w-full bg-gradient-to-t from-[#0a0a0f] via-[#0a0a0f] to-transparent pt-8 pb-8">
        <div class="max-w-6xl mx-auto px-16">
          <div class="flex items-center justify-between mb-6">
            <div class="flex items-center gap-8">
              <div class="flex items-center gap-3">
                <div
                  v-if="store.hasAvailableSlot !== null"
                  class="w-2.5 h-2.5 rounded-full"
                  :class="store.hasAvailableSlot ? 'bg-[#c2ff00]' : 'bg-red-500'"
                ></div>
                <span class="text-lg">{{ store.activeEmployees.length }} frisører på jobb</span>
              </div>
              <div class="flex gap-3">
                <div
                  v-for="employee in store.activeEmployees"
                  :key="employee.id"
                  class="flex items-center bg-[#1a1a1f] rounded-full px-4 py-2"
                  data-testid="employee"
                >
                  <div class="relative">
                    <div :class="employee.color" class="w-6 h-6 rounded-full"></div>
                    <div
                      class="absolute -top-1 -right-1 w-2.5 h-2.5 bg-[#c2ff00] rounded-full border-2 border-[#0a0a0f]"
                    ></div>
                  </div>
                  <span class="text-sm ml-3 font-medium">{{ employee.name }}</span>
                </div>
              </div>
            </div>
          </div>
          <!-- Metadata -->
          <div class="text-xs text-gray-500 space-y-0.5">
            <div>Side 1/1</div>
            <div>Sist oppdatert: {{ formatLastUpdate() }}</div>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>
<script setup lang="ts">
import { useDisplayStore } from '../stores/display'
import { onMounted, onUnmounted } from 'vue'
console.log('TVDisplayView script setup start')
const store = useDisplayStore()
const formatLastUpdate = () => {
  return store.lastUpdate.toLocaleTimeString('nb-NO', {
    hour: '2-digit',
    minute: '2-digit',
    second: '2-digit',
  })
}
// Start polling when component mounts
onMounted(() => {
  console.log('TVDisplayView mounted, starting polling')
  store.startPolling()
})
// Clean up when component unmounts
onUnmounted(() => {
  console.log('TVDisplayView unmounted, cleaning up')
  store.cleanup()
})
</script>
<style scoped>
/* Scoped styles only for TV display */
:deep(body) {
  background: transparent;
}
</style>
````

## File: frontend/customer/src/App.vue
````vue
<template>
  <header v-if="!isTVDisplay" class="border-b">
    <div class="max-w-4xl mx-auto px-4 py-4 flex items-center gap-8">
      <router-link to="/" class="text-2xl text-primary-600 font-bold flex-1"
        >Frisørsalong</router-link
      >
      <router-link to="/tv-display" class="text-2xl text-primary-600 font-bold flex-1"
        >TV Visning</router-link
      >
      <div class="flex-1 flex justify-end">
        <div class="w-[250px]">
          <WaitingTimeDisplay />
        </div>
      </div>
    </div>
  </header>
  <router-view />
</template>
<script setup lang="ts">
import { computed } from 'vue'
import { useRoute } from 'vue-router'
import WaitingTimeDisplay from './components/WaitingTimeDisplay.vue'
const route = useRoute()
const isTVDisplay = computed(() => route.name === 'tv-display')
</script>
````

## File: frontend/customer/src/main.ts
````typescript
import './assets/main.css'
import { createApp } from 'vue'
import { createPinia } from 'pinia'
import App from './App.vue'
import router from './router'
// Create the app instance
const app = createApp(App)
// Use plugins
app.use(createPinia())
app.use(router)
// Mount the app
app.mount('#app')
````

## File: frontend/customer/.editorconfig
````
[*.{js,jsx,mjs,cjs,ts,tsx,mts,cts,vue}]
charset = utf-8
indent_size = 2
indent_style = space
insert_final_newline = true
trim_trailing_whitespace = true
````

## File: frontend/customer/.gitignore
````
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
pnpm-debug.log*
lerna-debug.log*

node_modules
.DS_Store
dist
dist-ssr
coverage
*.local

/cypress/videos/
/cypress/screenshots/

# Editor directories and files
.vscode/*
!.vscode/extensions.json
.idea
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

*.tsbuildinfo
````

## File: frontend/customer/.prettierrc.json
````json
{
  "$schema": "https://json.schemastore.org/prettierrc",
  "semi": false,
  "singleQuote": true,
  "printWidth": 100
}
````

## File: frontend/customer/cypress.config.ts
````typescript
import { defineConfig } from 'cypress'
export default defineConfig({
  e2e: {
    specPattern: 'cypress/e2e/**/*.{cy,spec}.{js,jsx,ts,tsx}',
    baseUrl: 'http://localhost:4173',
  },
})
````

## File: frontend/customer/env.d.ts
````typescript
/// <reference types="vite/client" />
````

## File: frontend/customer/eslint.config.js
````javascript
import pluginVue from 'eslint-plugin-vue'
import vueTsEslintConfig from '@vue/eslint-config-typescript'
import pluginVitest from '@vitest/eslint-plugin'
import pluginCypress from 'eslint-plugin-cypress/flat'
import skipFormatting from '@vue/eslint-config-prettier/skip-formatting'
export default [
  {
    name: 'app/files-to-lint',
    files: ['**/*.{ts,mts,tsx,vue}'],
  },
  {
    name: 'app/files-to-ignore',
    ignores: ['**/dist/**', '**/dist-ssr/**', '**/coverage/**'],
  },
  ...pluginVue.configs['flat/essential'],
  ...vueTsEslintConfig(),
  {
    ...pluginVitest.configs.recommended,
    files: ['src/**/__tests__/*'],
  },
  {
    ...pluginCypress.configs.recommended,
    files: [
      'cypress/e2e/**/*.{cy,spec}.{js,ts,jsx,tsx}',
      'cypress/support/**/*.{js,ts,jsx,tsx}'
    ],
  },
  skipFormatting,
]
````

## File: frontend/customer/index.html
````html
<!DOCTYPE html>
<html lang="">
  <head>
    <meta charset="UTF-8">
    <link rel="icon" href="/favicon.ico">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Frisørsalong</title>
  </head>
  <body>
    <div id="app"></div>
    <script type="module" src="/src/main.ts"></script>
  </body>
</html>
````

## File: frontend/customer/postcss.config.js
````javascript
export default {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}
````

## File: frontend/customer/README.md
````markdown
# customer

This template should help get you started developing with Vue 3 in Vite.

## Recommended IDE Setup

[VSCode](https://code.visualstudio.com/) + [Volar](https://marketplace.visualstudio.com/items?itemName=Vue.volar) (and disable Vetur).

## Type Support for `.vue` Imports in TS

TypeScript cannot handle type information for `.vue` imports by default, so we replace the `tsc` CLI with `vue-tsc` for type checking. In editors, we need [Volar](https://marketplace.visualstudio.com/items?itemName=Vue.volar) to make the TypeScript language service aware of `.vue` types.

## Customize configuration

See [Vite Configuration Reference](https://vite.dev/config/).

## Project Setup

```sh
pnpm install
```

### Compile and Hot-Reload for Development

```sh
pnpm dev
```

### Type-Check, Compile and Minify for Production

```sh
pnpm build
```

### Run Unit Tests with [Vitest](https://vitest.dev/)

```sh
pnpm test:unit
```

### Run End-to-End Tests with [Cypress](https://www.cypress.io/)

```sh
pnpm test:e2e:dev
```

This runs the end-to-end tests against the Vite development server.
It is much faster than the production build.

But it's still recommended to test the production build with `test:e2e` before deploying (e.g. in CI environments):

```sh
pnpm build
pnpm test:e2e
```

### Lint with [ESLint](https://eslint.org/)

```sh
pnpm lint
```
````

## File: frontend/customer/tailwind.config.js
````javascript
/** @type {import('tailwindcss').Config} */
export default {
  content: ['./index.html', './src/**/*.{vue,js,ts,jsx,tsx}'],
  theme: {
    extend: {
      colors: {
        primary: {
          50: '#f0f9ff',
          100: '#e0f2fe',
          200: '#bae6fd',
          300: '#7dd3fc',
          400: '#38bdf8',
          500: '#0ea5e9',
          600: '#0284c7',
          700: '#0369a1',
          800: '#075985',
          900: '#0c4a6e',
        },
        secondary: {
          50: '#f8fafc',
          100: '#f1f5f9',
          200: '#e2e8f0',
          300: '#cbd5e1',
          400: '#94a3b8',
          500: '#64748b',
          600: '#475569',
          700: '#334155',
          800: '#1e293b',
          900: '#0f172a',
        },
      },
    },
  },
  plugins: [],
}
````

## File: frontend/customer/tsconfig.app.json
````json
{
  "extends": "@vue/tsconfig/tsconfig.dom.json",
  "include": ["env.d.ts", "src/**/*", "src/**/*.vue"],
  "exclude": ["src/**/__tests__/*"],
  "compilerOptions": {
    "composite": true,
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.app.tsbuildinfo",

    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  }
}
````

## File: frontend/customer/tsconfig.json
````json
{
  "files": [],
  "references": [
    {
      "path": "./tsconfig.node.json"
    },
    {
      "path": "./tsconfig.app.json"
    },
    {
      "path": "./tsconfig.vitest.json"
    }
  ],
  "compilerOptions": {
    "target": "esnext",
    "module": "esnext",
    "moduleResolution": "node",
    "strict": true,
    "jsx": "preserve",
    "sourceMap": true,
    "resolveJsonModule": true,
    "esModuleInterop": true,
    "lib": ["esnext", "dom"],
    "baseUrl": ".",
    "paths": {
      "@/*": ["./src/*"]
    }
  },
  "include": ["src/**/*.ts", "src/**/*.d.ts", "src/**/*.tsx", "src/**/*.vue"],
  "exclude": ["node_modules"]
}
````

## File: frontend/customer/tsconfig.node.json
````json
{
  "extends": "@tsconfig/node22/tsconfig.json",
  "include": [
    "vite.config.*",
    "vitest.config.*",
    "cypress.config.*",
    "nightwatch.conf.*",
    "playwright.config.*"
  ],
  "compilerOptions": {
    "composite": true,
    "noEmit": true,
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.node.tsbuildinfo",

    "module": "ESNext",
    "moduleResolution": "Bundler",
    "types": ["node"]
  }
}
````

## File: frontend/customer/tsconfig.vitest.json
````json
{
  "extends": "./tsconfig.app.json",
  "exclude": [],
  "compilerOptions": {
    "composite": true,
    "tsBuildInfoFile": "./node_modules/.tmp/tsconfig.vitest.tsbuildinfo",

    "lib": [],
    "types": ["node", "jsdom"]
  }
}
````

## File: frontend/customer/vite.config.ts
````typescript
import { fileURLToPath, URL } from 'node:url'
import { defineConfig } from 'vite'
import vue from '@vitejs/plugin-vue'
// https://vitejs.dev/config/
export default defineConfig({
  plugins: [vue()],
  resolve: {
    alias: {
      '@': fileURLToPath(new URL('./src', import.meta.url)),
    },
  },
})
````

## File: frontend/customer/vitest.config.ts
````typescript
import { fileURLToPath } from 'node:url'
import { mergeConfig, defineConfig, configDefaults } from 'vitest/config'
import viteConfig from './vite.config'
export default mergeConfig(
  viteConfig,
  defineConfig({
    test: {
      environment: 'jsdom',
      exclude: [...configDefaults.exclude, 'e2e/**'],
      root: fileURLToPath(new URL('./', import.meta.url)),
      coverage: {
        exclude: [
          // Config files
          '**/*.config.js',
          '**/*.config.ts',
          // Entry points
          'src/main.ts',
          // Test files
          '**/*.{test,spec}.{js,ts,jsx,tsx}',
          // Test directories
          '**/tests/**',
          '**/__tests__/**',
          // Cypress files
          'cypress/**',
          // Other files not needing coverage
          'env.d.ts',
          'src/assets/**',
          // Router (since it's just configuration)
          'src/router/**',
        ],
        include: ['src/components/**', 'src/stores/**', 'src/views/**'],
      },
    },
  }),
)
````

## File: .gitattributes
````
# Auto detect text files and perform LF normalization
* text=auto
````

## File: .gitignore
````
# Logs
logs
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*
lerna-debug.log*
.pnpm-debug.log*

# Diagnostic reports (https://nodejs.org/api/report.html)
report.[0-9]*.[0-9]*.[0-9]*.[0-9]*.json

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Directory for instrumented libs generated by jscoverage/JSCover
lib-cov

# Coverage directory used by tools like istanbul
coverage
*.lcov

# nyc test coverage
.nyc_output

# Grunt intermediate storage (https://gruntjs.com/creating-plugins#storing-task-files)
.grunt

# Bower dependency directory (https://bower.io/)
bower_components

# node-waf configuration
.lock-wscript

# Compiled binary addons (https://nodejs.org/api/addons.html)
build/Release

# Dependency directories
node_modules/
jspm_packages/

# Snowpack dependency directory (https://snowpack.dev/)
web_modules/

# TypeScript cache
*.tsbuildinfo

# Optional npm cache directory
.npm

# Optional eslint cache
.eslintcache

# Optional stylelint cache
.stylelintcache

# Microbundle cache
.rpt2_cache/
.rts2_cache_cjs/
.rts2_cache_es/
.rts2_cache_umd/

# Optional REPL history
.node_repl_history

# Output of 'npm pack'
*.tgz

# Yarn Integrity file
.yarn-integrity

# dotenv environment variable files
.env
.env.development.local
.env.test.local
.env.production.local
.env.local

# parcel-bundler cache (https://parceljs.org/)
.cache
.parcel-cache

# Next.js build output
.next
out

# Nuxt.js build / generate output
.nuxt
dist

# Gatsby files
.cache/
# Comment in the public line in if your project uses Gatsby and not Next.js
# https://nextjs.org/blog/next-9-1#public-directory-support
# public

# vuepress build output
.vuepress/dist

# vuepress v2.x temp and cache directory
.temp
.cache

# Docusaurus cache and generated files
.docusaurus

# Serverless directories
.serverless/

# FuseBox cache
.fusebox/

# DynamoDB Local files
.dynamodb/

# TernJS port file
.tern-port

# Stores VSCode versions used for testing VSCode extensions
.vscode-test

# yarn v2
.yarn/cache
.yarn/unplugged
.yarn/build-state.yml
.yarn/install-state.gz
.pnp.*
````

## File: codacy-fixes.txt
````
diff --git a/frontend/customer/docs/README.md b/frontend/customer/docs/README.md
--- a/frontend/customer/docs/README.md
+++ b/frontend/customer/docs/README.md
@@ -18,1 +18,1 @@
-### Backend
+### Backend

@@ -19,1 +19,1 @@
-- NestJS (TypeScript)
+
- NestJS (TypeScript)
@@ -25,1 +25,1 @@
-### Frontend
+### Frontend

@@ -26,1 +26,1 @@
-- Vue 3
+
- Vue 3
@@ -205,1 +205,1 @@
-1. Check the existing documentation
+
1. Check the existing documentation
diff --git a/backend/docs/README.md b/backend/docs/README.md
--- a/backend/docs/README.md
+++ b/backend/docs/README.md
@@ -18,1 +18,1 @@
-### Backend
+### Backend

@@ -19,1 +19,1 @@
-- NestJS (TypeScript)
+
- NestJS (TypeScript)
@@ -25,1 +25,1 @@
-### Frontend
+### Frontend

@@ -26,1 +26,1 @@
-- Vue 3
+
- Vue 3
@@ -205,1 +205,1 @@
-1. Check the existing documentation
+
1. Check the existing documentation
diff --git a/backend/src/database/seeds/update-admin-password.seed.spec.ts b/backend/src/database/seeds/update-admin-password.seed.spec.ts
--- a/backend/src/database/seeds/update-admin-password.seed.spec.ts
+++ b/backend/src/database/seeds/update-admin-password.seed.spec.ts
@@ -29,1 +29,1 @@
-      findOne: jest.fn() as jest.Mock,
+      findOne: jest.fn(),
diff --git a/docs/README.md b/docs/README.md
--- a/docs/README.md
+++ b/docs/README.md
@@ -18,1 +18,1 @@
-### Backend
+### Backend

@@ -19,1 +19,1 @@
-- NestJS (TypeScript)
+
- NestJS (TypeScript)
@@ -25,1 +25,1 @@
-### Frontend
+### Frontend

@@ -26,1 +26,1 @@
-- Vue 3
+
- Vue 3
@@ -205,1 +205,1 @@
-1. Check the existing documentation
+
1. Check the existing documentation
diff --git a/frontend/admin/docs/README.md b/frontend/admin/docs/README.md
--- a/frontend/admin/docs/README.md
+++ b/frontend/admin/docs/README.md
@@ -18,1 +18,1 @@
-### Backend
+### Backend

@@ -19,1 +19,1 @@
-- NestJS (TypeScript)
+
- NestJS (TypeScript)
@@ -25,1 +25,1 @@
-### Frontend
+### Frontend

@@ -26,1 +26,1 @@
-- Vue 3
+
- Vue 3
@@ -205,1 +205,1 @@
-1. Check the existing documentation
+
1. Check the existing documentation
diff --git a/backend/README.md b/backend/README.md
--- a/backend/README.md
+++ b/backend/README.md
@@ -34,1 +34,1 @@
-1. Install dependencies:
+1. Install dependencies:

@@ -45,1 +45,1 @@
-1. Run migrations:
+1. Run migrations:

@@ -50,1 +50,1 @@
-2. Seed initial data:
+2. Seed initial data:

diff --git a/frontend/admin/README.md b/frontend/admin/README.md
--- a/frontend/admin/README.md
+++ b/frontend/admin/README.md
@@ -30,1 +30,1 @@
-1. Install dependencies:
+1. Install dependencies:
````

## File: codecov.yml
````yaml
coverage:
  precision: 2
  round: down
  range: "70...100"
  status:
    project:
      backend:
        target: 75%
        threshold: 1%
        paths:
          - "backend/src"
      frontend-customer:
        target: 75%
        threshold: 1%
        paths:
          - "frontend/customer/src"
    patch:
      backend:
        target: 75%
        paths:
          - "backend/src"
      frontend-customer:
        target: 75%
        paths:
          - "frontend/customer/src"
flags:
  backend:
    paths:
      - backend/src
    carryforward: true
  frontend-customer:
    paths:
      - frontend/customer/src
    carryforward: true
ignore:
  - "frontend/admin/**/*"
  - "backend/node_modules/**/*"
  - "backend/dist/**/*"
  - "backend/test/**/*"
  - "backend/coverage/**/*"
  - "backend/**/*.spec.ts"
  - "backend/**/*.test.ts"
  - "backend/src/config/**/*"
  - "frontend/customer/node_modules/**/*"
  - "frontend/customer/dist/**/*"
  - "frontend/customer/coverage/**/*"
comment:
  layout: "reach, diff, flags, files"
  behavior: default
  require_changes: false
  require_base: false
  require_head: true
````

## File: CRITICAL.md
````markdown
All critical issues have been resolved:

1. Fixed deep nesting in CreateBookingSystem.spec.ts
2. Fixed deep nesting in shop-code.guard.spec.ts
3. Fixed deep nesting in services.spec.ts
4. Verified booking.spec.ts has proper structure

No remaining critical issues.
````

## File: Dockerfile
````dockerfile
# Multi-stage Dockerfile for building and running both backend and frontend

# Stage 1: Build backend
FROM node:22 AS backend-builder
WORKDIR /app/backend
COPY backend/package.json backend/pnpm-lock.yaml ./
RUN npm install -g pnpm && pnpm install
COPY backend .
RUN pnpm build

# Stage 2: Build frontend
FROM node:22 AS frontend-builder
WORKDIR /app/frontend
COPY frontend/admin/package.json frontend/admin/pnpm-lock.yaml ./
RUN npm install -g pnpm && pnpm install
COPY frontend/admin .
RUN pnpm build

# Stage 3: Run backend and frontend
FROM node:22
WORKDIR /app

# Copy backend build
COPY --from=backend-builder /app/backend/dist ./backend/dist
COPY --from=backend-builder /app/backend/node_modules ./backend/node_modules
COPY --from=backend-builder /app/backend/package.json ./backend/package.json

# Copy frontend build
COPY --from=frontend-builder /app/frontend/dist ./frontend/dist
COPY --from=frontend-builder /app/frontend/node_modules ./frontend/node_modules
COPY --from=frontend-builder /app/frontend/package.json ./frontend/package.json

# Install serve to serve the frontend
RUN npm install -g serve

# Set environment variables
ENV NODE_ENV=production
ENV PORT=3000

# Expose ports
EXPOSE 3000
EXPOSE 5173

# Start both backend and frontend
CMD ["sh", "-c", "node backend/dist/main.js & serve -s frontend/dist -l 5173"]
````

## File: ISSUES.md
````markdown
CRITICAL

Error prone

Unsafe call of an `error` type typed value.
backend/src/

app.module.spec.ts

206    const config = factoryFn(mockConfigService);

CRITICAL

Error prone

Unsafe argument of type `any` assigned to a parameter of type `string | RegExp | Constructable | Error | undefined`.
backend/src/auth/strategies/

jwt.strategy.spec.ts

108        .toThrow(new UnauthorizedException('User not found'));

CRITICAL

Error prone

Unsafe call of an `error` type typed value.
backend/src/auth/strategies/

jwt.strategy.ts

25@Injectable()

CRITICAL

Error prone

Unsafe member access .query on an `error` typed value.
backend/src/database/migrations/

1731981975582-CreateBookingSystem.ts

96    await queryRunner.query(`DROP TABLE "employees"`);

CRITICAL

Error prone

Unsafe assignment of type `Mock<any, any, any>` to a variable of type `Mock<Promise<void>, [string], any>`.
backend/src/database/migrations/

1731981975583-CreateOrders.spec.ts

32      dropTable: jest.fn().mockResolvedValue(undefined),

CRITICAL

Error prone

Unsafe assignment of type `Mock<any, any, any>` to a variable of type `Mock<Promise<Table>, [string], any>`.
backend/src/database/migrations/

1731981975583-CreateOrders.spec.ts

21      getTable: jest.fn().mockResolvedValue(new Table({

CRITICAL

Error prone

Unsafe construction of an any type value.
backend/src/database/migrations/

1731981975584-AddShopCodes.spec.ts

16    dataSource = new DataSource({

CRITICAL

Error prone

Unsafe call of an `error` type typed value.
backend/src/database/seeds/

create-initial-data.seed.ts

22  const employeeRepository = dataSource.getRepository(Employee);

CRITICAL

Error prone

Unsafe assignment of an error typed value.
backend/src/database/seeds/

create-initial-data.seed.ts

75      const employeeUser = await userRepository.save({

CRITICAL

Error prone

Unsafe member access .execute on an `error` typed value.
backend/src/database/seeds/

create-initial-data.seed.ts

115        .execute();

CRITICAL

Error prone

Unsafe member access .find on an `any` value.
backend/src/database/seeds/

create-sample-bookings.seed.spec.ts

230    const cancelledBooking = savedBookings.find((b: Booking) => b.status === BookingStatus.CANCELLED);

CRITICAL

Error prone

Unsafe assignment of an `any` value.
backend/src/database/seeds/

create-sample-bookings.seed.spec.ts

160    const savedBookings = (mockBookingRepository.save as jest.Mock).mock.calls[0][0];

CRITICAL

Error prone

Unsafe call of an `any` typed value.
backend/src/database/seeds/

create-sample-bookings.seed.spec.ts

230    const cancelledBooking = savedBookings.find((b: Booking) => b.status === BookingStatus.CANCELLED);

CRITICAL

Error prone

Unsafe assignment of an error typed value.
backend/src/database/seeds/

create-sample-bookings.seed.spec.ts

77        'User': mockUserRepository as Repository<User>,

CRITICAL

Error prone

Unsafe call of an `error` type typed value.
backend/src/database/seeds/

create-sample-bookings.seed.ts

49      const customer = await userRepository.save({

CRITICAL

Error prone

Unsafe call of an `error` type typed value.
backend/src/database/seeds/

create-sample-bookings.seed.ts

19  const bookingRepository: Repository<Booking> = dataSource.getRepository(Booking);

CRITICAL

Error prone

Unsafe member access .save on an `error` typed value.
backend/src/database/seeds/

create-sample-orders.seed.ts

53      const savedOrder = await orderRepository.save(order);

CRITICAL

Error prone

Unsafe member access .find on an `error` typed value.
backend/src/database/seeds/

create-sample-orders.seed.ts

14    const confirmedBookings = await bookingRepository.find({

CRITICAL

Error prone

Unsafe member access .length on an `error` typed value.
backend/src/employees/dto/

create-employee.dto.spec.ts

17    expect(errors.length).toBe(0);

CRITICAL

Error prone

Avoid referencing unbound methods which may cause unintentional scoping of `this`. If your function does not access `this`, you can annotate it with `this: void`, or consider using an arrow function instead.
backend/src/employees/

employees.controller.spec.ts

180      expect(service.findByUserId).toHaveBeenCalledWith(employeeUser.id);

CRITICAL

Error prone

Unsafe member access .get on an `error` typed value.
backend/src/employees/

employees.controller.spec.ts

81    controller = module.get<EmployeesController>(EmployeesController);

CRITICAL

Error prone

Unsafe return of an error typed value.
backend/src/employees/

employees.controller.spec.ts

30      return bcrypt.compare(password, this.password);

CRITICAL

Error prone

Unsafe assignment of an error typed value.
backend/src/employees/

employees.controller.spec.ts

25        const salt = await bcrypt.genSalt();

CRITICAL

Error prone

Unsafe call of an `error` type typed value.
backend/src/employees/

employees.controller.ts

51  @Post(':id/reset-password')
````

## File: LICENSE
````
MIT License

Copyright (c) 2024 w3bdesign

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
````

## File: README.md
````markdown
[![Quality Gate Status](https://sonarcloud.io/api/project_badges/measure?project=w3bdesign_frisorsalong-booking&metric=alert_status)](https://sonarcloud.io/summary/new_code?id=w3bdesign_frisorsalong-booking)
[![Codacy Badge](https://app.codacy.com/project/badge/Grade/8a8b1bc2c732403caab609840e3bc6ec)](https://app.codacy.com/gh/w3bdesign/frisorsalong-booking/dashboard?utm_source=gh&utm_medium=referral&utm_content=&utm_campaign=Badge_grade)

# Hair Salon Booking System

A full-stack booking system for hair salons built with NestJS (backend) and Vue 3 (frontend). The system provides comprehensive functionality for managing appointments, employees, services, and user authentication.

## Test Coverage

| Backend                                                                                                                                                                         | Frontend                                                                                                                                                                                   |
| ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| [![Backend Coverage](https://codecov.io/gh/w3bdesign/frisorsalong-booking/graph/badge.svg?token=YDY1N2NMWA&flag=backend)](https://codecov.io/gh/w3bdesign/frisorsalong-booking) | [![Frontend Coverage](https://codecov.io/gh/w3bdesign/frisorsalong-booking/graph/badge.svg?token=YDY1N2NMWA&flag=frontend-customer)](https://codecov.io/gh/w3bdesign/frisorsalong-booking) |

## Frontend

![Admin Panel](screenshot/admin.png)

## Backend

![API Documentation](screenshot/swagger.png)

---

## Features

- 🔐 Secure JWT-based Authentication & Authorization
- 👥 Role-based User Management (Admin, Employee, Customer)
- 📅 Advanced Booking System
  - ⏰ Smart scheduling with service duration-based time slots
  - 🕒 Automatic end time calculation based on service duration
  - ✅ Real-time employee availability checking
  - 📊 Booking status tracking (Pending, Confirmed, Cancelled)
  - ❌ Booking cancellation with reason tracking
  - 📈 Upcoming bookings dashboard
- 💇‍♀️ Service Management
  - ⏱️ Service duration and pricing
  - 🔄 Employee-service relationship mapping
  - 📋 Service availability per employee
- 👨‍💼 Employee Management & Scheduling
  - 📆 Advanced availability tracking
  - 🎯 Service specialization assignment
  - 📊 Workload management
- 🗄️ PostgreSQL Database with TypeORM
- 📚 Swagger API Documentation
- 🎨 Modern Admin Dashboard with Vue 3
- 📱 Responsive Design with Tailwind CSS
- 🧪 Comprehensive Test Coverage
  - ✅ Unit tests with Jest and Vitest
  - 📊 Continuous coverage reporting

## System Architecture

The system follows a modular architecture separating frontend, backend, and database layers:

### Backend (NestJS)

- **Framework**: NestJS with TypeScript
- **Database**: PostgreSQL with TypeORM
- **Authentication**: JWT with Passport
- **API Documentation**: Swagger/OpenAPI
- **Testing**: Jest

### Frontend (Vue 3)

- **Framework**: Vue 3 with TypeScript
- **State Management**: Pinia
- **Routing**: Vue Router
- **Styling**: Tailwind CSS
- **Testing**: Vitest

## Project Structure

```
├── backend/               # NestJS backend application
│   ├── src/
│   │   ├── auth/         # Authentication & authorization
│   │   ├── bookings/     # Booking management
│   │   ├── config/       # Configuration modules
│   │   ├── database/     # Migrations & seeds
│   │   ├── employees/    # Employee management
│   │   ├── services/     # Service management
│   │   └── users/        # User management
│   └── test/             # E2E tests
├── frontend/
│   ├── admin/            # Admin dashboard (Vue 3)
│   └── customer/         # Customer portal (Vue 3)
└── docs/                 # Project documentation
```

## Prerequisites

- Node.js (v20 or higher)
- pnpm
- PostgreSQL
- Docker

## Getting Started

### Backend Setup

1. Navigate to the backend directory:

```bash
cd backend
```

2. Install dependencies:

```bash
pnpm install
```

3. Configure environment variables:

```bash
cp .env.example .env
# Update the values in .env according to your setup
```

4. Run database migrations:

```bash
pnpm migration:run
```

5. Seed initial data:

```bash
pnpm seed
```

6. Start the development server:

```bash
pnpm start:dev
```

The API will be available at `http://localhost:3000` with Swagger documentation at `http://localhost:3000/api`

### Frontend Setup

1. Navigate to the admin frontend directory:

```bash
cd frontend/admin
```

2. Install dependencies:

```bash
pnpm install
```

3. Start the development server:

```bash
pnpm dev
```

The admin dashboard will be available at `http://localhost:5173`

### Using Docker

1. Build and run the Docker containers:

```bash
docker-compose up --build
```

2. Access the services:

- Backend API: `http://localhost:3000`
- Admin Dashboard: `http://localhost:3001`

## Development Guidelines

### Code Style

- Follow the conventions defined in [docs/CONVENTIONS.md](docs/CONVENTIONS.md)
- Use ESLint and Prettier for code formatting
- Write tests for all new features
- Follow TDD principles

### Git Workflow

1. Create a feature branch from `develop`:

```bash
git checkout -b feature/your-feature-name
```

2. Make your changes following the conventions

3. Write tests for your changes

4. Commit using conventional commits:

```
feat: add new feature
fix: resolve bug
docs: update documentation
style: formatting changes
refactor: code restructuring
test: add tests
chore: maintenance
```

5. Create a pull request to `develop`

## Testing

### Backend

```bash
# Unit tests
pnpm test

# E2E tests
pnpm test:e2e

# Test coverage
pnpm test:cov
```

### Frontend

```bash
# Unit tests
pnpm test

# Component tests
pnpm test:unit
```

## API Documentation

The API documentation is available through Swagger UI when running the backend:

```
http://localhost:3000/api
```

## Environment Variables

### Backend (.env)

```env
# Application
NODE_ENV=development
PORT=3000

# Database
DATABASE_URL=postgresql://username:password@localhost:5432/database_name

# JWT
JWT_SECRET=your_jwt_secret
JWT_EXPIRATION=1h

# Redis
REDIS_HOST=localhost
REDIS_PORT=6379
CACHE_TTL=300
```

## Security

- 🔒 All endpoints are protected with JWT authentication
- 👮 Role-based access control (RBAC) implementation
- ✅ Input validation using class-validator
- 🚦 Rate limiting for API endpoints
- 🌐 CORS configuration
- 🔑 Secure password hashing with bcrypt
- 🔐 Environment variable protection
- 🛡️ SQL injection prevention through TypeORM

## Contributing

1. Fork the repository
2. Create your feature branch
3. Commit your changes
4. Push to the branch
5. Create a Pull Request

## License

This project is licensed under the MIT License - see the [LICENSE](LICENSE) file for details.

## Architecture Documentation

For detailed information about the system architecture, please refer to [docs/ARCHITECTURE.md](docs/ARCHITECTURE.md).
````

## File: renovate.json
````json
{
  "$schema": "https://docs.renovatebot.com/renovate-schema.json",
  "extends": [
    "config:recommended"
  ]
}
````

## File: TODO.md
````markdown
# TODO

## General

-   Thorough security review
-   Scalability assessment
-   Comprehensive testing implementation
-   Automated deployment with CI/CD pipeline
-   Application monitoring and logging

## Customer-Facing Features

- Appointment Booking

  - Implement logic to prevent double-booking conflicts.

- Booking Management

  - Allow customers to view, modify, or cancel their bookings.

## Employee Features

- Employee Login

  - Develop login functionality for employees.

- Schedule Management

  - Create an interface for employees to view and manage their schedules.

- Availability Settings
  - Allow employees to set their availability and block out times.

## Admin Features

- User Management

  - Implement functionality to add, modify, or remove employee accounts.

- Reporting

  - Create reporting tools to generate and export reports on bookings, revenue, and employee performance.

- Service Management
  - Develop functionality to add or update services, including pricing and duration.

## Security Enhancements

- Authentication and Authorization
    - Implement bcrypt for password hashing.
    - Implement JWT refresh tokens for secure API access.
    - Implement role-based access control (RBAC) to restrict resources based on user roles.
- Input Validation
    - Use class-validator to sanitize and validate all user inputs.
    - Prevent SQL injection and XSS attacks.
- Data Protection
    - Encrypt sensitive data at rest and in transit using HTTPS with TLS.
- Rate Limiting
    - Implement rate limiting to protect against brute-force attacks.
- Audit Logging
    - Maintain logs of critical actions for auditing purposes.

## Scalability Improvements

- Stateless Backend
    - Design the backend to be stateless to facilitate horizontal scaling.
- Load Balancing
    - Use a load balancer to distribute traffic across multiple server instances.
- Caching
    - Implement caching for frequent read operations using Redis.
- Database Optimization
    - Use indexing and query optimization techniques.
    - Consider read replicas for PostgreSQL.
- Asynchronous Processing
    - Use message queues (e.g., RabbitMQ) for background tasks like sending notifications.

## Testing Improvements

- Unit Tests
    - Write comprehensive unit tests for all services, controllers, guards, and pipes.
- Integration Tests
    - Implement integration tests for API endpoints and database operations.
- End-to-End Tests
    - Create end-to-end tests for critical user flows using Cypress.

## Deployment Automation

- CI/CD Pipeline
    - Set up a CI/CD pipeline using GitHub Actions or similar.
    - Automate building, testing, and deployment processes.
- Infrastructure as Code (IaC)
    - Use Terraform or similar to manage infrastructure.

## Monitoring and Logging

- Application Monitoring
    - Use tools like Prometheus and Grafana to monitor application performance.
- Error Tracking
    - Implement Sentry or similar for error logging.
- Health Checks
    - Set up endpoint and infrastructure health checks.

## Existing Issues

- Address the CRITICAL issues listed in ISSUES.md

## Customer-Facing Features

- Appointment Booking

  - Develop the appointment booking interface.
  - Implement logic to prevent double-booking conflicts.

- Booking Management

  - Allow customers to view, modify, or cancel their bookings.

## Employee Features

- Employee Login

  - Develop login functionality for employees.

- Schedule Management

  - Create an interface for employees to view and manage their schedules.

- Availability Settings
  - Allow employees to set their availability and block out times.

## Admin Features

- User Management

  - Implement functionality to add, modify, or remove employee accounts.

- Reporting

  - Create reporting tools to generate and export reports on bookings, revenue, and employee performance.

- Service Management
  - Develop functionality to add or update services, including pricing and duration.

## Non-Functional Requirements (can be implemented in the future, not important)

- Scalability

  - Ensure the system can handle increased load and scale appropriately.

- Performance

  - Optimize the system for fast load times and responsive interactions.

- Security

  - Implement robust authentication and authorization mechanisms.
  - Protect user data and ensure compliance with data protection regulations.

- Reliability

  - Ensure high availability and fault tolerance.

## Deployment Plan

- Development Environment

  - Set up local development environments with hot-reloading for rapid development.

- Testing/Staging Environment

  - Mirror production environment for testing features before release.

- Production Environment

  - Set up live environment with robust monitoring and backup strategies.

- CI/CD Pipeline

  - Automate code building, testing, and deployment using CI/CD tools.

- Monitoring and Logging
  - Implement application monitoring, error tracking, and health checks.
````

## File: .github/workflows/repomix.yml
````yaml
name: Repository Documentation
on:
  push:
    branches:
      - main
  workflow_dispatch: # allows manual triggering
permissions:
  contents: write
  pull-requests: write
jobs:
  analyze:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0 # fetch all history for better context
      - name: Wait for other checks
        run: |
          echo "Waiting for 5 minutes to allow other checks to complete..."
          sleep 300
      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "22"
      - name: Install Repomix
        run: npm install -g repomix
      - name: Generate Repository Documentation
        run: |
          echo "Creating DOCS directory..."
          mkdir -p DOCS
          echo "Running Repomix..."
          if ! repomix --output DOCS/repository_context.txt --style markdown --remove-empty-lines --verbose; then
            echo "Error: Repomix command failed"
            # Print directory contents for debugging
            echo "DOCS directory contents:"
            ls -la DOCS/
            exit 1
          fi
          echo "Verifying output file..."
          if [ ! -f "DOCS/repository_context.txt" ]; then
            echo "Error: repository_context.txt was not created"
            # Print directory contents for debugging
            echo "DOCS directory contents:"
            ls -la DOCS/
            exit 1
          fi
          if [ ! -s "DOCS/repository_context.txt" ]; then
            echo "Error: repository_context.txt is empty"
            exit 1
          fi
          echo "Repository context file generated successfully"
          echo "File size: $(stat --format=%s "DOCS/repository_context.txt") bytes"
          echo "First few lines of the file:"
          head -n 5 "DOCS/repository_context.txt"
      # Update Documentation
      - name: Commit and Push Changes
        run: |
          echo "Configuring git..."
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "github-actions[bot]"
          echo "Checking for changes..."
          if [[ -n "$(git status --porcelain)" ]]; then
            echo "Changes detected, committing..."
            # Stage only repository_context.txt to avoid unintended changes
            if ! git add DOCS/repository_context.txt; then
              echo "Error: Failed to stage repository_context.txt"
              exit 1
            fi
            if ! git commit -m "docs: update repository context via Repomix [skip ci]"; then
              echo "Error: Failed to create commit"
              exit 1
            fi
            echo "Pushing to main branch..."
            if ! git push; then
              echo "Error: Failed to push changes"
              exit 1
            fi
            echo "Successfully updated repository context"
          else
            echo "No changes detected in repository_context.txt"
          fi
````

## File: backend/src/auth/dto/login.dto.ts
````typescript
import { ApiProperty } from "@nestjs/swagger";
import { IsEmail, IsString, MinLength } from "class-validator";
export class LoginDto {
  @ApiProperty({
    example: "user@example.com",
    description: "User email address",
  })
  @IsEmail({}, { message: "Vennligst oppgi en gyldig e-postadresse" })
  email: string;
  @ApiProperty({
    example: "Password123!",
    description: "User password (min 8 characters)",
  })
  @IsString()
  @MinLength(8, { message: "Passordet må være minst 8 tegn langt" })
  password: string;
}
````

## File: backend/src/auth/dto/register.dto.ts
````typescript
import { ApiProperty } from "@nestjs/swagger";
import {
  IsEmail,
  IsString,
  MinLength,
  IsEnum,
  IsOptional,
} from "class-validator";
import { UserRole } from "../../users/entities/user.entity";
export class RegisterDto {
  @ApiProperty({
    example: "user@example.com",
    description: "User email address",
  })
  @IsEmail({}, { message: "Vennligst oppgi en gyldig e-postadresse" })
  email: string;
  @ApiProperty({
    example: "Password123!",
    description: "User password (min 8 characters)",
  })
  @IsString()
  @MinLength(8, { message: "Passordet må være minst 8 tegn langt" })
  password: string;
  @ApiProperty({
    example: "John",
    description: "User first name",
  })
  @IsString()
  firstName: string;
  @ApiProperty({
    example: "Doe",
    description: "User last name",
  })
  @IsString()
  lastName: string;
  @ApiProperty({
    enum: UserRole,
    example: UserRole.CUSTOMER,
    description: "User role",
    default: UserRole.CUSTOMER,
  })
  @IsEnum(UserRole)
  @IsOptional()
  role?: UserRole = UserRole.CUSTOMER;
}
````

## File: backend/src/users/enums/role.enum.spec.ts
````typescript
import { Role } from "./role.enum";
describe("Role Enum", () => {
  it("should have correct values for all roles", () => {
    expect(Role.USER).toBe("user");
    expect(Role.EMPLOYEE).toBe("employee");
    expect(Role.ADMIN).toBe("admin");
  });
  it("should have exactly three roles defined", () => {
    const roleValues = Object.values(Role);
    expect(roleValues).toHaveLength(3);
    expect(roleValues).toEqual(["user", "employee", "admin"]);
  });
  it("should have correct keys matching the values", () => {
    const roleEntries = Object.entries(Role);
    expect(roleEntries).toEqual([
      ["USER", "user"],
      ["EMPLOYEE", "employee"],
      ["ADMIN", "admin"],
    ]);
  });
  it("should provide type safety through TypeScript", () => {
    let role: Role;
    role = Role.USER;
    expect(role).toBe("user");
    role = Role.EMPLOYEE;
    expect(role).toBe("employee");
    role = Role.ADMIN;
    expect(role).toBe("admin");
  });
});
````

## File: backend/.gitignore
````
.env
.env*
node_modules
````

## File: frontend/admin/src/components/base/Button.vue
````vue
<template>
  <button
    :type="props.type"
    :class="[
      'inline-flex items-center justify-center rounded-md px-4 py-2 text-sm font-medium focus:outline-none focus:ring-2 focus:ring-offset-2 disabled:opacity-50 disabled:cursor-not-allowed',
      variantClasses[props.variant],
      sizeClasses[props.size],
      props.className
    ]"
    :disabled="props.disabled || props.loading"
    @click="$emit('click', $event)"
  >
    <span v-if="props.loading" class="mr-2">
      <svg class="animate-spin h-4 w-4" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
        <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
        <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
      </svg>
    </span>
    <slot></slot>
  </button>
</template>
<script setup lang="ts">
import type { ButtonProps } from '@/types/components';
const props = withDefaults(defineProps<ButtonProps>(), {
  variant: 'primary',
  size: 'md',
  type: 'button',
  disabled: false,
  loading: false,
  className: ''
});
const emit = defineEmits<{
  (e: 'click', event: MouseEvent): void;
}>();
const variantClasses = {
  primary: 'bg-indigo-600 text-white hover:bg-indigo-700 focus:ring-indigo-500',
  secondary: 'bg-white text-gray-700 border border-gray-300 hover:bg-gray-50 focus:ring-indigo-500',
  danger: 'bg-red-600 text-white hover:bg-red-700 focus:ring-red-500'
} as const;
const sizeClasses = {
  sm: 'px-3 py-1.5 text-sm',
  md: 'px-4 py-2 text-sm',
  lg: 'px-6 py-3 text-base'
} as const;
</script>
````

## File: frontend/admin/src/stores/auth.ts
````typescript
import { defineStore } from "pinia";
import axios from "axios";
interface AuthState {
  token: string | null;
  user: User | null;
  isAuthenticated: boolean;
  error: string | null;
  isLoading: boolean;
}
interface User {
  id: string;
  email: string;
  firstName: string;
  lastName: string;
  role: "user" | "admin" | "employee";
}
interface LoginCredentials {
  email: string;
  password: string;
}
interface AuthResponse {
  token: string;
  user: User;
}
const API_URL = import.meta.env.VITE_API_URL;
// Set up axios interceptor for error handling
axios.interceptors.response.use(
  response => response,
  error => {
    if (error.response?.status === 403) {
      error.message = "Ingen tilgang: Du har ikke tillatelse til å se denne ressursen";
    }
    return Promise.reject(error);
  }
);
// Initialize axios headers if token exists
const token = localStorage.getItem("admin_token");
if (token) {
  axios.defaults.headers.common["Authorization"] = `Bearer ${token}`;
}
export const useAuthStore = defineStore("auth", {
  state: (): AuthState => ({
    token: localStorage.getItem("admin_token"),
    user: null,
    isAuthenticated: !!localStorage.getItem("admin_token"),
    error: null,
    isLoading: false,
  }),
  getters: {
    isAdmin: (state) => state.user?.role === "admin",
    isEmployee: (state) => state.user?.role === "employee",
    hasAdminAccess: (state) => state.user?.role === "admin" || state.user?.role === "employee",
  },
  actions: {
    async login(credentials: LoginCredentials): Promise<boolean> {
      try {
        this.isLoading = true;
        this.error = null;
        // Validate API_URL
        if (!API_URL) {
          throw new Error("Systemvariabler er ikke satt: Kontakt systemadministrator");
        }
        const response = await axios.post<AuthResponse>(
          `${API_URL}/auth/login`,
          credentials
        );
        const { token, user } = response.data;
        // Only allow admin and employee users to access the admin panel
        if (user.role === "user") {
          throw new Error("Ingen tilgang: Krever ansatt- eller administratortilgang");
        }
        this.token = token;
        this.user = user;
        this.isAuthenticated = true;
        // Store token in localStorage
        localStorage.setItem("admin_token", token);
        // Set default Authorization header for future requests
        axios.defaults.headers.common["Authorization"] = `Bearer ${token}`;
        return true;
      } catch (error: any) {
        console.error("Login error:", error);
        // Show backend error message if available
        if (error?.response?.data?.message) {
          const msg = error.response.data.message;
          this.error = Array.isArray(msg) ? msg.join(", ") : msg;
        }
        // Handle specific HTTP status codes
        else if (error?.response?.status) {
          switch (error.response.status) {
            case 401:
              this.error = "Feil e-postadresse eller passord";
              break;
            case 403:
              this.error = "Ingen tilgang: Krever ansatt- eller administratortilgang";
              break;
            case 404:
              this.error = "Tjenesten er ikke tilgjengelig. Vennligst prøv igjen senere";
              break;
            case 500:
              this.error = "En serverfeil har oppstått. Vennligst prøv igjen senere";
              break;
            default:
              this.error = "En feil oppstod under innlogging. Vennligst prøv igjen";
          }
        }
        // Handle network/connection errors
        else if (error?.code === "ECONNREFUSED" || error?.code === "ERR_NETWORK") {
          this.error = "Kunne ikke koble til serveren. Sjekk internettforbindelsen din";
        }
        // Handle API_URL configuration error
        else if (error?.message?.includes("Systemvariabler er ikke satt")) {
          this.error = error.message;
        }
        // Handle other errors
        else if (error instanceof Error) {
          this.error = error.message;
        }
        // Fallback error message
        else {
          this.error = "En feil oppstod under innlogging. Vennligst prøv igjen";
        }
        return false;
      } finally {
        this.isLoading = false;
      }
    },
    logout() {
      // Clear state
      this.token = null;
      this.user = null;
      this.isAuthenticated = false;
      this.error = null;
      // Remove token from localStorage
      localStorage.removeItem("admin_token");
      // Remove Authorization header
      delete axios.defaults.headers.common["Authorization"];
    },
    async checkAuth(): Promise<boolean> {
      const token = localStorage.getItem("admin_token");
      if (!token) {
        this.logout();
        return false;
      }
      // Set the Authorization header
      axios.defaults.headers.common["Authorization"] = `Bearer ${token}`;
      // If we have a token, consider the user authenticated
      // The token will be validated on API requests
      this.token = token;
      this.isAuthenticated = true;
      return true;
    },
    clearError() {
      this.error = null;
    },
  },
});
````

## File: frontend/admin/package.json
````json
{
  "name": "admin-dashboard",
  "version": "0.0.2",
  "private": true,
  "scripts": {
    "dev": "vite",
    "build": "vite build",
    "preview": "vite preview",
    "test:unit": "vitest",
    "build-only": "vite build",
    "type-check": "vue-tsc --noEmit -p tsconfig.vitest.json --composite false",
    "lint": "eslint . --ext .vue,.js,.jsx,.cjs,.mjs,.ts,.tsx,.cts,.mts --fix --ignore-path .gitignore",
    "format": "prettier --write src/"
  },
  "dependencies": {
    "@element-plus/icons-vue": "^2.3.1",
    "@types/chart.js": "^2.9.41",
    "autoprefixer": "^10.4.20",
    "axios": "^1.7.7",
    "chart.js": "^4.4.6",
    "element-plus": "^2.8.8",
    "pinia": "^2.2.6",
    "postcss": "^8.4.49",
    "tailwindcss": "^3.4.15",
    "vue": "^3.5.13",
    "vue-router": "^4.4.5"
  },
  "devDependencies": {
    "@rushstack/eslint-patch": "^1.10.4",
    "@tsconfig/node20": "^20.1.4",
    "@types/jsdom": "^21.1.7",
    "@types/node": "^22.9.0",
    "@vitejs/plugin-vue": "^5.2.0",
    "@vue/eslint-config-prettier": "^10.1.0",
    "@vue/eslint-config-typescript": "^14.1.3",
    "@vue/test-utils": "^2.4.6",
    "@vue/tsconfig": "^0.7.0",
    "eslint": "^9.15.0",
    "eslint-plugin-vue": "^9.31.0",
    "jsdom": "^26.0.0",
    "prettier": "^3.3.3",
    "typescript": "~5.8.0",
    "vite": "^6.0.0",
    "vitest": "^3.0.0",
    "vue-tsc": "^2.1.10"
  }
}
````

## File: docker-compose.yml
````yaml
version: '3.8'
services:
  backend:
    build:
      context: .
      dockerfile: Dockerfile
      target: backend-builder
    environment:
      - NODE_ENV=production
      - PORT=3000
      - DATABASE_URL=${DATABASE_URL}
      - JWT_SECRET=${JWT_SECRET}
      - JWT_EXPIRATION=${JWT_EXPIRATION}
      - REDIS_HOST=${REDIS_HOST}
      - REDIS_PORT=${REDIS_PORT}
      - CACHE_TTL=${CACHE_TTL}
    ports:
      - "3000:3000"
    depends_on:
      - db
      - redis
  frontend:
    build:
      context: .
      dockerfile: Dockerfile
      target: frontend-builder
    environment:
      - NODE_ENV=production
      - VITE_API_URL=${VITE_API_URL}
    ports:
      - "5173:5173"
    depends_on:
      - backend
  db:
    image: postgres:17
    environment:
      - POSTGRES_USER=${POSTGRES_USER}
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
      - POSTGRES_DB=${POSTGRES_DB}
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data
  redis:
    image: redis:8
    ports:
      - "6379:6379"
volumes:
  postgres_data:
````

## File: backend/src/auth/auth.service.ts
````typescript
import {
  Injectable,
  UnauthorizedException,
  ConflictException,
  InternalServerErrorException,
} from "@nestjs/common";
import { JwtService } from "@nestjs/jwt";
import * as bcrypt from "bcrypt";
import { UsersService } from "../users/users.service";
import { LoginDto, RegisterDto } from "./dto";
import { AuthResponse, JwtPayload } from "./interfaces/auth.interface";
import { User } from "../users/entities/user.entity";
@Injectable()
export class AuthService {
  constructor(
    private readonly usersService: UsersService,
    private readonly jwtService: JwtService,
  ) {}
  async register(registerDto: RegisterDto): Promise<AuthResponse> {
    try {
      const existingUser = await this.usersService.findByEmail(
        registerDto.email,
      );
      if (existingUser) {
        throw new ConflictException("E-postadressen er allerede i bruk");
      }
      const hashedPassword = await bcrypt.hash(registerDto.password, 10);
      const user = await this.usersService.create({
        ...registerDto,
        password: hashedPassword,
      });
      const token = this.generateToken(user);
      const userWithoutPassword = this.excludePassword(user);
      return {
        user: userWithoutPassword,
        token,
      };
    } catch (error: unknown) {
      if (error instanceof ConflictException) {
        throw error;
      }
      if (error instanceof Error) {
        throw new InternalServerErrorException(error.message);
      }
      throw new InternalServerErrorException("Feil under registrering");
    }
  }
  async login(loginDto: LoginDto): Promise<AuthResponse> {
    try {
      const user = await this.usersService.findByEmail(loginDto.email);
      if (!user) {
        throw new UnauthorizedException("Ugyldige innloggingsdetaljer");
      }
      const isPasswordValid = await bcrypt.compare(
        loginDto.password,
        user.password,
      );
      if (!isPasswordValid) {
        throw new UnauthorizedException("Invalid credentials");
      }
      const token = this.generateToken(user);
      const userWithoutPassword = this.excludePassword(user);
      return {
        user: userWithoutPassword,
        token,
      };
    } catch (error: unknown) {
      if (error instanceof UnauthorizedException) {
        throw error;
      }
      if (error instanceof Error) {
        throw new InternalServerErrorException(error.message);
      }
      throw new InternalServerErrorException("Feil under innlogging");
    }
  }
  private generateToken(user: User): string {
    const payload: JwtPayload = {
      sub: user.id,
      email: user.email,
      role: user.role,
    };
    const token: string = this.jwtService.sign(payload);
    return token;
  }
  private excludePassword<T extends { password: string }>(user: T): Omit<T, 'password'> {
    // eslint-disable-next-line @typescript-eslint/no-unused-vars
    const { password, ...userWithoutPassword } = user;
    return userWithoutPassword;
  }
}
````

## File: backend/package.json
````json
{
  "name": "backend",
  "version": "0.0.4",
  "description": "Hair Salon Booking System Backend",
  "author": "",
  "private": true,
  "license": "MIT",
  "scripts": {
    "build": "nest build",
    "format": "prettier --write \"src/**/*.ts\" \"test/**/*.ts\"",
    "start": "nest start",
    "start:dev": "nest start --watch",
    "start:debug": "nest start --debug --watch",
    "start:prod": "node dist/main",
    "lint": "eslint \"{src,apps,libs,test}/**/*.ts\" --fix",
    "lint:strict": "eslint \"{src,apps,libs,test}/**/*.ts\" --max-warnings 0",
    "test": "jest",
    "test:watch": "jest --watch",
    "test:cov": "jest --coverage",
    "test:debug": "node --inspect-brk -r tsconfig-paths/register -r ts-node/register node_modules/.bin/jest --runInBand",
    "test:e2e": "jest --config ./test/jest-e2e.json",
    "typeorm": "ts-node ./node_modules/typeorm/cli.js",
    "migration:create": "npm run typeorm -- migration:create",
    "migration:generate": "npm run typeorm -- migration:generate -d typeorm.config.ts",
    "migration:run": "npm run typeorm -- migration:run -d typeorm.config.ts",
    "migration:revert": "npm run typeorm -- migration:revert -d typeorm.config.ts",
    "seed": "ts-node src/database/seeds/run-seeds.ts",
    "seed:admin-password": "ts-node src/database/seeds/update-admin-password-runner.ts",
    "verify:admin-password": "ts-node src/database/seeds/verify-admin-password.ts",
    "remove-admin": "ts-node src/database/seeds/remove-admin-user.ts"
  },
  "dependencies": {
    "@nestjs/cache-manager": "^3.0.1",
    "@nestjs/common": "^11.0.0",
    "@nestjs/config": "^4.0.0",
    "@nestjs/core": "^11.0.0",
    "@nestjs/jwt": "^11.0.0",
    "@nestjs/mapped-types": "^2.0.6",
    "@nestjs/passport": "^11.0.0",
    "@nestjs/platform-express": "^11.0.0",
    "@nestjs/swagger": "^11.0.0",
    "@nestjs/typeorm": "^11.0.0",
    "bcrypt": "^5.1.1",
    "cache-manager": "6.4.3",
    "class-transformer": "^0.5.1",
    "class-validator": "^0.14.1",
    "dotenv": "^16.4.5",
    "passport": "^0.7.0",
    "passport-jwt": "^4.0.1",
    "pg": "^8.13.1",
    "reflect-metadata": "^0.2.2",
    "rxjs": "^7.8.1",
    "typeorm": "^0.3.20"
  },
  "devDependencies": {
    "@faker-js/faker": "^9.2.0",
    "@nestjs/cli": "^11.0.0",
    "@nestjs/schematics": "^11.0.0",
    "@nestjs/testing": "^11.0.0",
    "@types/bcrypt": "^5.0.2",
    "@types/cache-manager": "^5.0.0",
    "@types/express": "^5.0.0",
    "@types/jest": "^29.5.14",
    "@types/node": "^22.10.0",
    "@types/passport-jwt": "^4.0.1",
    "@types/supertest": "^6.0.2",
    "@typescript-eslint/eslint-plugin": "^8.15.0",
    "@typescript-eslint/parser": "^8.16.0",
    "eslint": "^9.15.0",
    "eslint-config-prettier": "^10.0.0",
    "eslint-plugin-prettier": "^5.2.1",
    "jest": "^29.7.0",
    "prettier": "^3.4.1",
    "source-map-support": "^0.5.21",
    "supertest": "^7.0.0",
    "ts-jest": "^29.2.5",
    "ts-loader": "^9.5.1",
    "ts-node": "^10.9.2",
    "tsconfig-paths": "^4.2.0",
    "typescript": "^5.7.2"
  }
}
````

## File: frontend/admin/.env.example
````
# Example environment variables for the Hair Salon Booking Admin Dashboard

# Base URL for the backend API
VITE_API_URL=http://localhost:3000/api
````

## File: frontend/customer/package.json
````json
{
  "name": "customer-frontend",
  "version": "0.0.1",
  "private": true,
  "type": "module",
  "scripts": {
    "dev": "vite",
    "build": "run-p type-check \"build-only {@}\" --",
    "preview": "vite preview",
    "test:unit": "vitest",
    "test:e2e": "start-server-and-test preview http://localhost:4173 'cypress run --e2e'",
    "test:e2e:dev": "start-server-and-test 'vite dev --port 4173' http://localhost:4173 'cypress open --e2e'",
    "build-only": "vite build",
    "type-check": "vue-tsc --build --force",
    "lint": "eslint . --fix",
    "format": "prettier --write src/"
  },
  "dependencies": {
    "axios": "^1.7.8",
    "pinia": "^2.2.6",
    "vue": "^3.5.13",
    "vue-router": "^4.4.5"
  },
  "devDependencies": {
    "@pinia/testing": "^1.0.0",
    "@tsconfig/node22": "^22.0.0",
    "@types/jsdom": "^21.1.7",
    "@types/node": "^22.9.2",
    "@vitejs/plugin-vue": "^5.1.4",
    "@vitest/coverage-v8": "3.2.3",
    "@vitest/eslint-plugin": "1.2.1",
    "@vue/eslint-config-prettier": "^10.1.0",
    "@vue/eslint-config-typescript": "^14.1.3",
    "@vue/test-utils": "^2.4.6",
    "@vue/tsconfig": "^0.7.0",
    "autoprefixer": "^10.4.20",
    "cypress": "^14.0.0",
    "eslint": "^9.14.0",
    "eslint-plugin-cypress": "^4.1.0",
    "eslint-plugin-vue": "^9.30.0",
    "jsdom": "^26.0.0",
    "npm-run-all2": "^8.0.0",
    "postcss": "^8.4.49",
    "prettier": "^3.3.3",
    "start-server-and-test": "^2.0.8",
    "tailwindcss": "^3.4.15",
    "typescript": "~5.8.0",
    "vite": "^6.0.0",
    "vite-plugin-vue-devtools": "^7.5.4",
    "vitest": "^3.0.0",
    "vue-tsc": "^2.1.10"
  }
}
````
